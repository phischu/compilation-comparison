{"sliceID":6913912590829791832,"uses":[{"reference":{"otherSlice":13410505313944458},"usedName":{"constructorName":{"identifier":"Bin"},"constructorTypeName":{"identifier":"IntMap"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">="}},"qualification":null},{"reference":{"otherSlice":4609286002637564688},"usedName":{"constructorName":{"operator":":*:"},"constructorTypeName":{"identifier":"StrictPair"}},"qualification":null},{"reference":{"otherSlice":1752801341487989849},"usedName":{"valueName":{"identifier":"union"}},"qualification":null},{"reference":{"otherSlice":2715173166319551379},"usedName":{"valueName":{"identifier":"nomatch"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">"}},"qualification":null},{"reference":{"otherSlice":13410505313944458},"usedName":{"constructorName":{"identifier":"Nil"},"constructorTypeName":{"identifier":"IntMap"}},"qualification":null},{"reference":{"otherSlice":4717645055143425729},"usedName":{"valueName":{"identifier":"zero"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":13410505313944458},"usedName":{"constructorName":{"identifier":"Tip"},"constructorTypeName":{"identifier":"IntMap"}},"qualification":null},{"reference":{"otherSlice":879198285250991989},"usedName":{"typeName":{"identifier":"Key"}},"qualification":null},{"reference":{"otherSlice":13410505313944458},"usedName":{"typeName":{"identifier":"IntMap"}},"qualification":null}],"fragment":["split :: Key -> IntMap a -> (IntMap a, IntMap a)","split k t\n  = case t of\n        Bin _ m l r | m < 0 ->\n                      if k >= 0 then\n                        case go k l of\n                            (lt :*: gt) -> let !lt' = union r lt in (lt', gt)\n                        else\n                        case go k r of\n                            (lt :*: gt) -> let !gt' = union gt l in (lt, gt')\n        _ -> case go k t of\n                 (lt :*: gt) -> (lt, gt)\n  where go k' t'@(Bin p m l r)\n          | nomatch k' p m = if k' > p then t' :*: Nil else Nil :*: t'\n          | zero k' m =\n            case go k' l of\n                (lt :*: gt) -> lt :*: union gt r\n          | otherwise =\n            case go k' r of\n                (lt :*: gt) -> union l lt :*: gt\n        go k' t'@(Tip ky _)\n          | k' > ky = (t' :*: Nil)\n          | k' < ky = (Nil :*: t')\n          | otherwise = (Nil :*: Nil)\n        go _ Nil = (Nil :*: Nil)"],"instances":[],"language":{"extensions":["BangPatterns","MagicHash","DeriveDataTypeable","StandaloneDeriving","ScopedTypeVariables","TypeFamilies","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
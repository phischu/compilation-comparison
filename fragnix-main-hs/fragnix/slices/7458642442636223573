{"sliceID":7458642442636223573,"uses":[{"reference":{"otherSlice":3215441896288524948},"usedName":{"constructorName":{"identifier":"Bin"},"constructorTypeName":{"identifier":"IntMap"}},"qualification":null},{"reference":{"otherSlice":6975147794617379683},"usedName":{"valueName":{"identifier":"shorter"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":2654114007802303743},"usedName":{"valueName":{"identifier":"nomatch"}},"qualification":null},{"reference":{"otherSlice":4724247418787711009},"usedName":{"valueName":{"identifier":"zero"}},"qualification":null},{"reference":{"otherSlice":3215441896288524948},"usedName":{"constructorName":{"identifier":"Tip"},"constructorTypeName":{"identifier":"IntMap"}},"qualification":null},{"reference":{"otherSlice":3215441896288524948},"usedName":{"constructorName":{"identifier":"Nil"},"constructorTypeName":{"identifier":"IntMap"}},"qualification":null},{"reference":{"otherSlice":9197541295180993364},"usedName":{"valueName":{"identifier":"link"}},"qualification":null},{"reference":{"otherSlice":3752227670748546116},"usedName":{"typeName":{"identifier":"Prefix"}},"qualification":null},{"reference":{"otherSlice":1461218703602982808},"usedName":{"typeName":{"identifier":"Mask"}},"qualification":null},{"reference":{"otherSlice":3215441896288524948},"usedName":{"typeName":{"identifier":"IntMap"}},"qualification":null}],"fragment":["mergeWithKey' ::\n              (Prefix -> Mask -> IntMap c -> IntMap c -> IntMap c) ->\n                (IntMap a -> IntMap b -> IntMap c) ->\n                  (IntMap a -> IntMap c) ->\n                    (IntMap b -> IntMap c) -> IntMap a -> IntMap b -> IntMap c","mergeWithKey' bin' f g1 g2 = go\n  where go t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)\n          | shorter m1 m2 = merge1\n          | shorter m2 m1 = merge2\n          | p1 == p2 = bin' p1 m1 (go l1 l2) (go r1 r2)\n          | otherwise = maybe_link p1 (g1 t1) p2 (g2 t2)\n          where merge1\n                  | nomatch p2 p1 m1 = maybe_link p1 (g1 t1) p2 (g2 t2)\n                  | zero p2 m1 = bin' p1 m1 (go l1 t2) (g1 r1)\n                  | otherwise = bin' p1 m1 (g1 l1) (go r1 t2)\n                merge2\n                  | nomatch p1 p2 m2 = maybe_link p1 (g1 t1) p2 (g2 t2)\n                  | zero p1 m2 = bin' p2 m2 (go t1 l2) (g2 r2)\n                  | otherwise = bin' p2 m2 (g2 l2) (go t1 r2)\n        go t1'@(Bin _ _ _ _) t2'@(Tip k2' _) = merge t2' k2' t1'\n          where merge t2 k2 t1@(Bin p1 m1 l1 r1)\n                  | nomatch k2 p1 m1 = maybe_link p1 (g1 t1) k2 (g2 t2)\n                  | zero k2 m1 = bin' p1 m1 (merge t2 k2 l1) (g1 r1)\n                  | otherwise = bin' p1 m1 (g1 l1) (merge t2 k2 r1)\n                merge t2 k2 t1@(Tip k1 _)\n                  | k1 == k2 = f t1 t2\n                  | otherwise = maybe_link k1 (g1 t1) k2 (g2 t2)\n                merge t2 _ Nil = g2 t2\n        go t1@(Bin _ _ _ _) Nil = g1 t1\n        go t1'@(Tip k1' _) t2' = merge t1' k1' t2'\n          where merge t1 k1 t2@(Bin p2 m2 l2 r2)\n                  | nomatch k1 p2 m2 = maybe_link k1 (g1 t1) p2 (g2 t2)\n                  | zero k1 m2 = bin' p2 m2 (merge t1 k1 l2) (g2 r2)\n                  | otherwise = bin' p2 m2 (g2 l2) (merge t1 k1 r2)\n                merge t1 k1 t2@(Tip k2 _)\n                  | k1 == k2 = f t1 t2\n                  | otherwise = maybe_link k1 (g1 t1) k2 (g2 t2)\n                merge t1 _ Nil = g1 t1\n        go Nil t2 = g2 t2\n        maybe_link _ Nil _ t2 = t2\n        maybe_link _ t1 _ Nil = t1\n        maybe_link p1 t1 p2 t2 = link p1 t1 p2 t2\n        \n        {-# INLINE maybe_link #-}"],"instances":[],"language":{"extensions":["MagicHash","DeriveDataTypeable","StandaloneDeriving","ScopedTypeVariables","TypeFamilies","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
{"sliceID":7846132414086270978,"uses":[{"reference":{"otherSlice":2051332017860334620},"usedName":{"typeName":{"identifier":"Hashable"}},"qualification":null},{"reference":{"otherSlice":1013433531415570027},"usedName":{"typeName":{"identifier":"HashMap"}},"qualification":null},{"reference":{"otherSlice":880202317694872316},"usedName":{"valueName":{"identifier":"toList'"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"otherSlice":1013433531415570027},"usedName":{"constructorName":{"identifier":"Leaf"},"constructorTypeName":{"identifier":"HashMap"}},"qualification":null},{"reference":{"otherSlice":1013433531415570027},"usedName":{"constructorName":{"identifier":"Collision"},"constructorTypeName":{"identifier":"HashMap"}},"qualification":null},{"reference":{"otherSlice":2051332017860334620},"usedName":{"valueName":{"identifier":"hashWithSalt"}},"qualification":"H"},{"reference":{"otherSlice":9205917895425065335},"usedName":{"typeName":{"identifier":"Leaf"}},"qualification":null},{"reference":{"otherSlice":9205917895425065335},"usedName":{"constructorName":{"identifier":"L"},"constructorTypeName":{"identifier":"Leaf"}},"qualification":null},{"reference":{"otherSlice":7421561743090722311},"usedName":{"typeName":{"identifier":"Array"}},"qualification":"A"},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"foldl'"}},"qualification":"L"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"Data.List"},"usedName":{"valueName":{"identifier":"sort"}},"qualification":"L"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":"L"},{"reference":{"otherSlice":6699099996820754610},"usedName":{"valueName":{"identifier":"toList"}},"qualification":"A"}],"fragment":["instance (Hashable k, Hashable v) => Hashable (HashMap k v) where\n        hashWithSalt salt hm = go salt (toList' hm [])\n          where go :: Int -> [HashMap k v] -> Int\n                go s [] = s\n                go s (Leaf _ l : tl) = s `hashLeafWithSalt` l `go` tl\n                go s (Collision h a : tl)\n                  = (s `H.hashWithSalt` h) `hashCollisionWithSalt` a `go` tl\n                go s (_ : tl) = s `go` tl\n                \n                hashLeafWithSalt :: Int -> Leaf k v -> Int\n                hashLeafWithSalt s (L k v)\n                  = s `H.hashWithSalt` k `H.hashWithSalt` v\n                \n                hashCollisionWithSalt :: Int -> A.Array (Leaf k v) -> Int\n                hashCollisionWithSalt s\n                  = L.foldl' H.hashWithSalt s . arrayHashesSorted s\n                \n                arrayHashesSorted :: Int -> A.Array (Leaf k v) -> [Int]\n                arrayHashesSorted s\n                  = L.sort . L.map (hashLeafWithSalt s) . A.toList"],"instances":[],"language":{"extensions":["BangPatterns","DeriveDataTypeable","MagicHash","ScopedTypeVariables","PatternGuards","RoleAnnotations","TypeFamilies","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll"],"isInstance":true}}
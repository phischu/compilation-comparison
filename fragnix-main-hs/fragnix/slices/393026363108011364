{"sliceID":393026363108011364,"uses":[{"reference":{"builtinModule":"GHC.MVar"},"usedName":{"valueName":{"identifier":"newEmptyMVar"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"newIORef"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Left"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"builtinModule":"Control.Exception.Base"},"usedName":{"valueName":{"identifier":"try"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"writeIORef"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"error"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"builtinModule":"GHC.Show"},"usedName":{"valueName":{"identifier":"show"}},"qualification":null},{"reference":{"builtinModule":"GHC.Exception"},"usedName":{"typeName":{"identifier":"SomeException"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Right"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO"},"usedName":{"valueName":{"identifier":"mask_"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"void"}},"qualification":null},{"reference":{"builtinModule":"GHC.Conc.Sync"},"usedName":{"valueName":{"identifier":"forkIO"}},"qualification":null},{"reference":{"builtinModule":"GHC.MVar"},"usedName":{"valueName":{"identifier":"takeMVar"}},"qualification":null},{"reference":{"otherSlice":5941859465781839543},"usedName":{"valueName":{"identifier":"catchSome"}},"qualification":null},{"reference":{"otherSlice":9136188995874768763},"usedName":{"valueName":{"identifier":"updateAction"}},"qualification":null},{"reference":{"builtinModule":"GHC.MVar"},"usedName":{"valueName":{"identifier":"putMVar"}},"qualification":null},{"reference":{"builtinModule":"GHC.Conc.IO"},"usedName":{"valueName":{"identifier":"threadDelay"}},"qualification":null},{"reference":{"otherSlice":9136188995874768763},"usedName":{"valueName":{"identifier":"updateFreq"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"readIORef"}},"qualification":null},{"reference":{"builtinModule":"GHC.MVar"},"usedName":{"valueName":{"identifier":"tryPutMVar"}},"qualification":null},{"reference":{"builtinModule":"GHC.MVar"},"usedName":{"valueName":{"identifier":"readMVar"}},"qualification":null},{"reference":{"otherSlice":9136188995874768763},"usedName":{"typeName":{"identifier":"UpdateSettings"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null}],"fragment":["mkAutoUpdate :: UpdateSettings a -> IO (IO a)","mkAutoUpdate us\n  = do needsRunning <- newEmptyMVar\n       responseVar0 <- newEmptyMVar\n       currRef <- newIORef $ Left responseVar0\n       let fillRefOnExit f\n             = do eres <- try f\n                  case eres of\n                      Left e -> writeIORef currRef $\n                                  error $\n                                    \"Control.AutoUpdate.mkAutoUpdate: worker thread exited with exception: \"\n                                      ++ show (e :: SomeException)\n                      Right () -> writeIORef currRef $\n                                    error $\n                                      \"Control.AutoUpdate.mkAutoUpdate: worker thread exited normally, \"\n                                        ++\n                                        \"which should be impossible due to usage of infinite loop\"\n       mask_ $\n         void $\n           forkIO $\n             fillRefOnExit $\n               do let loop responseVar\n                        = do takeMVar needsRunning\n                             a <- catchSome $ updateAction us\n                             writeIORef currRef $ Right a\n                             putMVar responseVar a\n                             threadDelay $ updateFreq us\n                             responseVar' <- newEmptyMVar\n                             writeIORef currRef $ Left responseVar'\n                             loop responseVar'\n                  loop responseVar0\n       return $\n         do mval <- readIORef currRef\n            case mval of\n                Left responseVar -> do void $ tryPutMVar needsRunning ()\n                                       readMVar responseVar\n                Right val -> return val"],"instances":[],"language":{"extensions":["MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
{"sliceID":638205510225586485,"uses":[{"reference":{"otherSlice":7459617743278403755},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"B"},{"reference":{"otherSlice":4010822550476529195},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":null},{"reference":{"otherSlice":2693425842868906517},"usedName":{"typeName":{"identifier":"CodePoint"}},"qualification":null},{"reference":{"otherSlice":6105909393245305947},"usedName":{"typeName":{"identifier":"DecoderState"}},"qualification":null},{"reference":{"otherSlice":826793438556564055},"usedName":{"typeName":{"identifier":"Decoding"}},"qualification":null},{"reference":{"otherSlice":4010822550476529195},"usedName":{"constructorName":{"identifier":"PS"},"constructorTypeName":{"identifier":"ByteString"}},"qualification":null},{"reference":{"builtinModule":"GHC.ST"},"usedName":{"valueName":{"identifier":"runST"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO"},"usedName":{"valueName":{"identifier":"unsafeIOToST"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"=<<"}},"qualification":null},{"reference":{"otherSlice":5202209142239390005},"usedName":{"valueName":{"identifier":"new"}},"qualification":"A"},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":7847819776717226819},"usedName":{"typeName":{"identifier":"MArray"}},"qualification":"A"},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"builtinModule":"Foreign.ForeignPtr"},"usedName":{"valueName":{"identifier":"withForeignPtr"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Marshal.Utils"},"usedName":{"valueName":{"identifier":"with"}},"qualification":null},{"reference":{"builtinModule":"Foreign.C.Types"},"usedName":{"typeName":{"identifier":"CSize"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"nullPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"plusPtr"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Storable"},"usedName":{"valueName":{"identifier":"poke"}},"qualification":null},{"reference":{"otherSlice":3309608989231307358},"usedName":{"valueName":{"identifier":"c_decode_utf8_with_state"}},"qualification":null},{"reference":{"otherSlice":7847819776717226819},"usedName":{"valueName":{"identifier":"maBA"}},"qualification":"A"},{"reference":{"builtinModule":"Foreign.Storable"},"usedName":{"valueName":{"identifier":"peek"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO"},"usedName":{"valueName":{"identifier":"unsafeSTToIO"}},"qualification":null},{"reference":{"otherSlice":6830589594641922584},"usedName":{"valueName":{"identifier":"unsafeWrite"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"otherSlice":8720616505311582446},"usedName":{"valueName":{"identifier":"safe"}},"qualification":null},{"reference":{"otherSlice":2599347847448508561},"usedName":{"valueName":{"identifier":"unsafeFreeze"}},"qualification":"A"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$!"}},"qualification":null},{"reference":{"otherSlice":8422374095318209233},"usedName":{"valueName":{"identifier":"text"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"minusPtr"}},"qualification":null},{"reference":{"otherSlice":6987230544343436129},"usedName":{"valueName":{"identifier":"append"}},"qualification":"B"},{"reference":{"otherSlice":3748312495235440417},"usedName":{"valueName":{"identifier":"drop"}},"qualification":"B"},{"reference":{"otherSlice":826793438556564055},"usedName":{"constructorName":{"identifier":"Some"},"constructorTypeName":{"identifier":"Decoding"}},"qualification":null},{"reference":{"otherSlice":8110432003699438363},"usedName":{"typeName":{"identifier":"OnDecodeError"}},"qualification":null}],"fragment":["streamDecodeUtf8With :: OnDecodeError -> ByteString -> Decoding","streamDecodeUtf8With onErr = decodeChunk B.empty 0 0\n  where decodeChunk ::\n                    ByteString -> CodePoint -> DecoderState -> ByteString -> Decoding\n        decodeChunk undecoded0 codepoint0 state0 bs@(PS fp off len)\n          = runST $ (unsafeIOToST . decodeChunkToBuffer) =<< A.new (len + 1)\n          where decodeChunkToBuffer :: A.MArray s -> IO Decoding\n                decodeChunkToBuffer dest\n                  = withForeignPtr fp $\n                      \\ ptr ->\n                        with (0 :: CSize) $\n                          \\ destOffPtr ->\n                            with codepoint0 $\n                              \\ codepointPtr ->\n                                with state0 $\n                                  \\ statePtr ->\n                                    with nullPtr $\n                                      \\ curPtrPtr ->\n                                        let end = ptr `plusPtr` (off + len)\n                                            loop curPtr\n                                              = do poke curPtrPtr curPtr\n                                                   curPtr' <- c_decode_utf8_with_state (A.maBA dest)\n                                                                destOffPtr\n                                                                curPtrPtr\n                                                                end\n                                                                codepointPtr\n                                                                statePtr\n                                                   state <- peek statePtr\n                                                   case state of\n                                                       12 -> do x <- peek curPtr'\n                                                                poke statePtr 0\n                                                                case onErr desc (Just x) of\n                                                                    Nothing -> loop $\n                                                                                 curPtr' `plusPtr` 1\n                                                                    Just c -> do destOff <- peek\n                                                                                              destOffPtr\n                                                                                 w <- unsafeSTToIO $\n                                                                                        unsafeWrite\n                                                                                          dest\n                                                                                          (fromIntegral\n                                                                                             destOff)\n                                                                                          (safe c)\n                                                                                 poke destOffPtr\n                                                                                   (destOff +\n                                                                                      fromIntegral\n                                                                                        w)\n                                                                                 loop $\n                                                                                   curPtr' `plusPtr`\n                                                                                     1\n                                                       _ -> do n <- peek destOffPtr\n                                                               codepoint <- peek codepointPtr\n                                                               chunkText <- unsafeSTToIO $\n                                                                              do arr <- A.unsafeFreeze\n                                                                                          dest\n                                                                                 return $!\n                                                                                   text arr 0\n                                                                                     (fromIntegral\n                                                                                        n)\n                                                               lastPtr <- peek curPtrPtr\n                                                               let left = lastPtr `minusPtr` curPtr\n                                                                   !undecoded\n                                                                     = case state of\n                                                                           0 -> B.empty\n                                                                           _ -> B.append undecoded0\n                                                                                  (B.drop left bs)\n                                                               return $\n                                                                 Some chunkText undecoded\n                                                                   (decodeChunk undecoded codepoint\n                                                                      state)\n                                          in loop (ptr `plusPtr` off)\n        desc\n          = \"Data.Text.Internal.Encoding.streamDecodeUtf8With: Invalid UTF-8 stream\""],"instances":[],"language":{"extensions":["BangPatterns","ForeignFunctionInterface","GeneralizedNewtypeDeriving","MagicHash","UnliftedFFITypes","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
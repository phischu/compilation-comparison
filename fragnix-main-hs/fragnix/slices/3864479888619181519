{"sliceID":3864479888619181519,"uses":[{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"newIORef"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"readIORef"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":65946078234120494},"usedName":{"valueName":{"identifier":"unsafeFreezeNonEmptyBuffer"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Left"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":6766449275992946084},"usedName":{"valueName":{"identifier":"unBuilder"}},"qualification":null},{"reference":{"otherSlice":2931540031717686030},"usedName":{"valueName":{"identifier":"buildStep"}},"qualification":null},{"reference":{"otherSlice":2921932848836490295},"usedName":{"constructorName":{"identifier":"BufRange"},"constructorTypeName":{"identifier":"BufRange"}},"qualification":null},{"reference":{"otherSlice":3030113937244366044},"usedName":{"constructorName":{"identifier":"Done"},"constructorTypeName":{"identifier":"BuildSignal"}},"qualification":null},{"reference":{"otherSlice":1169045707755494571},"usedName":{"valueName":{"identifier":"execBuildStep"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"writeIORef"}},"qualification":null},{"reference":{"otherSlice":6580852673642738549},"usedName":{"valueName":{"identifier":"updateEndOfSlice"}},"qualification":null},{"reference":{"otherSlice":2109377013281436257},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"S"},{"reference":{"otherSlice":3030113937244366044},"usedName":{"constructorName":{"identifier":"BufferFull"},"constructorTypeName":{"identifier":"BuildSignal"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"not"}},"qualification":null},{"reference":{"otherSlice":675696118971413715},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"otherSlice":3030113937244366044},"usedName":{"constructorName":{"identifier":"InsertByteString"},"constructorTypeName":{"identifier":"BuildSignal"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Right"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":3211694381570655447},"usedName":{"typeName":{"identifier":"BufferAllocStrategy"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"otherSlice":1334175715744687275},"usedName":{"typeName":{"identifier":"BlazeRecv"}},"qualification":null},{"reference":{"otherSlice":2542626151079315638},"usedName":{"typeName":{"identifier":"BlazeFinish"}},"qualification":null}],"fragment":["newBlazeRecv :: BufferAllocStrategy -> IO (BlazeRecv, BlazeFinish)","newBlazeRecv (ioBufInit, nextBuf)\n  = do refBuf <- newIORef ioBufInit\n       return (push refBuf, finish refBuf)\n  where finish refBuf\n          = do ioBuf <- readIORef refBuf\n               buf <- ioBuf\n               return $ unsafeFreezeNonEmptyBuffer buf\n        push refBuf builder\n          = do refStep <- newIORef $\n                            Left $ unBuilder builder (buildStep finalStep)\n               return $ popper refBuf refStep\n          where finalStep !(BufRange pf _) = return $ Done pf ()\n        popper refBuf refStep\n          = do ioBuf <- readIORef refBuf\n               ebStep <- readIORef refStep\n               case ebStep of\n                   Left bStep -> do !buf <- ioBuf\n                                    signal <- execBuildStep bStep buf\n                                    case signal of\n                                        Done op' _ -> do writeIORef refBuf $\n                                                           return $ updateEndOfSlice buf op'\n                                                         return S.empty\n                                        BufferFull minSize op' bStep' -> do let buf'\n                                                                                  = updateEndOfSlice\n                                                                                      buf\n                                                                                      op'\n                                                                                {-# INLINE cont #-}\n                                                                                cont mbs\n                                                                                  = do ioBuf' <- nextBuf\n                                                                                                   minSize\n                                                                                                   buf'\n                                                                                       writeIORef\n                                                                                         refBuf\n                                                                                         ioBuf'\n                                                                                       writeIORef\n                                                                                         refStep\n                                                                                         $\n                                                                                         Left bStep'\n                                                                                       case mbs of\n                                                                                           Just\n                                                                                             bs | not\n                                                                                                    $\n                                                                                                    S.null\n                                                                                                      bs\n                                                                                                  ->\n                                                                                                  return\n                                                                                                    bs\n                                                                                           _ -> popper\n                                                                                                  refBuf\n                                                                                                  refStep\n                                                                            cont $\n                                                                              unsafeFreezeNonEmptyBuffer\n                                                                                buf'\n                                        InsertByteString op' bs bStep' -> do let buf'\n                                                                                   = updateEndOfSlice\n                                                                                       buf\n                                                                                       op'\n                                                                             let yieldBS\n                                                                                   = do nextBuf 1\n                                                                                          buf'\n                                                                                          >>=\n                                                                                          writeIORef\n                                                                                            refBuf\n                                                                                        writeIORef\n                                                                                          refStep\n                                                                                          $\n                                                                                          Left\n                                                                                            bStep'\n                                                                                        if S.null bs\n                                                                                          then\n                                                                                          popper\n                                                                                            refBuf\n                                                                                            refStep\n                                                                                          else\n                                                                                          return bs\n                                                                             case\n                                                                               unsafeFreezeNonEmptyBuffer\n                                                                                 buf'\n                                                                               of\n                                                                                 Nothing -> yieldBS\n                                                                                 Just\n                                                                                   bs' -> do writeIORef\n                                                                                               refStep\n                                                                                               $\n                                                                                               Right\n                                                                                                 yieldBS\n                                                                                             return\n                                                                                               bs'\n                   Right action -> action"],"instances":[],"language":{"extensions":["FlexibleContexts","BangPatterns","RankNTypes","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
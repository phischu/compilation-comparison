{"sliceID":5147089479892133116,"uses":[{"reference":{"otherSlice":7072387134939381410},"usedName":{"constructorName":{"identifier":"DecompressInputRequired"},"constructorTypeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":3121151904321032761},"usedName":{"valueName":{"identifier":"mkStateST"}},"qualification":null},{"reference":{"otherSlice":1456959894529533239},"usedName":{"valueName":{"identifier":"decompressStream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":608743565900166835},"usedName":{"valueName":{"identifier":"runStreamST"}},"qualification":null},{"reference":{"otherSlice":7202692338078551997},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"otherSlice":7072387134939381410},"usedName":{"typeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"otherSlice":1394949281745390129},"usedName":{"typeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"otherSlice":1705518718783831717},"usedName":{"typeName":{"identifier":"State"}},"qualification":"Stream"},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad.ST.Lazy"},"usedName":{"typeName":{"identifier":"ST"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":7072387134939381410},"usedName":{"constructorName":{"identifier":"DecompressOutputAvailable"},"constructorTypeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"otherSlice":7072387134939381410},"usedName":{"constructorName":{"identifier":"DecompressStreamEnd"},"constructorTypeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":1769976971367097781},"usedName":{"valueName":{"identifier":"gzipFormat"}},"qualification":"Stream"},{"reference":{"otherSlice":3205252498693512578},"usedName":{"valueName":{"identifier":"decompressAllMembers"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"not"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":7072387134939381410},"usedName":{"constructorName":{"identifier":"DecompressStreamError"},"constructorTypeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"otherSlice":4010822550476529195},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"otherSlice":7235567377809295464},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"otherSlice":7459617743278403755},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"S"},{"reference":{"otherSlice":5746284862407516300},"usedName":{"valueName":{"identifier":"head"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"/="}},"qualification":null},{"reference":{"builtinModule":"GHC.Word"},"usedName":{"typeName":{"identifier":"Word8"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":7909906145565732243},"usedName":{"valueName":{"identifier":"pack"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">"}},"qualification":null},{"reference":{"otherSlice":2562795520282429707},"usedName":{"valueName":{"identifier":"tail"}},"qualification":"S"},{"reference":{"otherSlice":6318239047184045573},"usedName":{"valueName":{"identifier":"cons"}},"qualification":"S"},{"reference":{"otherSlice":3440128058703506980},"usedName":{"valueName":{"identifier":"index"}},"qualification":"S"},{"reference":{"otherSlice":2628884853785696949},"usedName":{"valueName":{"identifier":"finalise"}},"qualification":"Stream"},{"reference":{"otherSlice":7315165113918992770},"usedName":{"typeName":{"identifier":"Format"}},"qualification":"Stream"},{"reference":{"otherSlice":3205252498693512578},"usedName":{"typeName":{"identifier":"DecompressParams"}},"qualification":null}],"fragment":["decompressStreamST ::\n                   Stream.Format -> DecompressParams -> DecompressStream (ST s)","decompressStreamST format params\n  = DecompressInputRequired $\n      \\ chunk ->\n        do zstate <- mkStateST\n           let next = decompressStream format params False\n           (strm', zstate') <- runStreamST (next chunk) zstate\n           go strm' zstate' (S.null chunk)\n  where go ::\n           DecompressStream Stream ->\n             Stream.State s -> Bool -> ST s (DecompressStream (ST s))\n        go (DecompressInputRequired next) zstate !_\n          = return $\n              DecompressInputRequired $\n                \\ chunk ->\n                  do (strm', zstate') <- runStreamST (next chunk) zstate\n                     go strm' zstate' (S.null chunk)\n        go (DecompressOutputAvailable chunk next) zstate !eof\n          = return $\n              DecompressOutputAvailable chunk $\n                do (strm', zstate') <- runStreamST next zstate\n                   go strm' zstate' eof\n        go (DecompressStreamEnd unconsumed) zstate !eof\n          | format == Stream.gzipFormat, decompressAllMembers params, not eof\n            = tryFollowingStream unconsumed zstate\n          | otherwise = finaliseStreamEnd unconsumed zstate\n        go (DecompressStreamError err) zstate !_\n          = finaliseStreamError err zstate\n        \n        tryFollowingStream ::\n                           S.ByteString -> Stream.State s -> ST s (DecompressStream (ST s))\n        tryFollowingStream chunk zstate\n          = case S.length chunk of\n                0 -> return $\n                       DecompressInputRequired $\n                         \\ chunk' ->\n                           case S.length chunk' of\n                               0 -> finaliseStreamEnd S.empty zstate\n                               1 | S.head chunk' /= 31 -> finaliseStreamEnd chunk' zstate\n                               1 -> return $\n                                      DecompressInputRequired $\n                                        \\ chunk'' ->\n                                          case S.length chunk'' of\n                                              0 -> finaliseStreamEnd chunk' zstate\n                                              _ -> checkHeaderSplit (S.head chunk') chunk'' zstate\n                               _ -> checkHeader chunk' zstate\n                1 -> return $\n                       DecompressInputRequired $\n                         \\ chunk' ->\n                           case S.length chunk' of\n                               0 -> finaliseStreamEnd chunk zstate\n                               _ -> checkHeaderSplit (S.head chunk) chunk' zstate\n                _ -> checkHeader chunk zstate\n        \n        checkHeaderSplit ::\n                         Word8 ->\n                           S.ByteString -> Stream.State s -> ST s (DecompressStream (ST s))\n        checkHeaderSplit 31 chunk zstate\n          | S.head chunk == 139 =\n            do let resume\n                     = decompressStream format params True (S.pack [31, 139])\n               if S.length chunk > 1 then\n                 do (DecompressInputRequired next, zstate') <- runStreamST resume\n                                                                 zstate\n                    (strm', zstate'') <- runStreamST (next (S.tail chunk)) zstate'\n                    go strm' zstate'' False\n                 else\n                 do (strm, zstate') <- runStreamST resume zstate\n                    go strm zstate' False\n        checkHeaderSplit byte chunk zstate\n          = finaliseStreamEnd (S.cons byte chunk) zstate\n        \n        checkHeader ::\n                    S.ByteString -> Stream.State s -> ST s (DecompressStream (ST s))\n        checkHeader chunk zstate\n          | S.index chunk 0 == 31, S.index chunk 1 == 139 =\n            do let resume = decompressStream format params True chunk\n               (strm', zstate') <- runStreamST resume zstate\n               go strm' zstate' False\n        checkHeader chunk zstate = finaliseStreamEnd chunk zstate\n        finaliseStreamEnd unconsumed zstate\n          = do _ <- runStreamST Stream.finalise zstate\n               return (DecompressStreamEnd unconsumed)\n        finaliseStreamError err zstate\n          = do _ <- runStreamST Stream.finalise zstate\n               return (DecompressStreamError err)"],"instances":[],"language":{"extensions":["RankNTypes","DeriveDataTypeable","BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
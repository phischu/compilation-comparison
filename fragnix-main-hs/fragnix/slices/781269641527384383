{"sliceID":781269641527384383,"uses":[{"reference":{"builtinModule":"Data.List"},"usedName":{"valueName":{"identifier":"lines"}},"qualification":null},{"reference":{"builtinModule":"GHC.Integer"},"usedName":{"typeName":{"identifier":"Integer"}},"qualification":null},{"reference":{"otherSlice":3513222745602344190},"usedName":{"typeName":{"identifier":"Day"}},"qualification":null},{"reference":{"otherSlice":690857233018859977},"usedName":{"typeName":{"identifier":"LeapSecondTable"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"String"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":3513222745602344190},"usedName":{"constructorName":{"identifier":"ModifiedJulianDay"},"constructorTypeName":{"identifier":"Day"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Char"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">="}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"&&"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<="}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Enum"},"usedName":{"valueName":{"identifier":"fromEnum"}},"qualification":null}],"fragment":["parseTAIUTCDATFile :: String -> LeapSecondTable","parseTAIUTCDATFile ss = offsetlist 0 (parse (lines ss))\n  where offsetlist :: Integer -> [(Day, Integer)] -> LeapSecondTable\n        offsetlist i [] _ = i\n        offsetlist i ((d0, _) : _) d | d < d0 = i\n        offsetlist _ ((_, i0) : xx) d = offsetlist i0 xx d\n        \n        parse :: [String] -> [(Day, Integer)]\n        parse [] = []\n        parse (a : as)\n          = let ps = parse as in\n              case matchLine a of\n                  Just di -> di : ps\n                  Nothing -> ps\n        \n        matchLine :: String -> Maybe (Day, Integer)\n        matchLine s\n          = do check0S s\n               (d, s') <- findJD s\n               i <- findOffset s'\n               return (d, i)\n        \n        check0S :: String -> Maybe ()\n        check0S \"X 0.0      S\" = Just ()\n        check0S [] = Nothing\n        check0S (_ : cs) = check0S cs\n        \n        findJD :: String -> Maybe (Day, String)\n        findJD ('=' : ('J' : ('D' : s)))\n          = do d <- getInteger '5' s\n               return (ModifiedJulianDay (d - 2400000), s)\n        findJD [] = Nothing\n        findJD (_ : cs) = findJD cs\n        \n        findOffset :: String -> Maybe Integer\n        findOffset\n          ('T' : ('A' : ('I' : ('-' : ('U' : ('T' : ('C' : ('=' : s))))))))\n          = getInteger '0' s\n        findOffset [] = Nothing\n        findOffset (_ : cs) = findOffset cs\n        \n        getInteger :: Char -> String -> Maybe Integer\n        getInteger p s\n          = do digits <- getDigits p s\n               fromDigits 0 digits\n        \n        getDigits :: Char -> String -> Maybe String\n        getDigits p (' ' : s) = getDigits p s\n        getDigits p (c : cs)\n          | c >= '0' && c <= '9' =\n            do s <- getDigits p cs\n               return (c : s)\n        getDigits p ('.' : (p1 : _)) = if p == p1 then Just [] else Nothing\n        getDigits _ _ = Nothing\n        \n        fromDigits :: Integer -> String -> Maybe Integer\n        fromDigits i [] = Just i\n        fromDigits i (c : cs)\n          | c >= '0' && c <= '9' =\n            fromDigits\n              ((i * 10) + (fromIntegral ((fromEnum c) - (fromEnum '0'))))\n              cs\n        fromDigits _ _ = Nothing"],"instances":[],"language":{"extensions":["Rank2Types","DeriveDataTypeable","StandaloneDeriving","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
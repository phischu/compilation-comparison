{"sliceID":3182969843109454075,"uses":[{"reference":{"otherSlice":6756606517105139295},"usedName":{"constructorName":{"identifier":"Regex"},"constructorTypeName":{"identifier":"Regex"}},"qualification":null},{"reference":{"otherSlice":3024497621755900322},"usedName":{"valueName":{"identifier":"nullTest"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"/="}},"qualification":null},{"reference":{"otherSlice":435270172987220481},"usedName":{"valueName":{"identifier":"compNoSub"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"operator":".&."}},"qualification":null},{"reference":{"otherSlice":1666164400486130719},"usedName":{"valueName":{"identifier":"wrapTest"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Right"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Left"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"builtinModule":"Foreign.ForeignPtr"},"usedName":{"valueName":{"identifier":"withForeignPtr"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Marshal.Alloc"},"usedName":{"valueName":{"identifier":"allocaBytes"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"identifier":"complement"}},"qualification":null},{"reference":{"otherSlice":1436310940466545134},"usedName":{"valueName":{"identifier":"execNotBOL"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"operator":".|."}},"qualification":null},{"reference":{"otherSlice":5806818494902199580},"usedName":{"valueName":{"identifier":"doMatch"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"plusPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Prim"},"usedName":{"valueName":{"identifier":"seq"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"undefined"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"otherSlice":6404124556238023932},"usedName":{"valueName":{"identifier":"isNull"}},"qualification":null},{"reference":{"builtinModule":"GHC.Enum"},"usedName":{"valueName":{"identifier":"succ"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":6404124556238023932},"usedName":{"valueName":{"identifier":"isNewline"}},"qualification":null},{"reference":{"builtinModule":"GHC.Enum"},"usedName":{"valueName":{"identifier":"pred"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":6756606517105139295},"usedName":{"typeName":{"identifier":"Regex"}},"qualification":null},{"reference":{"builtinModule":"Foreign.C.String"},"usedName":{"typeName":{"identifier":"CString"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"typeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":3294887094191733298},"usedName":{"typeName":{"identifier":"WrapError"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null}],"fragment":["wrapCount :: Regex -> CString -> IO (Either WrapError Int)","wrapCount regex@(Regex regex_fptr compileOptions flags) cstr\n  = do nullTest cstr \"wrapCount cstr\" $\n         do if (0 /= compNoSub .&. compileOptions) then\n              do r <- wrapTest regex cstr\n                 case r of\n                     Right True -> return (Right 1)\n                     Right False -> return (Right 0)\n                     Left err -> return (Left err)\n              else\n              do withForeignPtr regex_fptr $\n                   \\ regex_ptr ->\n                     do let nsub_bytes = ((8))\n                        allocaBytes nsub_bytes $\n                          \\ p_match ->\n                            do nullTest p_match \"wrapCount p_match\" $\n                                 do let flagsBOL = (complement execNotBOL) .&. flags\n                                        flagsMIDDLE = execNotBOL .|. flags\n                                        atBOL pos\n                                          = doMatch regex_ptr (plusPtr cstr pos) 0 p_match flagsBOL\n                                        atMIDDLE pos\n                                          = doMatch regex_ptr (plusPtr cstr pos) 0 p_match\n                                              flagsMIDDLE\n                                        loop acc old (s, e)\n                                          | acc `seq` old `seq` False = undefined\n                                          | s == e =\n                                            do let pos = old + fromIntegral e\n                                               atEnd <- isNull cstr pos\n                                               if atEnd then return (Right acc) else\n                                                 loop acc old (s, succ e)\n                                          | otherwise =\n                                            do let pos = old + fromIntegral e\n                                               prev'newline <- isNewline cstr (pred pos)\n                                               result <- if prev'newline then atBOL pos else\n                                                           atMIDDLE pos\n                                               case result of\n                                                   Right Nothing -> return (Right acc)\n                                                   Right (Just (whole : _)) -> loop (succ acc) pos\n                                                                                 whole\n                                                   Left err -> return (Left err)\n                                                   Right (Just []) -> return (Right acc)\n                                    result <- doMatch regex_ptr cstr 0 p_match flags\n                                    case result of\n                                        Right Nothing -> return (Right 0)\n                                        Right (Just (whole : _)) -> loop 1 0 whole\n                                        Left err -> return (Left err)\n                                        Right (Just []) -> return (Right 0)"],"instances":[],"language":{"extensions":["MultiParamTypeClasses","FunctionalDependencies","ForeignFunctionInterface","GeneralizedNewtypeDeriving","FlexibleContexts","TypeSynonymInstances","FlexibleInstances","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
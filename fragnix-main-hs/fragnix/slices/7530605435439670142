{"sliceID":7530605435439670142,"uses":[{"reference":{"otherSlice":9209112058599157037},"usedName":{"constructorName":{"identifier":"Stream"},"constructorTypeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":1701156183895442950},"usedName":{"valueName":{"identifier":"smaller"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":6240008831363963322},"usedName":{"constructorName":{"identifier":"Yield"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"otherSlice":6240008831363963322},"usedName":{"constructorName":{"identifier":"Skip"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":6240008831363963322},"usedName":{"constructorName":{"identifier":"Done"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Monad"}},"qualification":null},{"reference":{"otherSlice":9209112058599157037},"usedName":{"typeName":{"identifier":"Stream"}},"qualification":null}],"fragment":["zipWith3M ::\n            Monad m =>\n            (a -> b -> c -> m d) ->\n              Stream m a -> Stream m b -> Stream m c -> Stream m d","zipWith3M f (Stream stepa sa na) (Stream stepb sb nb)\n  (Stream stepc sc nc)\n  = Stream step (sa, sb, sc, Nothing) (smaller na (smaller nb nc))\n  where {-# INLINE [0] step #-}\n        step (sa, sb, sc, Nothing)\n          = do r <- stepa sa\n               return $\n                 case r of\n                     Yield x sa' -> Skip (sa', sb, sc, Just (x, Nothing))\n                     Skip sa' -> Skip (sa', sb, sc, Nothing)\n                     Done -> Done\n        step (sa, sb, sc, Just (x, Nothing))\n          = do r <- stepb sb\n               return $\n                 case r of\n                     Yield y sb' -> Skip (sa, sb', sc, Just (x, Just y))\n                     Skip sb' -> Skip (sa, sb', sc, Just (x, Nothing))\n                     Done -> Done\n        step (sa, sb, sc, Just (x, Just y))\n          = do r <- stepc sc\n               case r of\n                   Yield z sc' -> f x y z >>=\n                                    (\\ res -> return $ Yield res (sa, sb, sc', Nothing))\n                   Skip sc' -> return $ Skip (sa, sb, sc', Just (x, Just y))\n                   Done -> return $ Done"],"instances":[],"language":{"extensions":["DeriveDataTypeable","ExistentialQuantification","Rank2Types","BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
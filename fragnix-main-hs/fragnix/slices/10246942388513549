{"sliceID":10246942388513549,"uses":[{"reference":{"otherSlice":2109377013281436257},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"B"},{"reference":{"otherSlice":8642306666063513779},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"B"},{"reference":{"otherSlice":3384122148683517227},"usedName":{"typeName":{"identifier":"CodePoint"}},"qualification":null},{"reference":{"otherSlice":7772542432409232005},"usedName":{"typeName":{"identifier":"DecoderState"}},"qualification":null},{"reference":{"otherSlice":7313190456694800977},"usedName":{"typeName":{"identifier":"DecodeResult"}},"qualification":null},{"reference":{"otherSlice":675696118971413715},"usedName":{"valueName":{"identifier":"null"}},"qualification":"B"},{"reference":{"otherSlice":7313190456694800977},"usedName":{"constructorName":{"identifier":"DecodeResultSuccess"},"constructorTypeName":{"identifier":"DecodeResult"}},"qualification":null},{"reference":{"otherSlice":600428831856449117},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"T"},{"reference":{"otherSlice":7313190456694800977},"usedName":{"constructorName":{"identifier":"DecodeResultFailure"},"constructorTypeName":{"identifier":"DecodeResult"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":8642306666063513779},"usedName":{"constructorName":{"identifier":"PS"},"constructorTypeName":{"identifier":"ByteString"}},"qualification":null},{"reference":{"builtinModule":"GHC.ST"},"usedName":{"valueName":{"identifier":"runST"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO"},"usedName":{"valueName":{"identifier":"unsafeIOToST"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"operator":"=<<"}},"qualification":null},{"reference":{"otherSlice":303218261714130477},"usedName":{"valueName":{"identifier":"new"}},"qualification":"A"},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":3588273259683486231},"usedName":{"typeName":{"identifier":"MArray"}},"qualification":"A"},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"builtinModule":"Foreign.ForeignPtr"},"usedName":{"valueName":{"identifier":"withForeignPtr"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Marshal.Utils"},"usedName":{"valueName":{"identifier":"with"}},"qualification":null},{"reference":{"builtinModule":"Foreign.C.Types"},"usedName":{"typeName":{"identifier":"CSize"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"nullPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"plusPtr"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Storable"},"usedName":{"valueName":{"identifier":"poke"}},"qualification":null},{"reference":{"otherSlice":1729033006664538519},"usedName":{"valueName":{"identifier":"c_decode_utf8_with_state"}},"qualification":null},{"reference":{"otherSlice":3588273259683486231},"usedName":{"valueName":{"identifier":"maBA"}},"qualification":"A"},{"reference":{"builtinModule":"Foreign.Storable"},"usedName":{"valueName":{"identifier":"peek"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO"},"usedName":{"valueName":{"identifier":"unsafeSTToIO"}},"qualification":null},{"reference":{"otherSlice":2495787221593611115},"usedName":{"valueName":{"identifier":"unsafeFreeze"}},"qualification":"A"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"Prelude"},"usedName":{"valueName":{"operator":"$!"}},"qualification":null},{"reference":{"otherSlice":4069519914147446271},"usedName":{"valueName":{"identifier":"text"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"minusPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"not"}},"qualification":null},{"reference":{"otherSlice":8228193317075554769},"usedName":{"valueName":{"identifier":"null"}},"qualification":"T"},{"reference":{"otherSlice":6479985746417015458},"usedName":{"valueName":{"identifier":"unsafeDrop"}},"qualification":"B"},{"reference":{"otherSlice":1524283775147600600},"usedName":{"valueName":{"identifier":"append"}},"qualification":"B"},{"reference":{"builtinModule":"GHC.Prim"},"usedName":{"valueName":{"identifier":"seq"}},"qualification":null}],"fragment":["decodeUtf8 :: B.ByteString -> DecodeResult","decodeUtf8 = decodeChunk B.empty 0 0\n  where decodeChunkCheck ::\n                         B.ByteString ->\n                           CodePoint -> DecoderState -> B.ByteString -> DecodeResult\n        decodeChunkCheck bsOld codepoint state bs\n          | B.null bs =\n            if B.null bsOld then DecodeResultSuccess T.empty decodeUtf8 else\n              DecodeResultFailure T.empty bsOld\n          | otherwise = decodeChunk bsOld codepoint state bs\n        \n        decodeChunk ::\n                    B.ByteString ->\n                      CodePoint -> DecoderState -> B.ByteString -> DecodeResult\n        decodeChunk bsOld codepoint0 state0 bs@(PS fp off len)\n          = runST $ (unsafeIOToST . decodeChunkToBuffer) =<< A.new (len + 1)\n          where decodeChunkToBuffer :: A.MArray s -> IO DecodeResult\n                decodeChunkToBuffer dest\n                  = withForeignPtr fp $\n                      \\ ptr ->\n                        with (0 :: CSize) $\n                          \\ destOffPtr ->\n                            with codepoint0 $\n                              \\ codepointPtr ->\n                                with state0 $\n                                  \\ statePtr ->\n                                    with nullPtr $\n                                      \\ curPtrPtr ->\n                                        let end = ptr `plusPtr` (off + len)\n                                            loop curPtr\n                                              = do poke curPtrPtr curPtr\n                                                   _ <- c_decode_utf8_with_state (A.maBA dest)\n                                                          destOffPtr\n                                                          curPtrPtr\n                                                          end\n                                                          codepointPtr\n                                                          statePtr\n                                                   state <- peek statePtr\n                                                   n <- peek destOffPtr\n                                                   chunkText <- unsafeSTToIO $\n                                                                  do arr <- A.unsafeFreeze dest\n                                                                     return $!\n                                                                       text arr 0 (fromIntegral n)\n                                                   lastPtr <- peek curPtrPtr\n                                                   let left = lastPtr `minusPtr` curPtr\n                                                       unused\n                                                         | not $ T.null chunkText =\n                                                           B.unsafeDrop left bs\n                                                         | B.null bsOld = bs\n                                                         | otherwise = B.append bsOld bs\n                                                   case unused `seq` state of\n                                                       12 -> return $!\n                                                               DecodeResultFailure chunkText unused\n                                                       _ -> do codepoint <- peek codepointPtr\n                                                               return $!\n                                                                 DecodeResultSuccess chunkText $!\n                                                                   decodeChunkCheck unused codepoint\n                                                                     state\n                                          in loop (ptr `plusPtr` off)"],"instances":[],"language":{"extensions":["BangPatterns","ForeignFunctionInterface","GeneralizedNewtypeDeriving","MagicHash","Rank2Types","UnliftedFFITypes","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
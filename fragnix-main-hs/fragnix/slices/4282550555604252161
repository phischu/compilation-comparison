{"sliceID":4282550555604252161,"uses":[{"reference":{"builtinModule":"GHC.ST"},"usedName":{"valueName":{"identifier":"runST"}},"qualification":null},{"reference":{"builtinModule":"GHC.Prim"},"usedName":{"valueName":{"identifier":"seq"}},"qualification":null},{"reference":{"otherSlice":748912564861231192},"usedName":{"valueName":{"identifier":"new"}},"qualification":"M"},{"reference":{"otherSlice":8396276112167879471},"usedName":{"valueName":{"identifier":"unsafeFreeze"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.ST"},"usedName":{"typeName":{"identifier":"ST"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":753616747898747081},"usedName":{"valueName":{"identifier":"unsafeSlice"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"otherSlice":8572689894313737623},"usedName":{"valueName":{"identifier":"elemseq"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":3238519251124094507},"usedName":{"valueName":{"identifier":"unsafeThaw"}},"qualification":null},{"reference":{"otherSlice":7447414200794448241},"usedName":{"valueName":{"identifier":"unsafeWrite"}},"qualification":"M"},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":8572689894313737623},"usedName":{"typeName":{"identifier":"Vector"}},"qualification":null}],"fragment":["constructrN :: forall v a . Vector v a => Int -> (v a -> a) -> v a","constructrN !n f\n  = runST\n      (do v <- n `seq` M.new n\n          v' <- unsafeFreeze v\n          fill v' 0)\n  where fill :: forall s . v a -> Int -> ST s (v a)\n        fill !v i\n          | i < n =\n            let x = f (unsafeSlice (n - i) i v) in\n              elemseq v x $\n                do v' <- unsafeThaw v\n                   M.unsafeWrite v' (n - i - 1) x\n                   v'' <- unsafeFreeze v'\n                   fill v'' (i + 1)\n        fill v _ = return v"],"instances":[],"language":{"extensions":["Rank2Types","MultiParamTypeClasses","FlexibleContexts","TypeFamilies","ScopedTypeVariables","BangPatterns","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
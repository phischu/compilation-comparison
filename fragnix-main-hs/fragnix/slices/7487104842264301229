{"sliceID":7487104842264301229,"uses":[{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"newIORef"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":5779775205356390901},"usedName":{"valueName":{"identifier":"mkSource"}},"qualification":null},{"reference":{"otherSlice":5149576256661213753},"usedName":{"valueName":{"identifier":"connSource"}},"qualification":null},{"reference":{"builtinModule":"Control.Exception.Base"},"usedName":{"valueName":{"identifier":"catch"}},"qualification":"E"},{"reference":{"builtinModule":"GHC.IO"},"usedName":{"valueName":{"identifier":"throwIO"}},"qualification":null},{"reference":{"builtinModule":"GHC.Exception"},"usedName":{"typeName":{"identifier":"SomeException"}},"qualification":null},{"reference":{"otherSlice":4040851656968671632},"usedName":{"valueName":{"identifier":"settingsProxyProtocol"}},"qualification":null},{"reference":{"otherSlice":7757643439920433849},"usedName":{"constructorName":{"identifier":"ProxyProtocolNone"},"constructorTypeName":{"identifier":"ProxyProtocol"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":7757643439920433849},"usedName":{"constructorName":{"identifier":"ProxyProtocolRequired"},"constructorTypeName":{"identifier":"ProxyProtocol"}},"qualification":null},{"reference":{"otherSlice":4434023532649325206},"usedName":{"valueName":{"identifier":"readSource"}},"qualification":null},{"reference":{"otherSlice":7757643439920433849},"usedName":{"constructorName":{"identifier":"ProxyProtocolOptional"},"constructorTypeName":{"identifier":"ProxyProtocol"}},"qualification":null},{"reference":{"otherSlice":7097082463823892789},"usedName":{"valueName":{"identifier":"isPrefixOf"}},"qualification":"S"},{"reference":{"otherSlice":3896990514858613071},"usedName":{"valueName":{"identifier":"leftoverSource"}},"qualification":null},{"reference":{"otherSlice":968296184656941152},"usedName":{"valueName":{"identifier":"break"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":858549950660912519},"usedName":{"valueName":{"identifier":"split"}},"qualification":"S"},{"reference":{"builtinModule":"Text.Read"},"usedName":{"valueName":{"identifier":"reads"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"null"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":5051683172608853772},"usedName":{"constructorName":{"identifier":"SockAddrInet"},"constructorTypeName":{"identifier":"SockAddr"}},"qualification":null},{"reference":{"otherSlice":1706086155524508431},"usedName":{"valueName":{"identifier":"readInt"}},"qualification":null},{"reference":{"otherSlice":7061941849582283826},"usedName":{"valueName":{"identifier":"toHostAddress"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":5051683172608853772},"usedName":{"constructorName":{"identifier":"SockAddrInet6"},"constructorTypeName":{"identifier":"SockAddr"}},"qualification":null},{"reference":{"otherSlice":7473026406621193645},"usedName":{"valueName":{"identifier":"toHostAddress6"}},"qualification":null},{"reference":{"otherSlice":8547266307614062940},"usedName":{"constructorName":{"identifier":"BadProxyHeader"},"constructorTypeName":{"identifier":"InvalidRequest"}},"qualification":null},{"reference":{"otherSlice":6985366053944096403},"usedName":{"valueName":{"identifier":"drop"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"builtinModule":"GHC.Char"},"usedName":{"valueName":{"identifier":"chr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"GHC.Enum"},"usedName":{"valueName":{"identifier":"fromEnum"}},"qualification":null},{"reference":{"otherSlice":7264869026049340701},"usedName":{"valueName":{"identifier":"unpack"}},"qualification":"S"},{"reference":{"otherSlice":3323754789693346301},"usedName":{"valueName":{"identifier":"threadHandle"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"readIORef"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"when"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"void"}},"qualification":null},{"reference":{"otherSlice":1723864833354466887},"usedName":{"valueName":{"identifier":"sendResponse"}},"qualification":null},{"reference":{"otherSlice":4040851656968671632},"usedName":{"valueName":{"identifier":"settingsServerName"}},"qualification":null},{"reference":{"otherSlice":1296148709406433364},"usedName":{"valueName":{"identifier":"defaultIndexRequestHeader"}},"qualification":null},{"reference":{"otherSlice":2109377013281436257},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"S"},{"reference":{"otherSlice":8532016779649345729},"usedName":{"valueName":{"identifier":"defaultRequest"}},"qualification":null},{"reference":{"otherSlice":30758760526534613},"usedName":{"valueName":{"identifier":"remoteHost"}},"qualification":null},{"reference":{"otherSlice":4040851656968671632},"usedName":{"valueName":{"identifier":"settingsOnExceptionResponse"}},"qualification":null},{"reference":{"otherSlice":800034901723742684},"usedName":{"valueName":{"identifier":"recvRequest"}},"qualification":null},{"reference":{"otherSlice":30758760526534613},"usedName":{"valueName":{"identifier":"isSecure"}},"qualification":null},{"reference":{"otherSlice":355629517602467088},"usedName":{"valueName":{"identifier":"onE"}},"qualification":null},{"reference":{"otherSlice":6004518109827599645},"usedName":{"valueName":{"identifier":"pause"}},"qualification":"T"},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"error"}},"qualification":null},{"reference":{"otherSlice":1556368807410862643},"usedName":{"valueName":{"identifier":"resume"}},"qualification":"T"},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"writeIORef"}},"qualification":null},{"reference":{"otherSlice":303372933562511200},"usedName":{"constructorName":{"identifier":"ResponseReceived"},"constructorTypeName":{"identifier":"ResponseReceived"}},"qualification":null},{"reference":{"builtinModule":"GHC.Conc.Sync"},"usedName":{"valueName":{"identifier":"yield"}},"qualification":"Conc"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"not"}},"qualification":null},{"reference":{"otherSlice":4040851656968671632},"usedName":{"valueName":{"identifier":"settingsMaximumBodyFlush"}},"qualification":null},{"reference":{"otherSlice":6161762963713990632},"usedName":{"valueName":{"identifier":"flushEntireBody"}},"qualification":null},{"reference":{"otherSlice":30758760526534613},"usedName":{"valueName":{"identifier":"requestBody"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":8104689359773003302},"usedName":{"valueName":{"identifier":"flushBody"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<="}},"qualification":null},{"reference":{"otherSlice":4881703223122348873},"usedName":{"typeName":{"identifier":"Connection"}},"qualification":null},{"reference":{"otherSlice":3323754789693346301},"usedName":{"typeName":{"identifier":"InternalInfo"}},"qualification":null},{"reference":{"otherSlice":5051683172608853772},"usedName":{"typeName":{"identifier":"SockAddr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":4040851656968671632},"usedName":{"typeName":{"identifier":"Settings"}},"qualification":null},{"reference":{"otherSlice":2500932139194697081},"usedName":{"typeName":{"identifier":"Application"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null}],"fragment":["serveConnection ::\n                Connection ->\n                  InternalInfo ->\n                    SockAddr -> Bool -> Settings -> Application -> IO ()","serveConnection conn ii origAddr isSecure' settings app\n  = do istatus <- newIORef False\n       src <- mkSource (connSource conn th istatus)\n       addr <- getProxyProtocolAddr src\n       recvSendLoop addr istatus src `E.catch`\n         \\ e ->\n           do sendErrorResponse addr istatus e\n              throwIO (e :: SomeException)\n  where getProxyProtocolAddr src\n          = case settingsProxyProtocol settings of\n                ProxyProtocolNone -> return origAddr\n                ProxyProtocolRequired -> do seg <- readSource src\n                                            parseProxyProtocolHeader src seg\n                ProxyProtocolOptional -> do seg <- readSource src\n                                            if S.isPrefixOf \"PROXY \" seg then\n                                              parseProxyProtocolHeader src seg else\n                                              do leftoverSource src seg\n                                                 return origAddr\n        parseProxyProtocolHeader src seg\n          = do let (header, seg') = S.break (== 13) seg\n                   maybeAddr\n                     = case S.split 32 header of\n                           [\"PROXY\", \"TCP4\", clientAddr, _, clientPort, _] -> case\n                                                                                [x |\n                                                                                 (x, t) <- reads\n                                                                                             (decodeAscii\n                                                                                                clientAddr),\n                                                                                 null t]\n                                                                                of\n                                                                                  [a] -> Just\n                                                                                           (SockAddrInet\n                                                                                              (readInt\n                                                                                                 clientPort)\n                                                                                              (toHostAddress\n                                                                                                 a))\n                                                                                  _ -> Nothing\n                           [\"PROXY\", \"TCP6\", clientAddr, _, clientPort, _] -> case\n                                                                                [x |\n                                                                                 (x, t) <- reads\n                                                                                             (decodeAscii\n                                                                                                clientAddr),\n                                                                                 null t]\n                                                                                of\n                                                                                  [a] -> Just\n                                                                                           (SockAddrInet6\n                                                                                              (readInt\n                                                                                                 clientPort)\n                                                                                              0\n                                                                                              (toHostAddress6\n                                                                                                 a)\n                                                                                              0)\n                                                                                  _ -> Nothing\n                           (\"PROXY\" : (\"UNKNOWN\" : _)) -> Just origAddr\n                           _ -> Nothing\n               case maybeAddr of\n                   Nothing -> throwIO (BadProxyHeader (decodeAscii header))\n                   Just a -> do leftoverSource src (S.drop 2 seg')\n                                return a\n        decodeAscii = map (chr . fromEnum) . S.unpack\n        th = threadHandle ii\n        sendErrorResponse addr istatus e\n          = do status <- readIORef istatus\n               when status $\n                 void $\n                   sendResponse (settingsServerName settings) conn ii (dummyreq addr)\n                     defaultIndexRequestHeader\n                     (return S.empty)\n                     (errorResponse e)\n        dummyreq addr = defaultRequest{remoteHost = addr}\n        errorResponse e = settingsOnExceptionResponse settings e\n        recvSendLoop addr istatus fromClient\n          = do (req', mremainingRef, idxhdr) <- recvRequest settings conn ii\n                                                  addr\n                                                  fromClient\n               let req = req'{isSecure = isSecure'}\n               keepAlive <- processRequest istatus fromClient req mremainingRef\n                              idxhdr\n                              `E.catch`\n                              \\ e ->\n                                do sendErrorResponse addr istatus e\n                                   onE settings (Just req) e\n                                   return False\n               when keepAlive $ recvSendLoop addr istatus fromClient\n        processRequest istatus fromClient req mremainingRef idxhdr\n          = do T.pause th\n               keepAliveRef <- newIORef $ error \"keepAliveRef not filled\"\n               _ <- app req $\n                      \\ res ->\n                        do T.resume th\n                           writeIORef istatus False\n                           keepAlive <- sendResponse (settingsServerName settings) conn ii req\n                                          idxhdr\n                                          (readSource fromClient)\n                                          res\n                           writeIORef keepAliveRef keepAlive\n                           return ResponseReceived\n               keepAlive <- readIORef keepAliveRef\n               Conc.yield\n               if not keepAlive then return False else\n                 do case settingsMaximumBodyFlush settings of\n                        Nothing -> do flushEntireBody (requestBody req)\n                                      T.resume th\n                                      return True\n                        Just maxToRead -> do let tryKeepAlive\n                                                   = do isComplete <- flushBody (requestBody req)\n                                                                        maxToRead\n                                                        if isComplete then\n                                                          do T.resume th\n                                                             return True\n                                                          else return False\n                                             case mremainingRef of\n                                                 Just ref -> do remaining <- readIORef ref\n                                                                if remaining <= maxToRead then\n                                                                  tryKeepAlive else return False\n                                                 Nothing -> tryKeepAlive"],"instances":[],"language":{"extensions":["OverloadedStrings","ScopedTypeVariables","TupleSections","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
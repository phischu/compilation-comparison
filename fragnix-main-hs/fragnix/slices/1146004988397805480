{"sliceID":1146004988397805480,"uses":[{"reference":{"otherSlice":7281902249350019939},"usedName":{"valueName":{"identifier":"parseJSON"}},"qualification":null},{"reference":{"otherSlice":2494651675846515900},"usedName":{"valueName":{"identifier":"unsafeIndex"}},"qualification":"V"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"otherSlice":1669319695546572556},"usedName":{"constructorName":{"identifier":"Array"},"constructorTypeName":{"identifier":"Value"}},"qualification":null},{"reference":{"otherSlice":6708001900488435128},"usedName":{"valueName":{"identifier":"length"}},"qualification":"V"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"Data.List"},"usedName":{"valueName":{"identifier":"foldl'"}},"qualification":null},{"reference":{"builtinModule":"Control.Applicative"},"usedName":{"valueName":{"operator":"<*>"}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"operator":"<$>"}},"qualification":null},{"reference":{"otherSlice":9089961804217864861},"usedName":{"valueName":{"identifier":"parseTypeMismatch"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"builtinModule":"GHC.Show"},"usedName":{"valueName":{"identifier":"show"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":8190452208809716526},"usedName":{"valueName":{"identifier":"matchFailed"}},"qualification":null},{"reference":{"builtinModule":"GHC.Integer"},"usedName":{"typeName":{"identifier":"Integer"}},"qualification":null}],"fragment":["parseProduct :: Name -> Name -> Integer -> [Q Match]","parseProduct tName conName numArgs\n  = [do arr <- newName \"arr\"\n        let x : xs\n              = [[| parseJSON |] `appE`\n                   infixApp (varE arr) [| V.unsafeIndex |] (litE $ integerL ix)\n                 | ix <- [0 .. numArgs - 1]]\n        match (conP 'Array [varP arr])\n          (normalB $\n             condE\n               (infixApp ([| V.length |] `appE` varE arr) [| (==) |]\n                  (litE $ integerL numArgs))\n               (foldl' (\\ a b -> infixApp a [| (<*>) |] b)\n                  (infixApp (conE conName) [| (<$>) |] x)\n                  xs)\n               (parseTypeMismatch tName conName\n                  (litE $ stringL $ \"Array of length \" ++ show numArgs)\n                  (infixApp (litE $ stringL $ \"Array of length \") [| (++) |]\n                     ([| show . V.length |] `appE` varE arr))))\n          [],\n     matchFailed tName conName \"Array\"]"],"instances":[],"language":{"extensions":["FlexibleInstances","IncoherentInstances","NamedFieldPuns","NoImplicitPrelude","OverlappingInstances","TemplateHaskell","UndecidableInstances","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
{"sliceID":6155598780668348545,"uses":[{"reference":{"otherSlice":4010822550476529195},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"otherSlice":4010822550476529195},"usedName":{"constructorName":{"identifier":"PS"},"constructorTypeName":{"identifier":"ByteString"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<="}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"error"}},"qualification":null},{"reference":{"otherSlice":7202692338078551997},"usedName":{"valueName":{"identifier":"null"}},"qualification":"B"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":2065173151069060358},"usedName":{"valueName":{"identifier":"unsafeCreate"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"Foreign.ForeignPtr"},"usedName":{"valueName":{"identifier":"withForeignPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"plusPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"minusPtr"}},"qualification":null},{"reference":{"otherSlice":7962159238439154152},"usedName":{"valueName":{"identifier":"memcpy"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"mod"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"div"}},"qualification":null}],"fragment":["joinWith :: ByteString -> Int -> ByteString -> ByteString","joinWith brk@(PS bfp boff blen) every bs@(PS sfp soff slen)\n  | every <= 0 = error \"invalid interval\"\n  | blen <= 0 = bs\n  | B.null bs = brk\n  | otherwise =\n    unsafeCreate dlen $\n      \\ dptr ->\n        withForeignPtr bfp $\n          \\ bptr ->\n            do withForeignPtr sfp $\n                 \\ sptr ->\n                   do let bp = bptr `plusPtr` boff\n                          sp0 = sptr `plusPtr` soff\n                          sLast = sp0 `plusPtr` (every * numBreaks)\n                          loop !dp !sp\n                            | sp == sLast =\n                              do let n = sp0 `plusPtr` slen `minusPtr` sp\n                                 memcpy dp sp (fromIntegral n)\n                                 memcpy (dp `plusPtr` n) bp (fromIntegral blen)\n                            | otherwise =\n                              do memcpy dp sp (fromIntegral every)\n                                 let dp' = dp `plusPtr` every\n                                 memcpy dp' bp (fromIntegral blen)\n                                 loop (dp' `plusPtr` blen) (sp `plusPtr` every)\n                      loop dptr sp0\n  where dlast = slen + blen * numBreaks\n        dlen\n          | slen `mod` every > 0 = dlast + blen\n          | otherwise = dlast\n        numBreaks = slen `div` every"],"instances":[],"language":{"extensions":["BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
{"sliceID":4875136916224806411,"uses":[{"reference":{"otherSlice":3858700879676200608},"usedName":{"typeName":{"identifier":"Extract"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":8059339572671343219},"usedName":{"typeName":{"identifier":"MatchArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":2403539435825703244},"usedName":{"typeName":{"identifier":"MatchText"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"fmap"}},"qualification":null},{"reference":{"builtinModule":"Data.Tuple"},"usedName":{"valueName":{"identifier":"snd"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"valueName":{"identifier":"isJust"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"length"}},"qualification":null},{"reference":{"builtinModule":"GHC.Arr"},"usedName":{"valueName":{"operator":"!"}},"qualification":null},{"reference":{"otherSlice":3858700879676200608},"usedName":{"valueName":{"identifier":"before"}},"qualification":null},{"reference":{"otherSlice":3858700879676200608},"usedName":{"valueName":{"identifier":"extract"}},"qualification":null},{"reference":{"otherSlice":3858700879676200608},"usedName":{"valueName":{"identifier":"after"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null}],"fragment":["class (Extract source) => RegexLike regex source where\n        matchOnce :: regex -> source -> Maybe MatchArray\n        \n        matchAll :: regex -> source -> [MatchArray]\n        \n        matchCount :: regex -> source -> Int\n        \n        matchTest :: regex -> source -> Bool\n        \n        matchAllText :: regex -> source -> [MatchText source]\n        \n        matchOnceText ::\n                      regex -> source -> Maybe (source, MatchText source, source)\n        matchAll regex source = map (fmap snd) (matchAllText regex source)\n        matchOnce regex source\n          = fmap (\\ (_, mt, _) -> fmap snd mt) (matchOnceText regex source)\n        matchTest regex source = isJust (matchOnce regex source)\n        matchCount regex source = length (matchAll regex source)\n        matchOnceText regex source\n          = fmap\n              (\\ ma ->\n                 let (o, l) = ma ! 0 in\n                   (before o source, fmap (\\ ol -> (extract ol source, ol)) ma,\n                    after (o + l) source))\n              (matchOnce regex source)\n        matchAllText regex source\n          = map (fmap (\\ ol -> (extract ol source, ol)))\n              (matchAll regex source)"],"instances":[{"instanceID":7212556260048329835,"instancePart":"OfClass"},{"instanceID":5074736139937267701,"instancePart":"OfClass"},{"instanceID":6280874928809225504,"instancePart":"OfClass"},{"instanceID":3744932936879156600,"instancePart":"OfClass"}],"language":{"extensions":["MultiParamTypeClasses","FunctionalDependencies","TypeSynonymInstances","FlexibleInstances","FlexibleContexts","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
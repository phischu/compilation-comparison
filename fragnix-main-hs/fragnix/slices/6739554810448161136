{"sliceID":6739554810448161136,"uses":[{"reference":{"builtinModule":"GHC.IO.Handle.Internals"},"usedName":{"valueName":{"identifier":"wantReadableHandle_"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Handle.Types"},"usedName":{"constructorName":{"identifier":"Handle__"},"constructorTypeName":{"identifier":"Handle__"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Handle.Types"},"usedName":{"valueName":{"identifier":"haByteBuffer"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Handle.Internals"},"usedName":{"valueName":{"identifier":"flushCharReadBuffer"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"readIORef"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Buffer"},"usedName":{"valueName":{"identifier":"isEmptyBuffer"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Handle.Types"},"usedName":{"valueName":{"identifier":"haDevice"}},"qualification":null},{"reference":{"builtinModule":"GHC.Prim"},"usedName":{"valueName":{"identifier":"seq"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.BufferedIO"},"usedName":{"valueName":{"identifier":"fillReadBuffer"}},"qualification":"Buffered"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"writeIORef"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Buffer"},"usedName":{"valueName":{"identifier":"bufR"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Buffer"},"usedName":{"valueName":{"identifier":"bufL"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">"}},"qualification":null},{"reference":{"otherSlice":8318688377057134665},"usedName":{"valueName":{"identifier":"mkBigPS"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Handle.Internals"},"usedName":{"valueName":{"identifier":"ioe_EOF"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Buffer"},"usedName":{"constructorName":{"identifier":"Buffer"},"constructorTypeName":{"identifier":"Buffer"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Buffer"},"usedName":{"valueName":{"identifier":"bufRaw"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"otherSlice":2077318198535599693},"usedName":{"valueName":{"identifier":"mkPS"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"/="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Buffer"},"usedName":{"valueName":{"identifier":"readWord8Buf"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"ord"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Handle.Types"},"usedName":{"typeName":{"identifier":"Handle"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"otherSlice":8642306666063513779},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":null}],"fragment":["hGetLine :: Handle -> IO ByteString","hGetLine h\n  = wantReadableHandle_ \"Data.ByteString.hGetLine\" h $\n      \\ h_@Handle__{haByteBuffer} ->\n        do flushCharReadBuffer h_\n           buf <- readIORef haByteBuffer\n           if isEmptyBuffer buf then fill h_ buf 0 [] else haveBuf h_ buf 0 []\n  where fill h_@Handle__{haByteBuffer, haDevice} buf len xss\n          = len `seq`\n              do (r, buf') <- Buffered.fillReadBuffer haDevice buf\n                 if r == 0 then\n                   do writeIORef haByteBuffer buf{bufR = 0, bufL = 0}\n                      if len > 0 then mkBigPS len xss else ioe_EOF\n                   else haveBuf h_ buf' len xss\n        haveBuf h_@Handle__{haByteBuffer}\n          buf@Buffer{bufRaw = raw, bufR = w, bufL = r} len xss\n          = do off <- findEOL r w raw\n               let new_len = len + off - r\n               xs <- mkPS raw r off\n               if off /= w then\n                 do if (w == off + 1) then\n                      writeIORef haByteBuffer buf{bufL = 0, bufR = 0} else\n                      writeIORef haByteBuffer buf{bufL = off + 1}\n                    mkBigPS new_len (xs : xss)\n                 else do fill h_ buf{bufL = 0, bufR = 0} new_len (xs : xss)\n        findEOL r w raw\n          | r == w = return w\n          | otherwise =\n            do c <- readWord8Buf raw r\n               if c == fromIntegral (ord '\\n') then return r else\n                 findEOL (r + 1) w raw"],"instances":[],"language":{"extensions":["MagicHash","UnboxedTuples","NamedFieldPuns","BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
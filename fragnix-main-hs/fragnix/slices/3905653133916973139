{"sliceID":3905653133916973139,"uses":[{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"typeName":{"identifier":"Eq"}},"qualification":null},{"reference":{"builtinModule":"GHC.Enum"},"usedName":{"typeName":{"identifier":"Enum"}},"qualification":null},{"reference":{"builtinModule":"GHC.Show"},"usedName":{"typeName":{"identifier":"Show"}},"qualification":null},{"reference":{"builtinModule":"GHC.Generics"},"usedName":{"typeName":{"identifier":"Generic"}},"qualification":null}],"fragment":["data Extension = Cpp\n               | OverlappingInstances\n               | UndecidableInstances\n               | IncoherentInstances\n               | UndecidableSuperClasses\n               | MonomorphismRestriction\n               | MonoPatBinds\n               | MonoLocalBinds\n               | RelaxedPolyRec\n               | ExtendedDefaultRules\n               | ForeignFunctionInterface\n               | UnliftedFFITypes\n               | InterruptibleFFI\n               | CApiFFI\n               | GHCForeignImportPrim\n               | JavaScriptFFI\n               | ParallelArrays\n               | Arrows\n               | TemplateHaskell\n               | TemplateHaskellQuotes\n               | QuasiQuotes\n               | ImplicitParams\n               | ImplicitPrelude\n               | ScopedTypeVariables\n               | AllowAmbiguousTypes\n               | UnboxedTuples\n               | BangPatterns\n               | TypeFamilies\n               | TypeFamilyDependencies\n               | TypeInType\n               | OverloadedStrings\n               | OverloadedLists\n               | NumDecimals\n               | DisambiguateRecordFields\n               | RecordWildCards\n               | RecordPuns\n               | ViewPatterns\n               | GADTs\n               | GADTSyntax\n               | NPlusKPatterns\n               | DoAndIfThenElse\n               | RebindableSyntax\n               | ConstraintKinds\n               | PolyKinds\n               | DataKinds\n               | InstanceSigs\n               | ApplicativeDo\n               | StandaloneDeriving\n               | DeriveDataTypeable\n               | AutoDeriveTypeable\n               | DeriveFunctor\n               | DeriveTraversable\n               | DeriveFoldable\n               | DeriveGeneric\n               | DefaultSignatures\n               | DeriveAnyClass\n               | DeriveLift\n               | TypeSynonymInstances\n               | FlexibleContexts\n               | FlexibleInstances\n               | ConstrainedClassMethods\n               | MultiParamTypeClasses\n               | NullaryTypeClasses\n               | FunctionalDependencies\n               | UnicodeSyntax\n               | ExistentialQuantification\n               | MagicHash\n               | EmptyDataDecls\n               | KindSignatures\n               | RoleAnnotations\n               | ParallelListComp\n               | TransformListComp\n               | MonadComprehensions\n               | GeneralizedNewtypeDeriving\n               | RecursiveDo\n               | PostfixOperators\n               | TupleSections\n               | PatternGuards\n               | LiberalTypeSynonyms\n               | RankNTypes\n               | ImpredicativeTypes\n               | TypeOperators\n               | ExplicitNamespaces\n               | PackageImports\n               | ExplicitForAll\n               | AlternativeLayoutRule\n               | AlternativeLayoutRuleTransitional\n               | DatatypeContexts\n               | NondecreasingIndentation\n               | RelaxedLayout\n               | TraditionalRecordSyntax\n               | LambdaCase\n               | MultiWayIf\n               | BinaryLiterals\n               | NegativeLiterals\n               | DuplicateRecordFields\n               | OverloadedLabels\n               | EmptyCase\n               | PatternSynonyms\n               | PartialTypeSignatures\n               | NamedWildCards\n               | StaticPointers\n               | TypeApplications\n               | Strict\n               | StrictData\n               | MonadFailDesugaring\n               deriving (Eq, Enum, Show, Generic)"],"instances":[],"language":{"extensions":["DeriveGeneric","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
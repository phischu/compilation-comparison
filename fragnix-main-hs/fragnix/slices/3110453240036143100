{"sliceID":3110453240036143100,"uses":[{"reference":{"otherSlice":675696118971413715},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"otherSlice":6258463563638113276},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":667237810833597684},"usedName":{"valueName":{"identifier":"head"}},"qualification":"S"},{"reference":{"otherSlice":6575862329792134764},"usedName":{"valueName":{"identifier":"elemIndices"}},"qualification":"S"},{"reference":{"otherSlice":3093287715237579077},"usedName":{"valueName":{"identifier":"take"}},"qualification":"S"},{"reference":{"otherSlice":6985366053944096403},"usedName":{"valueName":{"identifier":"drop"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"otherSlice":691967835189386788},"usedName":{"valueName":{"identifier":"occurs"}},"qualification":null},{"reference":{"otherSlice":7572129403924818532},"usedName":{"valueName":{"identifier":"suffShifts"}},"qualification":null},{"reference":{"builtinModule":"GHC.Enum"},"usedName":{"valueName":{"identifier":"maxBound"}},"qualification":null},{"reference":{"otherSlice":7420251549451097395},"usedName":{"valueName":{"identifier":"unsafeIndex"}},"qualification":null},{"reference":{"otherSlice":958675940120742873},"usedName":{"valueName":{"identifier":"unsafeAt"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"error"}},"qualification":null},{"reference":{"otherSlice":8642306666063513779},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"foldr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"flip"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"id"}},"qualification":null},{"reference":{"otherSlice":5036397791054469605},"usedName":{"valueName":{"identifier":"keep"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"max"}},"qualification":null}],"fragment":["lazyBreak ::\n          S.ByteString -> [S.ByteString] -> ([S.ByteString], [S.ByteString])","lazyBreak !pat\n  | S.null pat = \\ lst -> ([], lst)\n  | S.length pat == 1 =\n    let !w = S.head pat\n        go [] = ([], [])\n        go (!(str : rest))\n          = case S.elemIndices w str of\n                [] -> let (pre, post) = go rest in (str : pre, post)\n                (i : _) -> if i == 0 then ([], str : rest) else\n                             ([S.take i str], S.drop i str : rest)\n      in go\nlazyBreak pat = breaker\n  where !patLen = S.length pat\n        !patEnd = patLen - 1\n        !occT = occurs pat\n        !suffT = suffShifts pat\n        !maxLen = maxBound - patLen\n        !pe = patAt patEnd\n        \n        {-# INLINE patAt #-}\n        patAt !i = unsafeIndex pat i\n        \n        {-# INLINE occ #-}\n        occ !w = unsafeAt occT (fromIntegral w)\n        \n        {-# INLINE suff #-}\n        suff !i = unsafeAt suffT i\n        breaker lst\n          = case lst of\n                [] -> ([], [])\n                (h : t) -> if maxLen < S.length h then\n                             error \"Overflow in BoyerMoore.lazyBreak\" else seek [] h t 0 patEnd\n        \n        seek ::\n             [S.ByteString] ->\n               S.ByteString ->\n                 [S.ByteString] -> Int -> Int -> ([S.ByteString], [S.ByteString])\n        seek !past !str future !offset !patPos\n          | strPos < 0 =\n            case past of\n                [] -> error \"not enough past!\"\n                (h : t) -> seek t h (str : future) (offset + S.length h) patPos\n          | strEnd < strPos =\n            case future of\n                [] -> (foldr (flip (.) . (:)) id past [str], [])\n                (h : t) -> let !off' = offset - strLen\n                               (past', !discharge) = keep (-off') (str : past)\n                             in\n                             if maxLen < S.length h then\n                               error \"Overflow in BoyerMoore.lazyBreak (future)\" else\n                               let (pre, post) = seek past' h t off' patPos in\n                                 (foldr (flip (.) . (:)) id discharge pre, post)\n          | patPos == patEnd = checkEnd strPos\n          | offset < 0 = matcherN offset patPos\n          | otherwise = matcherP offset patPos\n          where {-# INLINE strAt #-}\n                strAt !i = unsafeIndex str i\n                !strLen = S.length str\n                !strEnd = strLen - 1\n                !maxOff = strLen - patLen\n                !strPos = offset + patPos\n                checkEnd !sI\n                  | strEnd < sI = seek past str future (sI - patEnd) patEnd\n                  | otherwise =\n                    case strAt sI of\n                        !c | c == pe ->\n                             if sI < patEnd then\n                               (if sI == 0 then seek past str future (-patEnd) (patEnd - 1) else\n                                  matcherN (sI - patEnd) (patEnd - 1))\n                               else matcherP (sI - patEnd) (patEnd - 1)\n                           | otherwise -> checkEnd (sI + patEnd + occ c)\n                matcherN !off !patI\n                  = case strAt (off + patI) of\n                        !c | c == patAt patI ->\n                             if off + patI == 0 then seek past str future off (patI - 1) else\n                               matcherN off (patI - 1)\n                           | otherwise ->\n                             let !off' = off + max (suff patI) (patI + occ c) in\n                               if maxOff < off' then seek past str future off' patEnd else\n                                 checkEnd (off' + patEnd)\n                matcherP !off !patI\n                  = case strAt (off + patI) of\n                        !c | c == patAt patI ->\n                             if patI == 0 then\n                               let !pre = if off == 0 then [] else [S.take off str]\n                                   !post = S.drop off str\n                                 in (foldr (flip (.) . (:)) id past pre, post : future)\n                               else matcherP off (patI - 1)\n                           | otherwise ->\n                             let !off' = off + max (suff patI) (patI + occ c) in\n                               if maxOff < off' then seek past str future off' patEnd else\n                                 checkEnd (off' + patEnd)"],"instances":[],"language":{"extensions":["BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
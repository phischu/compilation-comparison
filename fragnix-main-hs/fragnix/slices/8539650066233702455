{"sliceID":8539650066233702455,"uses":[{"reference":{"otherSlice":6468298682039186647},"usedName":{"valueName":{"identifier":"reifyConTys"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"length"}},"qualification":null},{"reference":{"otherSlice":5300934711519751499},"usedName":{"valueName":{"identifier":"newNameList"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"zip"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":7332739957992962242},"usedName":{"valueName":{"identifier":"emptyArray_"}},"qualification":"E"},{"reference":{"otherSlice":3198347555409976524},"usedName":{"valueName":{"identifier":"dispatchToEncoding"}},"qualification":null},{"reference":{"otherSlice":1099420853876450354},"usedName":{"valueName":{"identifier":"array"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"foldr1"}},"qualification":null},{"reference":{"otherSlice":4468210030402328315},"usedName":{"valueName":{"operator":"<%>"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"otherSlice":439638757918524458},"usedName":{"valueName":{"identifier":"sumToEncoding"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"null"}},"qualification":null},{"reference":{"otherSlice":4512247588159674237},"usedName":{"valueName":{"identifier":"unwrapUnaryRecords"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"not"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":5507919707442773556},"usedName":{"valueName":{"identifier":"object"}},"qualification":null},{"reference":{"otherSlice":3628016301933981999},"usedName":{"valueName":{"identifier":"econcat"}},"qualification":"E"},{"reference":{"builtinModule":"Data.List"},"usedName":{"valueName":{"identifier":"intersperse"}},"qualification":null},{"reference":{"otherSlice":5640392682337773567},"usedName":{"valueName":{"identifier":"comma"}},"qualification":"E"},{"reference":{"otherSlice":4512247588159674237},"usedName":{"valueName":{"identifier":"omitNothingFields"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"zip3"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"valueName":{"identifier":"catMaybes"}},"qualification":null},{"reference":{"builtinModule":"Data.List"},"usedName":{"valueName":{"identifier":"partition"}},"qualification":null},{"reference":{"otherSlice":4760538052842005726},"usedName":{"valueName":{"identifier":"isMaybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":6719407552231569060},"usedName":{"valueName":{"operator":"<^>"}},"qualification":null},{"reference":{"otherSlice":5640392682337773567},"usedName":{"valueName":{"identifier":"colon"}},"qualification":"E"},{"reference":{"otherSlice":4137103122019276934},"usedName":{"valueName":{"operator":"><"}},"qualification":"E"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"operator":"<$>"}},"qualification":null},{"reference":{"otherSlice":8859284081890533327},"usedName":{"valueName":{"operator":"<:>"}},"qualification":null},{"reference":{"otherSlice":2048067546703867103},"usedName":{"valueName":{"identifier":"text"}},"qualification":"E"},{"reference":{"otherSlice":5420555374589246121},"usedName":{"valueName":{"identifier":"pack"}},"qualification":"T"},{"reference":{"otherSlice":7408368847678525969},"usedName":{"valueName":{"identifier":"fieldLabelExp"}},"qualification":null},{"reference":{"otherSlice":4512247588159674237},"usedName":{"valueName":{"identifier":"sumEncoding"}},"qualification":null},{"reference":{"otherSlice":2490827399793063090},"usedName":{"constructorName":{"identifier":"TwoElemArray"},"constructorTypeName":{"identifier":"SumEncoding"}},"qualification":null},{"reference":{"otherSlice":6390671972622275302},"usedName":{"valueName":{"identifier":"encStr"}},"qualification":null},{"reference":{"otherSlice":2490827399793063090},"usedName":{"constructorName":{"identifier":"TaggedObject"},"constructorTypeName":{"identifier":"SumEncoding"}},"qualification":null},{"reference":{"otherSlice":2490827399793063090},"usedName":{"valueName":{"identifier":"tagFieldName"}},"qualification":null},{"reference":{"otherSlice":2490827399793063090},"usedName":{"constructorName":{"identifier":"ObjectWithSingleField"},"constructorTypeName":{"identifier":"SumEncoding"}},"qualification":null},{"reference":{"otherSlice":2490827399793063090},"usedName":{"constructorName":{"identifier":"UntaggedValue"},"constructorTypeName":{"identifier":"SumEncoding"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"head"}},"qualification":null},{"reference":{"otherSlice":3790782889836978137},"usedName":{"typeName":{"identifier":"JSONClass"}},"qualification":null},{"reference":{"otherSlice":4512247588159674237},"usedName":{"typeName":{"identifier":"Options"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null}],"fragment":["argsToEncoding ::\n               JSONClass -> [(Name, Name)] -> Options -> Bool -> Con -> Q Match","argsToEncoding jc tes opts multiCons (NormalC conName ts)\n  = do (argTys, tvMap) <- reifyConTys jc tes conName\n       let len = length ts\n       args <- newNameList \"arg\" len\n       js <- case zip args argTys of\n                 [] -> return [| E.emptyArray_ |]\n                 [(e, eTy)] -> return\n                                 (dispatchToEncoding jc conName tvMap eTy `appE` varE e)\n                 es -> return\n                         (array\n                            (foldr1 (<%>)\n                               [dispatchToEncoding jc conName tvMap xTy `appE` varE x |\n                                (x, xTy) <- es]))\n       match (conP conName $ map varP args)\n         (normalB $ sumToEncoding opts multiCons (null ts) conName js)\n         []\nargsToEncoding jc tes opts multiCons (RecC conName ts)\n  = case (unwrapUnaryRecords opts, not multiCons, ts) of\n        (True, True, [(_, st, ty)]) -> argsToEncoding jc tes opts multiCons\n                                         (NormalC conName [(st, ty)])\n        _ -> do args <- newNameList \"arg\" $ length ts\n                (argTys, tvMap) <- reifyConTys jc tes conName\n                let exp = object objBody\n                    objBody\n                      = [| E.econcat |] `appE` ([| intersperse E.comma |] `appE` pairs)\n                    pairs\n                      | omitNothingFields opts =\n                        infixApp maybeFields [| (++) |] restFields\n                      | otherwise = listE (map toPair argCons)\n                    argCons = zip3 args argTys ts\n                    maybeFields = [| catMaybes |] `appE` listE (map maybeToPair maybes)\n                    restFields = listE (map toPair rest)\n                    (maybes, rest) = partition isMaybe argCons\n                    maybeToPair (arg, argTy, (field, _, _))\n                      = infixApp\n                          (infixApp\n                             (infixE (Just $ toFieldName field <^> [| E.colon |]) [| (E.><) |]\n                                Nothing)\n                             [| (.) |]\n                             (dispatchToEncoding jc conName tvMap argTy))\n                          [| (<$>) |]\n                          (varE arg)\n                    toPair (arg, argTy, (field, _, _))\n                      = toFieldName field <:>\n                          dispatchToEncoding jc conName tvMap argTy `appE` varE arg\n                    toFieldName field\n                      = [| E.text |] `appE`\n                          ([| T.pack |] `appE` fieldLabelExp opts field)\n                match (conP conName $ map varP args)\n                  (normalB $\n                     if multiCons then\n                       case sumEncoding opts of\n                           TwoElemArray -> array $ encStr opts conName <%> exp\n                           TaggedObject{tagFieldName} -> object $\n                                                           ([| E.text (T.pack tagFieldName) |] <:>\n                                                              encStr opts conName)\n                                                             <%> objBody\n                           ObjectWithSingleField -> object $ encStr opts conName <:> exp\n                           UntaggedValue -> exp\n                       else exp)\n                  []\nargsToEncoding jc tes opts multiCons (InfixC _ conName _)\n  = do al <- newName \"argL\"\n       ar <- newName \"argR\"\n       ([alTy, arTy], tvMap) <- reifyConTys jc tes conName\n       match (infixP (varP al) conName (varP ar))\n         (normalB $\n            sumToEncoding opts multiCons False conName $\n              array\n                (foldr1 (<%>)\n                   [dispatchToEncoding jc conName tvMap aTy `appE` varE a |\n                    (a, aTy) <- [(al, alTy), (ar, arTy)]]))\n         []\nargsToEncoding jc tes opts multiCons (ForallC _ _ con)\n  = argsToEncoding jc tes opts multiCons con\nargsToEncoding jc tes opts multiCons (GadtC conNames ts _)\n  = argsToEncoding jc tes opts multiCons $ NormalC (head conNames) ts\nargsToEncoding jc tes opts multiCons (RecGadtC conNames ts _)\n  = argsToEncoding jc tes opts multiCons $ RecC (head conNames) ts"],"instances":[],"language":{"extensions":["BangPatterns","FlexibleInstances","NamedFieldPuns","NoImplicitPrelude","UndecidableInstances","TemplateHaskellQuotes","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards","TemplateHaskell"],"isInstance":false}}
{"sliceID":8033869996351735523,"uses":[{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Applicative"}},"qualification":null},{"reference":{"otherSlice":836250808765999032},"usedName":{"typeName":{"identifier":"Array"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"pure"}},"qualification":null},{"reference":{"builtinModule":"GHC.ST"},"usedName":{"valueName":{"identifier":"runST"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":2701731213600886508},"usedName":{"valueName":{"identifier":"newArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"otherSlice":7901644516281080830},"usedName":{"valueName":{"identifier":"unsafeFreezeArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"<*>"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"otherSlice":5999148496770720081},"usedName":{"valueName":{"identifier":"die"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":7280415104757243858},"usedName":{"valueName":{"identifier":"indexArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":554915414788471638},"usedName":{"valueName":{"identifier":"writeArray"}},"qualification":null},{"reference":{"otherSlice":7297700151455758761},"usedName":{"valueName":{"identifier":"sizeofArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"*>"}},"qualification":null},{"reference":{"otherSlice":6359411244316829523},"usedName":{"valueName":{"identifier":"createArray"}},"qualification":null},{"reference":{"otherSlice":424073283210537862},"usedName":{"valueName":{"identifier":"copyArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"<*"}},"qualification":null}],"fragment":["instance Applicative Array where\n        pure x = runST $ newArray 1 x >>= unsafeFreezeArray\n        ab <*> a\n          = runST $\n              do mb <- newArray (szab * sza) $ die \"<*>\" \"impossible\"\n                 let go1 i\n                       | i < szab = go2 (i * sza) (indexArray ab i) 0 >> go1 (i + 1)\n                       | otherwise = return ()\n                     go2 off f j\n                       | j < sza = writeArray mb (off + j) (f $ indexArray a j)\n                       | otherwise = return ()\n                 go1 0\n                 unsafeFreezeArray mb\n          where szab = sizeofArray ab\n                sza = sizeofArray a\n        a *> b\n          = createArray (sza * szb) (die \"*>\" \"impossible\") $\n              \\ mb ->\n                let go i\n                      | i < sza = copyArray mb (i * szb) b 0 szb\n                      | otherwise = return ()\n                  in go 0\n          where sza = sizeofArray a\n                szb = sizeofArray b\n        a <* b\n          = createArray (sza * szb) (die \"<*\" \"impossible\") $\n              \\ ma ->\n                let fill off i e\n                      | i < szb = writeArray ma (off + i) e >> fill off (i + 1) e\n                      | otherwise = return ()\n                    go i\n                      | i < sza = fill (i * szb) 0 (indexArray a i) >> go (i + 1)\n                      | otherwise = return ()\n                  in go 0\n          where sza = sizeofArray a\n                szb = sizeofArray b"],"instances":[],"language":{"extensions":["MagicHash","UnboxedTuples","DeriveDataTypeable","BangPatterns","RankNTypes","TypeFamilies","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":true}}
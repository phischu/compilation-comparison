{"sliceID":3934350906810068733,"uses":[{"reference":{"otherSlice":7521817567785272208},"usedName":{"valueName":{"identifier":"empty"}},"qualification":null},{"reference":{"otherSlice":8952495918426714387},"usedName":{"valueName":{"identifier":"hasOneByte"}},"qualification":null},{"reference":{"otherSlice":8129972227451485047},"usedName":{"valueName":{"identifier":"getByte"}},"qualification":null},{"reference":{"otherSlice":1097455102875242181},"usedName":{"valueName":{"identifier":"toTokenHeader"}},"qualification":null},{"reference":{"otherSlice":359484736934200607},"usedName":{"valueName":{"operator":"<<"}},"qualification":null},{"reference":{"otherSlice":4524223153277317778},"usedName":{"valueName":{"identifier":"run"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"otherSlice":6267815227162739186},"usedName":{"valueName":{"identifier":"tokenFoldedKey"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":6383363541455760455},"usedName":{"typeName":{"identifier":"DynamicTable"}},"qualification":null},{"reference":{"otherSlice":3829111669494975350},"usedName":{"typeName":{"identifier":"ReadBuffer"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"otherSlice":376103273712644431},"usedName":{"typeName":{"identifier":"HeaderList"}},"qualification":null}],"fragment":["decodeSimple :: DynamicTable -> ReadBuffer -> IO HeaderList","decodeSimple dyntbl rbuf = go empty\n  where go builder\n          = do more <- hasOneByte rbuf\n               if more then\n                 do w <- getByte rbuf\n                    !tv <- toTokenHeader dyntbl w rbuf\n                    let builder' = builder << tv\n                    go builder'\n                 else\n                 do let !tvs = run builder\n                        !kvs = map (\\ (t, v) -> let !k = tokenFoldedKey t in (k, v)) tvs\n                    return kvs"],"instances":[],"language":{"extensions":["BangPatterns","RecordWildCards","OverloadedStrings","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
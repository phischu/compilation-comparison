{"sliceID":8331996149662481219,"uses":[{"reference":{"otherSlice":6258463563638113276},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"otherSlice":3110453240036143100},"usedName":{"valueName":{"identifier":"lazyBreak"}},"qualification":null},{"reference":{"otherSlice":5833678940193095900},"usedName":{"valueName":{"identifier":"lsplit"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"null"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"otherSlice":8642306666063513779},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"}],"fragment":["lazySplitKeepFront ::\n                   S.ByteString -> [S.ByteString] -> [[S.ByteString]]","lazySplitKeepFront pat = splitter'\n  where !patLen = S.length pat\n        breaker = lazyBreak pat\n        splitter' strs\n          = case splitter strs of\n                ([] : rest) -> rest\n                other -> other\n        splitter [] = []\n        splitter strs\n          = case breaker strs of\n                (pre, mtch) -> pre :\n                                 case mtch of\n                                     [] -> []\n                                     _ -> case lsplit patLen mtch of\n                                              (pt, rst) -> if null rst then [pt] else\n                                                             let (h : t) = splitter rst in\n                                                               (pt ++ h) : t"],"instances":[],"language":{"extensions":["BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
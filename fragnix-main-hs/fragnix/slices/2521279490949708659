{"sliceID":2521279490949708659,"uses":[{"reference":{"otherSlice":675696118971413715},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"otherSlice":6258463563638113276},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"otherSlice":3130773916720830677},"usedName":{"valueName":{"identifier":"kmpBorders"}},"qualification":null},{"reference":{"otherSlice":958675940120742873},"usedName":{"valueName":{"identifier":"unsafeAt"}},"qualification":null},{"reference":{"otherSlice":7420251549451097395},"usedName":{"valueName":{"identifier":"unsafeIndex"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"typeName":{"identifier":"Integral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":8642306666063513779},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"}],"fragment":["matcher ::\n          Integral a => Bool -> S.ByteString -> [S.ByteString] -> [a]","matcher _ !pat | S.null pat = (0 :) . go 0\n  where go _ [] = []\n        go !prior (!(str : rest))\n          = [prior + fromIntegral i | i <- [1 .. l]] ++ go prior' rest\n          where !l = S.length str\n                !prior' = prior + fromIntegral l\nmatcher !overlap pat = searcher 0 0\n  where !patLen = S.length pat\n        !bords = kmpBorders pat\n        !patH = patAt 0\n        \n        {-# INLINE misi #-}\n        misi !i = unsafeAt bords i\n        \n        {-# INLINE patAt #-}\n        patAt !i = unsafeIndex pat i\n        !ami = if overlap then misi patLen else 0\n        searcher _ _ [] = []\n        searcher !prior !patPos (!(str : rest))\n          | patPos == 0 = checkHead 0\n          | otherwise = findMatch patPos 0\n          where !strLen = S.length str\n                \n                {-# INLINE strAt #-}\n                strAt !i = unsafeIndex str i\n                checkHead !strI\n                  | strI == strLen = searcher (prior + fromIntegral strLen) 0 rest\n                  | strAt strI == patH = findMatch 1 (strI + 1)\n                  | otherwise = checkHead (strI + 1)\n                findMatch !patI !strI\n                  | patI == patLen =\n                    (prior + fromIntegral strI - fromIntegral patLen) :\n                      if ami == 0 then checkHead strI else findMatch ami strI\n                  | strI == strLen = searcher (prior + fromIntegral strLen) patI rest\n                  | otherwise =\n                    if strAt strI == patAt patI then findMatch (patI + 1) (strI + 1)\n                      else\n                      case misi patI of\n                          0 -> checkHead strI\n                          (-1) -> checkHead (strI + 1)\n                          pI -> findMatch pI strI"],"instances":[],"language":{"extensions":["BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
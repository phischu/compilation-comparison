{"sliceID":3835607281723772359,"uses":[{"reference":{"otherSlice":1366305008510466253},"usedName":{"valueName":{"identifier":"equalFilePath"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"/="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"dropWhile"}},"qualification":null},{"reference":{"otherSlice":8016967709815987406},"usedName":{"valueName":{"identifier":"isPathSeparator"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"break"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":8941969549242563641},"usedName":{"valueName":{"identifier":"dropDrive"}},"qualification":null},{"reference":{"otherSlice":874117597288315808},"usedName":{"valueName":{"identifier":"pathSeparator"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"builtinModule":"GHC.Unicode"},"usedName":{"valueName":{"identifier":"toLower"}},"qualification":null},{"reference":{"otherSlice":6282195426548794871},"usedName":{"valueName":{"identifier":"takeDrive"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO"},"usedName":{"typeName":{"identifier":"FilePath"}},"qualification":null}],"fragment":["makeRelative :: FilePath -> FilePath -> FilePath","makeRelative root path\n  | equalFilePath root path = \".\"\n  | takeAbs root /= takeAbs path = path\n  | otherwise = f (dropAbs root) (dropAbs path)\n  where f \"\" y = dropWhile isPathSeparator y\n        f x y\n          = let (x1, x2) = g x\n                (y1, y2) = g y\n              in if equalFilePath x1 y1 then f x2 y2 else path\n        g x = (dropWhile isPathSeparator a, dropWhile isPathSeparator b)\n          where (a, b) = break isPathSeparator $ dropWhile isPathSeparator x\n        dropAbs (x : xs) | isPathSeparator x = xs\n        dropAbs x = dropDrive x\n        takeAbs (x : _) | isPathSeparator x = [pathSeparator]\n        takeAbs x\n          = map\n              (\\ y -> if isPathSeparator y then pathSeparator else toLower y)\n              $ takeDrive x"],"instances":[],"language":{"extensions":["MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
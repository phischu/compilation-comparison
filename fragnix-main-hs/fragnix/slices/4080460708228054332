{"sliceID":4080460708228054332,"uses":[{"reference":{"otherSlice":7235567377809295464},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"otherSlice":4368397506866556061},"usedName":{"valueName":{"identifier":"occurs"}},"qualification":null},{"reference":{"otherSlice":696973203919167932},"usedName":{"valueName":{"identifier":"suffShifts"}},"qualification":null},{"reference":{"builtinModule":"GHC.Enum"},"usedName":{"valueName":{"identifier":"maxBound"}},"qualification":null},{"reference":{"otherSlice":7493882458078027726},"usedName":{"valueName":{"identifier":"unsafeIndex"}},"qualification":null},{"reference":{"otherSlice":3191844957948247487},"usedName":{"valueName":{"identifier":"unsafeAt"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"error"}},"qualification":null},{"reference":{"otherSlice":3748312495235440417},"usedName":{"valueName":{"identifier":"drop"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":4010822550476529195},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"foldr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"flip"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"id"}},"qualification":null},{"reference":{"otherSlice":5195162226803900797},"usedName":{"valueName":{"identifier":"keep"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"max"}},"qualification":null},{"reference":{"otherSlice":380767506459821795},"usedName":{"valueName":{"identifier":"take"}},"qualification":"S"}],"fragment":["lazyRepl ::\n         S.ByteString ->\n           ([S.ByteString] -> [S.ByteString]) ->\n             [S.ByteString] -> [S.ByteString]","lazyRepl pat = replacer\n  where !patLen = S.length pat\n        !patEnd = patLen - 1\n        !occT = occurs pat\n        !suffT = suffShifts pat\n        !maxLen = maxBound - patLen\n        !pe = patAt patEnd\n        \n        {-# INLINE patAt #-}\n        patAt !i = unsafeIndex pat i\n        \n        {-# INLINE occ #-}\n        occ !w = unsafeAt occT (fromIntegral w)\n        \n        {-# INLINE suff #-}\n        suff !i = unsafeAt suffT i\n        replacer sub lst\n          = case lst of\n                [] -> []\n                (h : t) -> if maxLen < S.length h then\n                             error \"Overflow in BoyerMoore.lazyRepl\" else seek [] h t 0 patEnd\n          where chop _ [] = []\n                chop !k (!(str : rest))\n                  | k < s =\n                    if maxLen < (s - k) then\n                      error \"Overflow in BoyerMoore.lazyRepl (chop)\" else\n                      seek [] (S.drop k str) rest 0 patEnd\n                  | otherwise = chop (k - s) rest\n                  where !s = S.length str\n                \n                seek ::\n                     [S.ByteString] ->\n                       S.ByteString -> [S.ByteString] -> Int -> Int -> [S.ByteString]\n                seek !past !str fut !offset !patPos\n                  | strPos < 0 =\n                    case past of\n                        [] -> error \"not enough past!\"\n                        (h : t) -> seek t h (str : fut) (offset + S.length h) patPos\n                  | strEnd < strPos =\n                    case fut of\n                        [] -> foldr (flip (.) . (:)) id past [str]\n                        (h : t) -> let !off' = offset - strLen\n                                       (past', !discharge) = keep (-off') (str : past)\n                                     in\n                                     if maxLen < S.length h then\n                                       error \"Overflow in BoyerMoore.lazyRepl (future)\" else\n                                       foldr (flip (.) . (:)) id discharge $\n                                         seek past' h t off' patPos\n                  | patPos == patEnd = checkEnd strPos\n                  | offset < 0 = matcherN offset patPos\n                  | otherwise = matcherP offset patPos\n                  where {-# INLINE strAt #-}\n                        strAt !i = unsafeIndex str i\n                        !strLen = S.length str\n                        !strEnd = strLen - 1\n                        !maxOff = strLen - patLen\n                        !strPos = offset + patPos\n                        checkEnd !sI\n                          | strEnd < sI = seek past str fut (sI - patEnd) patEnd\n                          | otherwise =\n                            case strAt sI of\n                                !c | c == pe ->\n                                     if sI < patEnd then\n                                       (if sI == 0 then seek past str fut (-patEnd) (patEnd - 1)\n                                          else matcherN (sI - patEnd) (patEnd - 1))\n                                       else matcherP (sI - patEnd) (patEnd - 1)\n                                   | otherwise -> checkEnd (sI + patEnd + occ c)\n                        matcherN !off !patI\n                          = case strAt (off + patI) of\n                                !c | c == patAt patI ->\n                                     if off + patI == 0 then seek past str fut off (patI - 1) else\n                                       matcherN off (patI - 1)\n                                   | otherwise ->\n                                     let !off' = off + max (suff patI) (patI + occ c) in\n                                       if maxOff < off' then seek past str fut off' patEnd else\n                                         checkEnd (off' + patEnd)\n                        matcherP !off !patI\n                          = case strAt (off + patI) of\n                                !c | c == patAt patI ->\n                                     if patI == 0 then\n                                       foldr (flip (.) . (:)) id past $\n                                         let pre = if off == 0 then id else (S.take off str :) in\n                                           pre . sub $\n                                             let !p = off + patLen in\n                                               if p < strLen then\n                                                 seek [] (S.drop p str) fut 0 patEnd else\n                                                 chop (p - strLen) fut\n                                       else matcherP off (patI - 1)\n                                   | otherwise ->\n                                     let !off' = off + max (suff patI) (patI + occ c) in\n                                       if maxOff < off' then seek past str fut off' patEnd else\n                                         checkEnd (off' + patEnd)"],"instances":[],"language":{"extensions":["BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
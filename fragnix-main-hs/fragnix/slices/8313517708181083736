{"sliceID":8313517708181083736,"uses":[{"reference":{"otherSlice":968296184656941152},"usedName":{"valueName":{"identifier":"break"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"id"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":6985366053944096403},"usedName":{"valueName":{"identifier":"drop"}},"qualification":"S"},{"reference":{"otherSlice":675696118971413715},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":8651865326705395037},"usedName":{"valueName":{"identifier":"dropWhile"}},"qualification":"S"},{"reference":{"builtinModule":"Data.Tuple"},"usedName":{"valueName":{"identifier":"fst"}},"qualification":null},{"reference":{"otherSlice":8258718026201843775},"usedName":{"valueName":{"identifier":"breakEnd"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"/="}},"qualification":null},{"reference":{"otherSlice":8642306666063513779},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"}],"fragment":["parseContentType ::\n                 S.ByteString -> (S.ByteString, [(S.ByteString, S.ByteString)])","parseContentType a\n  = do let (ctype, b) = S.break (== semicolon) a\n           attrs = goAttrs id $ S.drop 1 b\n         in (ctype, attrs)\n  where semicolon = 59\n        equals = 61\n        space = 32\n        goAttrs front bs\n          | S.null bs = front []\n          | otherwise =\n            let (x, rest) = S.break (== semicolon) bs in\n              goAttrs (front . (goAttr x :)) $ S.drop 1 rest\n        goAttr bs\n          = let (k, v') = S.break (== equals) bs\n                v = S.drop 1 v'\n              in (strip k, strip v)\n        strip = S.dropWhile (== space) . fst . S.breakEnd (/= space)"],"instances":[],"language":{"extensions":["OverloadedStrings","ExistentialQuantification","PatternGuards","TypeFamilies","RankNTypes","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll"],"isInstance":false}}
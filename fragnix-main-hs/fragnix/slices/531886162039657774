{"sliceID":531886162039657774,"uses":[{"reference":{"otherSlice":1117299957054012877},"usedName":{"constructorName":{"identifier":"DecompressParams"},"constructorTypeName":{"identifier":"DecompressParams"}},"qualification":null},{"reference":{"otherSlice":485333622601141093},"usedName":{"valueName":{"identifier":"run"}},"qualification":"Stream"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":2364574481817449760},"usedName":{"valueName":{"identifier":"inflateInit"}},"qualification":"Stream"},{"reference":{"otherSlice":9091181793480111601},"usedName":{"valueName":{"identifier":"toChunks"}},"qualification":"L"},{"reference":{"otherSlice":8642306666063513779},"usedName":{"constructorName":{"identifier":"PS"},"constructorTypeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"otherSlice":3322703672414279104},"usedName":{"valueName":{"identifier":"pushInputBuffer"}},"qualification":"Stream"},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"otherSlice":8642306666063513779},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"otherSlice":2792556818527605581},"usedName":{"typeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"otherSlice":2387895976868100660},"usedName":{"typeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"otherSlice":2788873788275344703},"usedName":{"valueName":{"identifier":"inputBufferEmpty"}},"qualification":"Stream"},{"reference":{"otherSlice":8890257045515737105},"usedName":{"valueName":{"identifier":"outputBufferFull"}},"qualification":"Stream"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"assert"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"||"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"when"}},"qualification":null},{"reference":{"otherSlice":2778596240580165680},"usedName":{"valueName":{"identifier":"unsafeLiftIO"}},"qualification":"Stream"},{"reference":{"otherSlice":8772400319191501505},"usedName":{"valueName":{"identifier":"mallocByteString"}},"qualification":"S"},{"reference":{"otherSlice":7487703413674984992},"usedName":{"valueName":{"identifier":"pushOutputBuffer"}},"qualification":"Stream"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"not"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"&&"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"null"}},"qualification":null},{"reference":{"otherSlice":2334941969787710877},"usedName":{"valueName":{"identifier":"inflate"}},"qualification":"Stream"},{"reference":{"otherSlice":301371971675441703},"usedName":{"constructorName":{"identifier":"NoFlush"},"constructorTypeName":{"identifier":"Flush"}},"qualification":"Stream"},{"reference":{"otherSlice":3313324963614757746},"usedName":{"constructorName":{"identifier":"Ok"},"constructorTypeName":{"identifier":"Status"}},"qualification":"Stream"},{"reference":{"otherSlice":1109438053661961098},"usedName":{"valueName":{"identifier":"popOutputBuffer"}},"qualification":"Stream"},{"reference":{"otherSlice":4429892730289619114},"usedName":{"valueName":{"identifier":"unsafeInterleave"}},"qualification":"Stream"},{"reference":{"otherSlice":7657990540697301033},"usedName":{"valueName":{"identifier":"defaultDecompressBufferSize"}},"qualification":null},{"reference":{"otherSlice":2387895976868100660},"usedName":{"constructorName":{"identifier":"StreamChunk"},"constructorTypeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"otherSlice":3313324963614757746},"usedName":{"constructorName":{"identifier":"StreamEnd"},"constructorTypeName":{"identifier":"Status"}},"qualification":"Stream"},{"reference":{"builtinModule":"GHC.Prim"},"usedName":{"valueName":{"identifier":"seq"}},"qualification":null},{"reference":{"otherSlice":2387895976868100660},"usedName":{"constructorName":{"identifier":"StreamEnd"},"constructorTypeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"otherSlice":3313324963614757746},"usedName":{"constructorName":{"identifier":"Error"},"constructorTypeName":{"identifier":"Status"}},"qualification":"Stream"},{"reference":{"otherSlice":5456935967306518022},"usedName":{"constructorName":{"identifier":"BufferError"},"constructorTypeName":{"identifier":"ErrorCode"}},"qualification":"Stream"},{"reference":{"otherSlice":2387895976868100660},"usedName":{"constructorName":{"identifier":"StreamError"},"constructorTypeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"otherSlice":5666975279501768357},"usedName":{"constructorName":{"identifier":"TruncatedInput"},"constructorTypeName":{"identifier":"DecompressError"}},"qualification":null},{"reference":{"otherSlice":5456935967306518022},"usedName":{"constructorName":{"identifier":"NeedDict"},"constructorTypeName":{"identifier":"ErrorCode"}},"qualification":"Stream"},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":5456935967306518022},"usedName":{"constructorName":{"identifier":"DataError"},"constructorTypeName":{"identifier":"ErrorCode"}},"qualification":"Stream"},{"reference":{"otherSlice":5666975279501768357},"usedName":{"constructorName":{"identifier":"DataError"},"constructorTypeName":{"identifier":"DecompressError"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"fail"}},"qualification":null},{"reference":{"otherSlice":2397344891765167000},"usedName":{"valueName":{"identifier":"outputBufferBytesAvailable"}},"qualification":"Stream"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">"}},"qualification":null},{"reference":{"otherSlice":7309703476355789929},"usedName":{"valueName":{"identifier":"finalise"}},"qualification":"Stream"},{"reference":{"otherSlice":6330359818578713224},"usedName":{"typeName":{"identifier":"DictionaryHash"}},"qualification":"Stream"},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":5666975279501768357},"usedName":{"constructorName":{"identifier":"DictionaryRequired"},"constructorTypeName":{"identifier":"DecompressError"}},"qualification":null},{"reference":{"otherSlice":798189419127906741},"usedName":{"valueName":{"identifier":"inflateSetDictionary"}},"qualification":"Stream"},{"reference":{"otherSlice":5456935967306518022},"usedName":{"constructorName":{"identifier":"StreamError"},"constructorTypeName":{"identifier":"ErrorCode"}},"qualification":"Stream"},{"reference":{"otherSlice":620627319155400790},"usedName":{"typeName":{"identifier":"Format"}},"qualification":"Stream"},{"reference":{"otherSlice":1117299957054012877},"usedName":{"typeName":{"identifier":"DecompressParams"}},"qualification":null},{"reference":{"otherSlice":1699226608098321587},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"L"}],"fragment":["decompressWithErrors ::\n                     Stream.Format ->\n                       DecompressParams -> L.ByteString -> DecompressStream","decompressWithErrors format\n  (DecompressParams bits initChunkSize mdict) input\n  = Stream.run $\n      do Stream.inflateInit format bits\n         case L.toChunks input of\n             [] -> fillBuffers 4 []\n             S.PS inFPtr offset length : chunks -> do Stream.pushInputBuffer\n                                                        inFPtr\n                                                        offset\n                                                        length\n                                                      fillBuffers initChunkSize chunks\n  where fillBuffers ::\n                    Int -> [S.ByteString] -> Stream DecompressStream\n        fillBuffers outChunkSize inChunks\n          = do inputBufferEmpty <- Stream.inputBufferEmpty\n               outputBufferFull <- Stream.outputBufferFull\n               assert (inputBufferEmpty || outputBufferFull) $ return ()\n               when outputBufferFull $\n                 do outFPtr <- Stream.unsafeLiftIO (S.mallocByteString outChunkSize)\n                    Stream.pushOutputBuffer outFPtr 0 outChunkSize\n               if inputBufferEmpty then\n                 case inChunks of\n                     [] -> drainBuffers []\n                     S.PS inFPtr offset length : inChunks' -> do Stream.pushInputBuffer\n                                                                   inFPtr\n                                                                   offset\n                                                                   length\n                                                                 drainBuffers inChunks'\n                 else drainBuffers inChunks\n        \n        drainBuffers :: [S.ByteString] -> Stream DecompressStream\n        drainBuffers inChunks\n          = do inputBufferEmpty' <- Stream.inputBufferEmpty\n               outputBufferFull' <- Stream.outputBufferFull\n               assert\n                 (not outputBufferFull' && (null inChunks || not inputBufferEmpty'))\n                 $ return ()\n               status <- Stream.inflate Stream.NoFlush\n               case status of\n                   Stream.Ok -> do outputBufferFull <- Stream.outputBufferFull\n                                   if outputBufferFull then\n                                     do (outFPtr, offset, length) <- Stream.popOutputBuffer\n                                        outChunks <- Stream.unsafeInterleave\n                                                       (fillBuffers defaultDecompressBufferSize\n                                                          inChunks)\n                                        return $ StreamChunk (S.PS outFPtr offset length) outChunks\n                                     else do fillBuffers defaultDecompressBufferSize inChunks\n                   Stream.StreamEnd -> inChunks `seq` finish StreamEnd\n                   Stream.Error code msg -> case code of\n                                                Stream.BufferError -> finish\n                                                                        (StreamError TruncatedInput\n                                                                           msg')\n                                                  where msg' = \"premature end of compressed stream\"\n                                                Stream.NeedDict adler -> do err <- setDictionary\n                                                                                     adler\n                                                                                     mdict\n                                                                            case err of\n                                                                                Just\n                                                                                  streamErr -> finish\n                                                                                                 streamErr\n                                                                                Nothing -> drainBuffers\n                                                                                             inChunks\n                                                Stream.DataError -> finish\n                                                                      (StreamError DataError msg)\n                                                _ -> fail msg\n        finish end\n          = do outputBufferBytesAvailable <- Stream.outputBufferBytesAvailable\n               if outputBufferBytesAvailable > 0 then\n                 do (outFPtr, offset, length) <- Stream.popOutputBuffer\n                    Stream.finalise\n                    return (StreamChunk (S.PS outFPtr offset length) end)\n                 else\n                 do Stream.finalise\n                    return end\n        \n        setDictionary ::\n                      Stream.DictionaryHash ->\n                        Maybe S.ByteString -> Stream (Maybe DecompressStream)\n        setDictionary _adler Nothing\n          = return $\n              Just (StreamError DictionaryRequired \"custom dictionary needed\")\n        setDictionary _adler (Just dict)\n          = do status <- Stream.inflateSetDictionary dict\n               case status of\n                   Stream.Ok -> return Nothing\n                   Stream.Error Stream.StreamError _ -> return $\n                                                          Just\n                                                            (StreamError DictionaryRequired\n                                                               \"provided dictionary not valid\")\n                   Stream.Error Stream.DataError _ -> return $\n                                                        Just\n                                                          (StreamError DictionaryRequired\n                                                             \"given dictionary does not match the expected one\")\n                   _ -> fail \"error when setting inflate dictionary\""],"instances":[],"language":{"extensions":["ForeignFunctionInterface","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
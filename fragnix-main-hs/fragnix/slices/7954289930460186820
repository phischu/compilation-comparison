{"sliceID":7954289930460186820,"uses":[{"reference":{"otherSlice":2958303632770465718},"usedName":{"constructorName":{"identifier":"PriorityTree"},"constructorTypeName":{"identifier":"PriorityTree"}},"qualification":null},{"reference":{"otherSlice":1212538307867996875},"usedName":{"valueName":{"identifier":"dequeue"}},"qualification":"Q"},{"reference":{"otherSlice":7540965333211353980},"usedName":{"constructorName":{"identifier":"Child"},"constructorTypeName":{"identifier":"Element"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$!"}},"qualification":null},{"reference":{"otherSlice":7540965333211353980},"usedName":{"constructorName":{"identifier":"Parent"},"constructorTypeName":{"identifier":"Element"}},"qualification":null},{"reference":{"otherSlice":8480493952620872628},"usedName":{"valueName":{"identifier":"isEmpty"}},"qualification":"Q"},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"unless"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":1048600942091142715},"usedName":{"valueName":{"identifier":"enqueue"}},"qualification":"Q"},{"reference":{"otherSlice":2958303632770465718},"usedName":{"typeName":{"identifier":"PriorityTree"}},"qualification":null},{"reference":{"builtinModule":"GHC.Conc.Sync"},"usedName":{"typeName":{"identifier":"STM"}},"qualification":null},{"reference":{"otherSlice":3763678114540243998},"usedName":{"typeName":{"identifier":"StreamId"}},"qualification":null},{"reference":{"otherSlice":269795606805388831},"usedName":{"typeName":{"identifier":"Precedence"}},"qualification":null}],"fragment":["dequeueSTM :: PriorityTree a -> STM (StreamId, Precedence, a)","dequeueSTM (PriorityTree _ q0) = loop q0\n  where loop q\n          = do (sid, p, el) <- Q.dequeue q\n               case el of\n                   Child x -> return $! (sid, p, x)\n                   Parent q' -> do entr <- loop q'\n                                   empty <- Q.isEmpty q'\n                                   unless empty $ Q.enqueue q sid p el\n                                   return entr"],"instances":[],"language":{"extensions":["BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
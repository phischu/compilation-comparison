{"sliceID":3788859768353318382,"uses":[{"reference":{"otherSlice":1254073128444822395},"usedName":{"constructorName":{"identifier":"Stream"},"constructorTypeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Left"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":2120320550836080743},"usedName":{"constructorName":{"identifier":"Yield"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":2120320550836080743},"usedName":{"constructorName":{"identifier":"Skip"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Right"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":2120320550836080743},"usedName":{"constructorName":{"identifier":"Done"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Monad"}},"qualification":null},{"reference":{"otherSlice":1254073128444822395},"usedName":{"typeName":{"identifier":"Stream"}},"qualification":null}],"fragment":["concatMapM ::\n             Monad m => (a -> m (Stream m b)) -> Stream m a -> Stream m b","concatMapM f (Stream step t) = Stream concatMap_go (Left t)\n  where concatMap_go (Left s)\n          = do r <- step s\n               case r of\n                   Yield a s' -> do b_stream <- f a\n                                    return $ Skip (Right (b_stream, s'))\n                   Skip s' -> return $ Skip (Left s')\n                   Done -> return Done\n        concatMap_go (Right (Stream inner_step inner_s, s))\n          = do r <- inner_step inner_s\n               case r of\n                   Yield b inner_s' -> return $\n                                         Yield b (Right (Stream inner_step inner_s', s))\n                   Skip inner_s' -> return $\n                                      Skip (Right (Stream inner_step inner_s', s))\n                   Done -> return $ Skip (Left s)"],"instances":[],"language":{"extensions":["ExistentialQuantification","MultiParamTypeClasses","FlexibleInstances","Rank2Types","BangPatterns","KindSignatures","GADTs","ScopedTypeVariables","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
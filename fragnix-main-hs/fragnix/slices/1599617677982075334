{"sliceID":1599617677982075334,"uses":[{"reference":{"otherSlice":1254073128444822395},"usedName":{"constructorName":{"identifier":"Stream"},"constructorTypeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":2120320550836080743},"usedName":{"constructorName":{"identifier":"Yield"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"otherSlice":2120320550836080743},"usedName":{"constructorName":{"identifier":"Skip"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":2120320550836080743},"usedName":{"constructorName":{"identifier":"Done"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Monad"}},"qualification":null},{"reference":{"otherSlice":1254073128444822395},"usedName":{"typeName":{"identifier":"Stream"}},"qualification":null}],"fragment":["zipWith3M ::\n            Monad m =>\n            (a -> b -> c -> m d) ->\n              Stream m a -> Stream m b -> Stream m c -> Stream m d","zipWith3M f (Stream stepa ta) (Stream stepb tb) (Stream stepc tc)\n  = Stream step (ta, tb, tc, Nothing)\n  where {-# INLINE [0] step #-}\n        step (sa, sb, sc, Nothing)\n          = do r <- stepa sa\n               return $\n                 case r of\n                     Yield x sa' -> Skip (sa', sb, sc, Just (x, Nothing))\n                     Skip sa' -> Skip (sa', sb, sc, Nothing)\n                     Done -> Done\n        step (sa, sb, sc, Just (x, Nothing))\n          = do r <- stepb sb\n               return $\n                 case r of\n                     Yield y sb' -> Skip (sa, sb', sc, Just (x, Just y))\n                     Skip sb' -> Skip (sa, sb', sc, Just (x, Nothing))\n                     Done -> Done\n        step (sa, sb, sc, Just (x, Just y))\n          = do r <- stepc sc\n               case r of\n                   Yield z sc' -> f x y z >>=\n                                    (\\ res -> return $ Yield res (sa, sb, sc', Nothing))\n                   Skip sc' -> return $ Skip (sa, sb, sc', Just (x, Just y))\n                   Done -> return $ Done"],"instances":[],"language":{"extensions":["ExistentialQuantification","MultiParamTypeClasses","FlexibleInstances","Rank2Types","BangPatterns","KindSignatures","GADTs","ScopedTypeVariables","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
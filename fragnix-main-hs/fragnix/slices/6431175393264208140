{"sliceID":6431175393264208140,"uses":[{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"typeName":{"identifier":"Ptr"}},"qualification":null},{"reference":{"otherSlice":3743132549088005222},"usedName":{"typeName":{"identifier":"CRegex"}},"qualification":null},{"reference":{"builtinModule":"Foreign.C.String"},"usedName":{"typeName":{"identifier":"CString"}},"qualification":null},{"reference":{"builtinModule":"Foreign.C.Types"},"usedName":{"typeName":{"identifier":"CSize"}},"qualification":null},{"reference":{"otherSlice":7125426414712168640},"usedName":{"typeName":{"identifier":"CRegMatch"}},"qualification":null},{"reference":{"otherSlice":6777075013164680088},"usedName":{"typeName":{"identifier":"ExecOption"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"typeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":106396208025620094},"usedName":{"typeName":{"identifier":"WrapError"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":8898595847961145836},"usedName":{"typeName":{"identifier":"RegOffset"}},"qualification":null},{"reference":{"otherSlice":6851686643024694980},"usedName":{"valueName":{"identifier":"c_regexec"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":2111864715456074790},"usedName":{"valueName":{"identifier":"retOk"}},"qualification":null},{"reference":{"builtinModule":"Data.Traversable"},"usedName":{"valueName":{"identifier":"mapM"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"take"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"iterate"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"plusPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Right"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":7056436270160315297},"usedName":{"valueName":{"identifier":"retNoMatch"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":7549104589823954046},"usedName":{"valueName":{"identifier":"wrapError"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Storable"},"usedName":{"valueName":{"identifier":"peekByteOff"}},"qualification":null},{"reference":{"builtinModule":"GHC.Int"},"usedName":{"typeName":{"identifier":"Int32"}},"qualification":null}],"fragment":["doMatch ::\n        Ptr CRegex ->\n          CString ->\n            CSize ->\n              Ptr CRegMatch ->\n                ExecOption ->\n                  IO (Either WrapError (Maybe [(RegOffset, RegOffset)]))","doMatch regex_ptr cstr nsub p_match flags\n  = do r <- c_regexec regex_ptr cstr (1 + nsub) p_match flags\n       if r == retOk then\n         do regions <- mapM getOffsets .\n                         take (1 + fromIntegral nsub) . iterate (`plusPtr` (8))\n                         $ p_match\n            return (Right (Just regions))\n         else\n         if r == retNoMatch then return (Right Nothing) else\n           wrapError r regex_ptr\n  where getOffsets :: Ptr CRegMatch -> IO (RegOffset, RegOffset)\n        \n        {-# INLINE getOffsets #-}\n        getOffsets pmatch'\n          = do start <- ((\\ hsc_ptr -> peekByteOff hsc_ptr 0)) pmatch' ::\n                          IO (Int32)\n               end <- ((\\ hsc_ptr -> peekByteOff hsc_ptr 4)) pmatch' :: IO (Int32)\n               return (fromIntegral start, fromIntegral end)"],"instances":[],"language":{"extensions":["MultiParamTypeClasses","FunctionalDependencies","ForeignFunctionInterface","GeneralizedNewtypeDeriving","FlexibleContexts","TypeSynonymInstances","FlexibleInstances","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
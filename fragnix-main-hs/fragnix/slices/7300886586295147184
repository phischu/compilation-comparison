{"sliceID":7300886586295147184,"uses":[{"reference":{"builtinModule":"GHC.Float"},"usedName":{"valueName":{"identifier":"decodeFloat"}},"qualification":null},{"reference":{"builtinModule":"GHC.Float"},"usedName":{"valueName":{"identifier":"floatRange"}},"qualification":null},{"reference":{"builtinModule":"GHC.Float"},"usedName":{"valueName":{"identifier":"floatDigits"}},"qualification":null},{"reference":{"builtinModule":"GHC.Float"},"usedName":{"valueName":{"identifier":"floatRadix"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"quot"}},"qualification":null},{"reference":{"otherSlice":4393327300197448547},"usedName":{"valueName":{"identifier":"expt"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">="}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"&&"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"ceiling"}},"qualification":null},{"reference":{"builtinModule":"GHC.Float"},"usedName":{"valueName":{"identifier":"log"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"identifier":"fromInteger"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Float"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"operator":"/"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<="}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"quotRem"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"reverse"}},"qualification":null},{"reference":{"builtinModule":"GHC.Float"},"usedName":{"typeName":{"identifier":"RealFloat"}},"qualification":null}],"fragment":["floatToDigits :: (RealFloat a) => a -> ([Int], Int)","floatToDigits 0 = ([0], 0)\nfloatToDigits x\n  = let (f0, e0) = decodeFloat x\n        (minExp0, _) = floatRange x\n        p = floatDigits x\n        b = floatRadix x\n        minExp = minExp0 - p\n        (f, e)\n          = let n = minExp - e0 in\n              if n > 0 then (f0 `quot` (expt b n), e0 + n) else (f0, e0)\n        (r, s, mUp, mDn)\n          = if e >= 0 then\n              let be = expt b e in\n                if f == expt b (p - 1) then (f * be * b * 2, 2 * b, be * b, be)\n                  else (f * be * 2, 2, be, be)\n              else\n              if e > minExp && f == expt b (p - 1) then\n                (f * b * 2, expt b ((-e) + 1) * 2, b, 1) else\n                (f * 2, expt b (-e) * 2, 1, 1)\n        \n        k :: Int\n        k = let k0 :: Int\n                k0\n                  = if b == 2 then\n                      let lx = p - 1 + e0\n                          k1 = (lx * 8651) `quot` 28738\n                        in if lx >= 0 then k1 + 1 else k1\n                      else\n                      ceiling\n                        ((log (fromInteger (f + 1) :: Float) +\n                            fromIntegral e * log (fromInteger b))\n                           / log 10)\n                fixup n\n                  = if n >= 0 then\n                      if r + mUp <= expt 10 n * s then n else fixup (n + 1) else\n                      if expt 10 (-n) * (r + mUp) <= s then n else fixup (n + 1)\n              in fixup k0\n        gen ds rn sN mUpN mDnN\n          = let (dn, rn') = (rn * 10) `quotRem` sN\n                mUpN' = mUpN * 10\n                mDnN' = mDnN * 10\n              in\n              case (rn' < mDnN', rn' + mUpN' > sN) of\n                  (True, False) -> dn : ds\n                  (False, True) -> dn + 1 : ds\n                  (True, True) -> if rn' * 2 < sN then dn : ds else dn + 1 : ds\n                  (False, False) -> gen (dn : ds) rn' sN mUpN' mDnN'\n        rds\n          = if k >= 0 then gen [] r (s * expt 10 k) mUp mDn else\n              let bk = expt 10 (-k) in gen [] (r * bk) s (mUp * bk) (mDn * bk)\n      in (map fromIntegral (reverse rds), k)"],"instances":[],"language":{"extensions":["OverloadedStrings","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
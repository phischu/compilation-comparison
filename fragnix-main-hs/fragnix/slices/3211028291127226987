{"sliceID":3211028291127226987,"uses":[{"reference":{"otherSlice":4302051445882722562},"usedName":{"valueName":{"identifier":"runPut"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"otherSlice":8496573510002582276},"usedName":{"typeName":{"identifier":"BuildStep"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Handle.Internals"},"usedName":{"valueName":{"identifier":"wantWritableHandle"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Handle.Types"},"usedName":{"typeName":{"identifier":"Handle__"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"=<<"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"readIORef"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Handle.Types"},"usedName":{"valueName":{"identifier":"haByteBuffer"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Buffer"},"usedName":{"valueName":{"identifier":"bufSize"}},"qualification":"IO"},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Buffer"},"usedName":{"valueName":{"identifier":"bufR"}},"qualification":"IO"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Handle.Internals"},"usedName":{"valueName":{"identifier":"flushWriteBuffer"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Buffer"},"usedName":{"valueName":{"identifier":"bufState"}},"qualification":"IO"},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"operator":"<$>"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Buffer"},"usedName":{"valueName":{"identifier":"newByteBuffer"}},"qualification":"IO"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"writeIORef"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"error"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"Data.OldList"},"usedName":{"valueName":{"identifier":"unlines"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"builtinModule":"GHC.Show"},"usedName":{"valueName":{"identifier":"show"}},"qualification":null},{"reference":{"otherSlice":38613747648554582},"usedName":{"constructorName":{"identifier":"BufferRange"},"constructorTypeName":{"identifier":"BufferRange"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"plusPtr"}},"qualification":null},{"reference":{"otherSlice":7838743463568576031},"usedName":{"valueName":{"identifier":"fillWithBuildStep"}},"qualification":null},{"reference":{"builtinModule":"GHC.ForeignPtr"},"usedName":{"valueName":{"identifier":"touchForeignPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Buffer"},"usedName":{"valueName":{"identifier":"bufRaw"}},"qualification":"IO"},{"reference":{"builtinModule":"GHC.ForeignPtr"},"usedName":{"valueName":{"identifier":"unsafeForeignPtrToPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"minusPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Handle.Types"},"usedName":{"valueName":{"identifier":"haBufferMode"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Handle.Types"},"usedName":{"constructorName":{"identifier":"BlockBuffering"},"constructorTypeName":{"identifier":"BufferMode"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO.Handle"},"usedName":{"valueName":{"identifier":"hFlush"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>"}},"qualification":null},{"reference":{"otherSlice":7122040331796438017},"usedName":{"valueName":{"identifier":"hPut"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.IO.Handle.Types"},"usedName":{"typeName":{"identifier":"Handle"}},"qualification":null},{"reference":{"otherSlice":9057008282097227273},"usedName":{"typeName":{"identifier":"Put"}},"qualification":null}],"fragment":["hPut :: forall a . Handle -> Put a -> IO a","hPut h p = do fillHandle 1 (runPut p)\n  where fillHandle :: Int -> BuildStep a -> IO a\n        fillHandle !minFree step\n          = do next <- wantWritableHandle \"hPut\" h fillHandle_\n               next\n          where fillHandle_ :: Handle__ -> IO (IO a)\n                fillHandle_ h_\n                  = do makeSpace =<< readIORef refBuf\n                       fillBuffer =<< readIORef refBuf\n                  where refBuf = haByteBuffer h_\n                        freeSpace buf = IO.bufSize buf - IO.bufR buf\n                        makeSpace buf\n                          | IO.bufSize buf < minFree =\n                            do flushWriteBuffer h_\n                               s <- IO.bufState <$> readIORef refBuf\n                               IO.newByteBuffer minFree s >>= writeIORef refBuf\n                          | freeSpace buf < minFree = flushWriteBuffer h_\n                          | otherwise = return ()\n                        fillBuffer buf\n                          | freeSpace buf < minFree =\n                            error $\n                              unlines\n                                [\"Data.ByteString.Builder.Internal.hPut: internal error.\",\n                                 \"  Not enough space after flush.\",\n                                 \"    required: \" ++ show minFree,\n                                 \"    free: \" ++ show (freeSpace buf)]\n                          | otherwise =\n                            do let !br = BufferRange op (pBuf `plusPtr` IO.bufSize buf)\n                               res <- fillWithBuildStep step doneH fullH insertChunkH br\n                               touchForeignPtr fpBuf\n                               return res\n                          where fpBuf = IO.bufRaw buf\n                                pBuf = unsafeForeignPtrToPtr fpBuf\n                                op = pBuf `plusPtr` IO.bufR buf\n                                \n                                {-# INLINE updateBufR #-}\n                                updateBufR op'\n                                  = do let !off' = op' `minusPtr` pBuf\n                                           !buf' = buf{IO.bufR = off'}\n                                       writeIORef refBuf buf'\n                                doneH op' x\n                                  = do updateBufR op'\n                                       case haBufferMode h_ of\n                                           BlockBuffering _ -> return $ return x\n                                           _line_or_no_buffering -> return $ hFlush h >> return x\n                                fullH op' minSize nextStep\n                                  = do updateBufR op'\n                                       return $ fillHandle minSize nextStep\n                                insertChunkH op' bs nextStep\n                                  = do updateBufR op'\n                                       return $\n                                         do S.hPut h bs\n                                            fillHandle 1 nextStep"],"instances":[],"language":{"extensions":["ScopedTypeVariables","BangPatterns","RankNTypes","Unsafe","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
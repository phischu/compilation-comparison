{"sliceID":1456959894529533239,"uses":[{"reference":{"otherSlice":3205252498693512578},"usedName":{"constructorName":{"identifier":"DecompressParams"},"constructorTypeName":{"identifier":"DecompressParams"}},"qualification":null},{"reference":{"otherSlice":2281697129950829781},"usedName":{"valueName":{"identifier":"inputBufferEmpty"}},"qualification":"Stream"},{"reference":{"otherSlice":2337964900038309551},"usedName":{"valueName":{"identifier":"outputBufferFull"}},"qualification":"Stream"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"assert"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":1769976971367097781},"usedName":{"valueName":{"identifier":"gzipFormat"}},"qualification":"Stream"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"&&"}},"qualification":null},{"reference":{"otherSlice":798279389318286045},"usedName":{"valueName":{"identifier":"inflateReset"}},"qualification":"Stream"},{"reference":{"otherSlice":7588601672080787193},"usedName":{"valueName":{"identifier":"inflateInit"}},"qualification":"Stream"},{"reference":{"otherSlice":7202692338078551997},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"when"}},"qualification":null},{"reference":{"otherSlice":4053808545383669285},"usedName":{"valueName":{"identifier":"unsafeLiftIO"}},"qualification":"Stream"},{"reference":{"otherSlice":4976473949306289482},"usedName":{"valueName":{"identifier":"mallocByteString"}},"qualification":"S"},{"reference":{"otherSlice":4194159638160094001},"usedName":{"valueName":{"identifier":"pushOutputBuffer"}},"qualification":"Stream"},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":4010822550476529195},"usedName":{"constructorName":{"identifier":"PS"},"constructorTypeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"otherSlice":919922670402176205},"usedName":{"valueName":{"identifier":"pushInputBuffer"}},"qualification":"Stream"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"not"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"otherSlice":1394949281745390129},"usedName":{"typeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"otherSlice":7072387134939381410},"usedName":{"typeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"||"}},"qualification":null},{"reference":{"otherSlice":7072387134939381410},"usedName":{"constructorName":{"identifier":"DecompressInputRequired"},"constructorTypeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":8663222698995643969},"usedName":{"valueName":{"identifier":"inflate"}},"qualification":"Stream"},{"reference":{"otherSlice":4135024097093880496},"usedName":{"constructorName":{"identifier":"NoFlush"},"constructorTypeName":{"identifier":"Flush"}},"qualification":"Stream"},{"reference":{"otherSlice":8123682005749207259},"usedName":{"constructorName":{"identifier":"Ok"},"constructorTypeName":{"identifier":"Status"}},"qualification":"Stream"},{"reference":{"otherSlice":3517660788483210230},"usedName":{"valueName":{"identifier":"popOutputBuffer"}},"qualification":"Stream"},{"reference":{"otherSlice":7072387134939381410},"usedName":{"constructorName":{"identifier":"DecompressOutputAvailable"},"constructorTypeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"otherSlice":8172945783513712089},"usedName":{"valueName":{"identifier":"defaultDecompressBufferSize"}},"qualification":null},{"reference":{"otherSlice":8123682005749207259},"usedName":{"constructorName":{"identifier":"StreamEnd"},"constructorTypeName":{"identifier":"Status"}},"qualification":"Stream"},{"reference":{"otherSlice":7072387134939381410},"usedName":{"constructorName":{"identifier":"DecompressStreamEnd"},"constructorTypeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"otherSlice":7459617743278403755},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"S"},{"reference":{"otherSlice":5598030488736048712},"usedName":{"valueName":{"identifier":"popRemainingInputBuffer"}},"qualification":"Stream"},{"reference":{"otherSlice":8123682005749207259},"usedName":{"constructorName":{"identifier":"Error"},"constructorTypeName":{"identifier":"Status"}},"qualification":"Stream"},{"reference":{"otherSlice":5361487995898188190},"usedName":{"constructorName":{"identifier":"BufferError"},"constructorTypeName":{"identifier":"ErrorCode"}},"qualification":"Stream"},{"reference":{"otherSlice":7072387134939381410},"usedName":{"constructorName":{"identifier":"DecompressStreamError"},"constructorTypeName":{"identifier":"DecompressStream"}},"qualification":null},{"reference":{"otherSlice":8830414457797892968},"usedName":{"constructorName":{"identifier":"TruncatedInput"},"constructorTypeName":{"identifier":"DecompressError"}},"qualification":null},{"reference":{"otherSlice":5361487995898188190},"usedName":{"constructorName":{"identifier":"NeedDict"},"constructorTypeName":{"identifier":"ErrorCode"}},"qualification":"Stream"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":5361487995898188190},"usedName":{"constructorName":{"identifier":"DataError"},"constructorTypeName":{"identifier":"ErrorCode"}},"qualification":"Stream"},{"reference":{"otherSlice":8830414457797892968},"usedName":{"constructorName":{"identifier":"DataFormatError"},"constructorTypeName":{"identifier":"DecompressError"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"fail"}},"qualification":null},{"reference":{"otherSlice":5511494881741289570},"usedName":{"valueName":{"identifier":"outputBufferBytesAvailable"}},"qualification":"Stream"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">"}},"qualification":null},{"reference":{"otherSlice":1723298855936855019},"usedName":{"typeName":{"identifier":"DictionaryHash"}},"qualification":"Stream"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":4010822550476529195},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"otherSlice":8830414457797892968},"usedName":{"constructorName":{"identifier":"DictionaryRequired"},"constructorTypeName":{"identifier":"DecompressError"}},"qualification":null},{"reference":{"otherSlice":7201678224810914439},"usedName":{"valueName":{"identifier":"inflateSetDictionary"}},"qualification":"Stream"},{"reference":{"otherSlice":8830414457797892968},"usedName":{"constructorName":{"identifier":"DictionaryMismatch"},"constructorTypeName":{"identifier":"DecompressError"}},"qualification":null},{"reference":{"otherSlice":7315165113918992770},"usedName":{"typeName":{"identifier":"Format"}},"qualification":"Stream"},{"reference":{"otherSlice":3205252498693512578},"usedName":{"typeName":{"identifier":"DecompressParams"}},"qualification":null}],"fragment":["decompressStream ::\n                 Stream.Format ->\n                   DecompressParams ->\n                     Bool -> S.ByteString -> Stream (DecompressStream Stream)","decompressStream format\n  (DecompressParams bits initChunkSize mdict allMembers) resume\n  = \\ chunk ->\n      do inputBufferEmpty <- Stream.inputBufferEmpty\n         outputBufferFull <- Stream.outputBufferFull\n         assert inputBufferEmpty $\n           if resume then\n             assert (format == Stream.gzipFormat && allMembers) $\n               Stream.inflateReset\n             else assert outputBufferFull $ Stream.inflateInit format bits\n         case chunk of\n             _ | S.null chunk ->\n                 do when outputBufferFull $\n                      do let outChunkSize = 1\n                         outFPtr <- Stream.unsafeLiftIO (S.mallocByteString outChunkSize)\n                         Stream.pushOutputBuffer outFPtr 0 outChunkSize\n                    drainBuffers True\n             S.PS inFPtr offset length -> do Stream.pushInputBuffer inFPtr\n                                               offset\n                                               length\n                                             assert (if not resume then outputBufferFull else True)\n                                               $ return ()\n                                             if outputBufferFull then fillBuffers initChunkSize else\n                                               drainBuffers False\n  where fillBuffers :: Int -> Stream (DecompressStream Stream)\n        fillBuffers outChunkSize\n          = do inputBufferEmpty <- Stream.inputBufferEmpty\n               outputBufferFull <- Stream.outputBufferFull\n               assert (inputBufferEmpty || outputBufferFull) $ return ()\n               when outputBufferFull $\n                 do outFPtr <- Stream.unsafeLiftIO (S.mallocByteString outChunkSize)\n                    Stream.pushOutputBuffer outFPtr 0 outChunkSize\n               if inputBufferEmpty then\n                 return $\n                   DecompressInputRequired $\n                     \\ chunk ->\n                       case chunk of\n                           _ | S.null chunk -> drainBuffers True\n                           S.PS inFPtr offset length -> do Stream.pushInputBuffer inFPtr\n                                                             offset\n                                                             length\n                                                           drainBuffers False\n                 else drainBuffers False\n        \n        drainBuffers :: Bool -> Stream (DecompressStream Stream)\n        drainBuffers lastChunk\n          = do inputBufferEmpty' <- Stream.inputBufferEmpty\n               outputBufferFull' <- Stream.outputBufferFull\n               assert\n                 (not outputBufferFull' && (lastChunk || not inputBufferEmpty'))\n                 $ return ()\n               status <- Stream.inflate Stream.NoFlush\n               case status of\n                   Stream.Ok -> do outputBufferFull <- Stream.outputBufferFull\n                                   if outputBufferFull then\n                                     do (outFPtr, offset, length) <- Stream.popOutputBuffer\n                                        let chunk = S.PS outFPtr offset length\n                                        return $\n                                          DecompressOutputAvailable chunk $\n                                            do fillBuffers defaultDecompressBufferSize\n                                     else do fillBuffers defaultDecompressBufferSize\n                   Stream.StreamEnd -> do inputBufferEmpty <- Stream.inputBufferEmpty\n                                          if inputBufferEmpty then\n                                            do finish (DecompressStreamEnd S.empty) else\n                                            do (inFPtr, offset,\n                                                length) <- Stream.popRemainingInputBuffer\n                                               let inchunk = S.PS inFPtr offset length\n                                               finish (DecompressStreamEnd inchunk)\n                   Stream.Error code msg -> case code of\n                                                Stream.BufferError -> finish\n                                                                        (DecompressStreamError\n                                                                           TruncatedInput)\n                                                Stream.NeedDict adler -> do err <- setDictionary\n                                                                                     adler\n                                                                                     mdict\n                                                                            case err of\n                                                                                Just\n                                                                                  streamErr -> finish\n                                                                                                 streamErr\n                                                                                Nothing -> drainBuffers\n                                                                                             lastChunk\n                                                Stream.DataError -> finish\n                                                                      (DecompressStreamError\n                                                                         (DataFormatError msg))\n                                                _ -> fail msg\n        finish end\n          = do outputBufferBytesAvailable <- Stream.outputBufferBytesAvailable\n               if outputBufferBytesAvailable > 0 then\n                 do (outFPtr, offset, length) <- Stream.popOutputBuffer\n                    return\n                      (DecompressOutputAvailable (S.PS outFPtr offset length)\n                         (return end))\n                 else return end\n        \n        setDictionary ::\n                      Stream.DictionaryHash ->\n                        Maybe S.ByteString -> Stream (Maybe (DecompressStream Stream))\n        setDictionary _adler Nothing\n          = return $ Just (DecompressStreamError DictionaryRequired)\n        setDictionary _adler (Just dict)\n          = do status <- Stream.inflateSetDictionary dict\n               case status of\n                   Stream.Ok -> return Nothing\n                   Stream.Error Stream.DataError _ -> return $\n                                                        Just\n                                                          (DecompressStreamError DictionaryMismatch)\n                   _ -> fail \"error when setting inflate dictionary\""],"instances":[],"language":{"extensions":["RankNTypes","DeriveDataTypeable","BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
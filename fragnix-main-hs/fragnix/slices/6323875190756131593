{"sliceID":6323875190756131593,"uses":[{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Functor"}},"qualification":null},{"reference":{"otherSlice":6497888655579684852},"usedName":{"typeName":{"identifier":"SmallArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"fmap"}},"qualification":null},{"reference":{"otherSlice":7806011641631011927},"usedName":{"valueName":{"identifier":"createSmallArray"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"length"}},"qualification":null},{"reference":{"otherSlice":2833989017205590612},"usedName":{"valueName":{"identifier":"die"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"Data.Function"},"usedName":{"valueName":{"identifier":"fix"}},"qualification":null},{"reference":{"otherSlice":9036649515903686607},"usedName":{"valueName":{"operator":"?"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"when"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":6346859743251984807},"usedName":{"valueName":{"identifier":"writeSmallArray"}},"qualification":null},{"reference":{"otherSlice":1051985424738612364},"usedName":{"valueName":{"identifier":"indexSmallArray"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"*>"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"<$"}},"qualification":null},{"reference":{"otherSlice":8484253100598478685},"usedName":{"valueName":{"identifier":"noOp"}},"qualification":null}],"fragment":["instance Functor SmallArray where\n        fmap f sa\n          = createSmallArray (length sa) (die \"fmap\" \"impossible\") $\n              \\ smb ->\n                fix ? 0 $\n                  \\ go i ->\n                    when (i < length sa) $\n                      writeSmallArray smb i (f $ indexSmallArray sa i) *> go (i + 1)\n        \n        {-# INLINE fmap #-}\n        x <$ sa = createSmallArray (length sa) x noOp"],"instances":[],"language":{"extensions":["MagicHash","RankNTypes","TypeFamilies","UnboxedTuples","DeriveTraversable","DeriveDataTypeable","GeneralizedNewtypeDeriving","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":true}}
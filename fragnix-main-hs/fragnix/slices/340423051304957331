{"sliceID":340423051304957331,"uses":[{"reference":{"otherSlice":3219427377843591870},"usedName":{"valueName":{"identifier":"encodeSum"}},"qualification":null},{"reference":{"otherSlice":847687915866770813},"usedName":{"valueName":{"identifier":"toJSON"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"length"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"mapM"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"builtinModule":"GHC.Show"},"usedName":{"valueName":{"identifier":"show"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":2508811511449264432},"usedName":{"valueName":{"identifier":"unsafeNew"}},"qualification":"VM"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"otherSlice":2158331014164558600},"usedName":{"valueName":{"identifier":"unsafeWrite"}},"qualification":"VM"},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"zip"}},"qualification":null},{"reference":{"builtinModule":"GHC.Integer"},"usedName":{"typeName":{"identifier":"Integer"}},"qualification":null},{"reference":{"otherSlice":1669319695546572556},"usedName":{"constructorName":{"identifier":"Array"},"constructorTypeName":{"identifier":"Value"}},"qualification":null},{"reference":{"otherSlice":6212199489683928166},"usedName":{"valueName":{"identifier":"create"}},"qualification":"V"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"otherSlice":2340554657643939838},"usedName":{"valueName":{"identifier":"object"}},"qualification":null},{"reference":{"otherSlice":5961014460351920517},"usedName":{"valueName":{"identifier":"omitNothingFields"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"valueName":{"identifier":"catMaybes"}},"qualification":null},{"reference":{"builtinModule":"Data.List"},"usedName":{"valueName":{"identifier":"partition"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":2092273851542796443},"usedName":{"valueName":{"operator":".="}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"operator":"<$>"}},"qualification":null},{"reference":{"otherSlice":400033489728798890},"usedName":{"valueName":{"identifier":"pack"}},"qualification":"T"},{"reference":{"otherSlice":7803600462155506517},"usedName":{"valueName":{"identifier":"fieldLabelExp"}},"qualification":null},{"reference":{"otherSlice":5961014460351920517},"usedName":{"valueName":{"identifier":"sumEncoding"}},"qualification":null},{"reference":{"otherSlice":5152478156045782397},"usedName":{"constructorName":{"identifier":"TwoElemArray"},"constructorTypeName":{"identifier":"SumEncoding"}},"qualification":null},{"reference":{"otherSlice":8202299163306084124},"usedName":{"valueName":{"identifier":"conStr"}},"qualification":null},{"reference":{"otherSlice":5152478156045782397},"usedName":{"constructorName":{"identifier":"TaggedObject"},"constructorTypeName":{"identifier":"SumEncoding"}},"qualification":null},{"reference":{"otherSlice":5152478156045782397},"usedName":{"valueName":{"identifier":"tagFieldName"}},"qualification":null},{"reference":{"otherSlice":5152478156045782397},"usedName":{"constructorName":{"identifier":"ObjectWithSingleField"},"constructorTypeName":{"identifier":"SumEncoding"}},"qualification":null},{"reference":{"otherSlice":4208832239629921401},"usedName":{"valueName":{"identifier":"conTxt"}},"qualification":null},{"reference":{"otherSlice":5961014460351920517},"usedName":{"typeName":{"identifier":"Options"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null}],"fragment":["encodeArgs :: Options -> Bool -> Con -> Q Match","encodeArgs opts multiCons (NormalC conName [])\n  = match (conP conName [])\n      (normalB\n         (encodeSum opts multiCons conName [| toJSON ([] :: [()]) |]))\n      []\nencodeArgs opts multiCons (NormalC conName ts)\n  = do let len = length ts\n       args <- mapM newName [\"arg\" ++ show n | n <- [1 .. len]]\n       js <- case [[| toJSON |] `appE` varE arg | arg <- args] of\n                 [e] -> return e\n                 es -> do mv <- newName \"mv\"\n                          let newMV\n                                = bindS (varP mv)\n                                    ([| VM.unsafeNew |] `appE` litE (integerL $ fromIntegral len))\n                              stmts\n                                = [noBindS $\n                                     [| VM.unsafeWrite |] `appE` (varE mv) `appE` litE (integerL ix)\n                                       `appE` e\n                                   | (ix, e) <- zip [(0 :: Integer) ..] es]\n                              ret = noBindS $ [| return |] `appE` varE mv\n                          return $\n                            [| Array |] `appE`\n                              (varE 'V.create `appE` doE (newMV : stmts ++ [ret]))\n       match (conP conName $ map varP args)\n         (normalB $ encodeSum opts multiCons conName js)\n         []\nencodeArgs opts multiCons (RecC conName ts)\n  = do args <- mapM newName\n                 [\"arg\" ++ show n | (_, n) <- zip ts [1 :: Integer ..]]\n       let exp = [| object |] `appE` pairs\n           pairs\n             | omitNothingFields opts =\n               infixApp maybeFields [| (++) |] restFields\n             | otherwise = listE $ map toPair argCons\n           argCons = zip args ts\n           maybeFields = [| catMaybes |] `appE` listE (map maybeToPair maybes)\n           restFields = listE $ map toPair rest\n           (maybes, rest) = partition isMaybe argCons\n           isMaybe (_, (_, _, AppT (ConT t) _)) = t == ''Maybe\n           isMaybe _ = False\n           maybeToPair (arg, (field, _, _))\n             = infixApp (infixE (Just $ toFieldName field) [| (.=) |] Nothing)\n                 [| (<$>) |]\n                 (varE arg)\n           toPair (arg, (field, _, _))\n             = infixApp (toFieldName field) [| (.=) |] (varE arg)\n           toFieldName field = [| T.pack |] `appE` fieldLabelExp opts field\n       match (conP conName $ map varP args)\n         (normalB $\n            if multiCons then\n              case sumEncoding opts of\n                  TwoElemArray -> [| toJSON |] `appE` tupE [conStr opts conName, exp]\n                  TaggedObject{tagFieldName} -> [| object |] `appE`\n                                                  infixApp\n                                                    (infixApp [| T.pack tagFieldName |] [| (.=) |]\n                                                       (conStr opts conName))\n                                                    [| (:) |]\n                                                    pairs\n                  ObjectWithSingleField -> [| object |] `appE`\n                                             listE [infixApp (conTxt opts conName) [| (.=) |] exp]\n              else exp)\n         []\nencodeArgs opts multiCons (InfixC _ conName _)\n  = do al <- newName \"argL\"\n       ar <- newName \"argR\"\n       match (infixP (varP al) conName (varP ar))\n         (normalB $\n            encodeSum opts multiCons conName $\n              [| toJSON |] `appE`\n                listE [[| toJSON |] `appE` varE a | a <- [al, ar]])\n         []\nencodeArgs opts multiCons (ForallC _ _ con)\n  = encodeArgs opts multiCons con"],"instances":[],"language":{"extensions":["FlexibleInstances","IncoherentInstances","NamedFieldPuns","NoImplicitPrelude","OverlappingInstances","TemplateHaskell","UndecidableInstances","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
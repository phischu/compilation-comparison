{"sliceID":8274398417728000959,"uses":[{"reference":{"otherSlice":4132404936174356097},"usedName":{"constructorName":{"identifier":"Stream"},"constructorTypeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"otherSlice":2430856326972046314},"usedName":{"valueName":{"identifier":"isEmpty"}},"qualification":null},{"reference":{"otherSlice":600428831856449117},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"I"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":4069519914147446271},"usedName":{"valueName":{"identifier":"text"}},"qualification":"I"},{"reference":{"otherSlice":371753114757304304},"usedName":{"valueName":{"identifier":"upperBound"}},"qualification":null},{"reference":{"otherSlice":5011483905817787380},"usedName":{"valueName":{"identifier":"larger"}},"qualification":null},{"reference":{"otherSlice":5281522789970953128},"usedName":{"valueName":{"identifier":"run2"}},"qualification":"A"},{"reference":{"otherSlice":303218261714130477},"usedName":{"valueName":{"identifier":"new"}},"qualification":"A"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"otherSlice":2339004113504757537},"usedName":{"constructorName":{"identifier":"Done"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":2339004113504757537},"usedName":{"constructorName":{"identifier":"Skip"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"otherSlice":2339004113504757537},"usedName":{"constructorName":{"identifier":"Yield"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":4463961207685254290},"usedName":{"valueName":{"identifier":"shiftL"}},"qualification":null},{"reference":{"otherSlice":7984510095534010158},"usedName":{"valueName":{"identifier":"copyM"}},"qualification":"A"},{"reference":{"otherSlice":1071295638341592846},"usedName":{"valueName":{"identifier":"ord"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":4463961207685254290},"usedName":{"valueName":{"identifier":"shiftR"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"operator":".&."}},"qualification":null},{"reference":{"otherSlice":2150232250643188057},"usedName":{"valueName":{"identifier":"unsafeWrite"}},"qualification":"A"},{"reference":{"otherSlice":4132404936174356097},"usedName":{"typeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Char"}},"qualification":null},{"reference":{"otherSlice":6742866475076404776},"usedName":{"typeName":{"identifier":"Text"}},"qualification":null}],"fragment":["reverse :: Stream Char -> Text","reverse (Stream next s len0)\n  | isEmpty len0 = I.empty\n  | otherwise = I.text arr off' len'\n  where len0' = upperBound 4 (larger len0 4)\n        (arr, (off', len'))\n          = A.run2 (A.new len0' >>= loop s (len0' - 1) len0')\n        loop !s0 !i !len marr\n          = case next s0 of\n                Done -> return (marr, (j, len - j))\n                  where j = i + 1\n                Skip s1 -> loop s1 i len marr\n                Yield x s1 | i < least ->\n                             {-# SCC \"reverse/resize\" #-}\n                               do let newLen = len `shiftL` 1\n                                  marr' <- A.new newLen\n                                  A.copyM marr' (newLen - len) marr 0 len\n                                  write s1 (len + i) newLen marr'\n                           | otherwise -> write s1 i len marr\n                  where n = ord x\n                        least\n                          | n < 65536 = 0\n                          | otherwise = 1\n                        m = n - 65536\n                        lo = fromIntegral $ (m `shiftR` 10) + 55296\n                        hi = fromIntegral $ (m .&. 1023) + 56320\n                        write t j l mar\n                          | n < 65536 =\n                            do A.unsafeWrite mar j (fromIntegral n)\n                               loop t (j - 1) l mar\n                          | otherwise =\n                            do A.unsafeWrite mar (j - 1) lo\n                               A.unsafeWrite mar j hi\n                               loop t (j - 2) l mar"],"instances":[],"language":{"extensions":["BangPatterns","MagicHash","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
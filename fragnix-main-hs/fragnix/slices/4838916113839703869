{"sliceID":4838916113839703869,"uses":[{"reference":{"otherSlice":7341538116301593995},"usedName":{"constructorName":{"identifier":"WhenMissing"},"constructorTypeName":{"identifier":"WhenMissing"}},"qualification":null},{"reference":{"otherSlice":7341538116301593995},"usedName":{"valueName":{"identifier":"missingSubtree"}},"qualification":null},{"reference":{"otherSlice":7341538116301593995},"usedName":{"valueName":{"identifier":"missingKey"}},"qualification":null},{"reference":{"otherSlice":3779212341974530911},"usedName":{"constructorName":{"identifier":"WhenMatched"},"constructorTypeName":{"identifier":"WhenMatched"}},"qualification":null},{"reference":{"otherSlice":3779212341974530911},"usedName":{"valueName":{"identifier":"matchedKey"}},"qualification":null},{"reference":{"otherSlice":13410505313944458},"usedName":{"constructorName":{"identifier":"Nil"},"constructorTypeName":{"identifier":"IntMap"}},"qualification":null},{"reference":{"otherSlice":13410505313944458},"usedName":{"constructorName":{"identifier":"Tip"},"constructorTypeName":{"identifier":"IntMap"}},"qualification":null},{"reference":{"otherSlice":13410505313944458},"usedName":{"constructorName":{"identifier":"Bin"},"constructorTypeName":{"identifier":"IntMap"}},"qualification":null},{"reference":{"otherSlice":2715173166319551379},"usedName":{"valueName":{"identifier":"nomatch"}},"qualification":null},{"reference":{"otherSlice":4717645055143425729},"usedName":{"valueName":{"identifier":"zero"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"liftA2"}},"qualification":null},{"reference":{"otherSlice":5872821015204751437},"usedName":{"valueName":{"identifier":"bin"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":5445665798090920829},"usedName":{"valueName":{"identifier":"shorter"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"valueName":{"identifier":"maybe"}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"operator":"<$>"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":3388317860341888410},"usedName":{"valueName":{"identifier":"link"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Applicative"}},"qualification":null},{"reference":{"otherSlice":6191317532360100524},"usedName":{"typeName":{"identifier":"Prefix"}},"qualification":null},{"reference":{"otherSlice":13410505313944458},"usedName":{"typeName":{"identifier":"IntMap"}},"qualification":null},{"reference":{"otherSlice":5746297709281868947},"usedName":{"valueName":{"identifier":"branchMask"}},"qualification":null},{"reference":{"otherSlice":9137921527376321367},"usedName":{"valueName":{"identifier":"mask"}},"qualification":null},{"reference":{"otherSlice":7341538116301593995},"usedName":{"typeName":{"identifier":"WhenMissing"}},"qualification":null},{"reference":{"otherSlice":3779212341974530911},"usedName":{"typeName":{"identifier":"WhenMatched"}},"qualification":null}],"fragment":["mergeA ::\n         (Applicative f) =>\n         WhenMissing f a c ->\n           WhenMissing f b c ->\n             WhenMatched f a b c -> IntMap a -> IntMap b -> f (IntMap c)","mergeA WhenMissing{missingSubtree = g1t, missingKey = g1k}\n  WhenMissing{missingSubtree = g2t, missingKey = g2k}\n  WhenMatched{matchedKey = f} = go\n  where go t1 Nil = g1t t1\n        go Nil t2 = g2t t2\n        go (Tip k1 x1) t2' = merge2 t2'\n          where merge2 t2@(Bin p2 m2 l2 r2)\n                  | nomatch k1 p2 m2 =\n                    linkA k1 (subsingletonBy g1k k1 x1) p2 (g2t t2)\n                  | zero k1 m2 = liftA2 (bin p2 m2) (merge2 l2) (g2t r2)\n                  | otherwise = liftA2 (bin p2 m2) (g2t l2) (merge2 r2)\n                merge2 (Tip k2 x2) = mergeTips k1 x1 k2 x2\n                merge2 Nil = subsingletonBy g1k k1 x1\n        go t1' (Tip k2 x2) = merge1 t1'\n          where merge1 t1@(Bin p1 m1 l1 r1)\n                  | nomatch k2 p1 m1 =\n                    linkA p1 (g1t t1) k2 (subsingletonBy g2k k2 x2)\n                  | zero k2 m1 = liftA2 (bin p1 m1) (merge1 l1) (g1t r1)\n                  | otherwise = liftA2 (bin p1 m1) (g1t l1) (merge1 r1)\n                merge1 (Tip k1 x1) = mergeTips k1 x1 k2 x2\n                merge1 Nil = subsingletonBy g2k k2 x2\n        go t1@(Bin p1 m1 l1 r1) t2@(Bin p2 m2 l2 r2)\n          | shorter m1 m2 = merge1\n          | shorter m2 m1 = merge2\n          | p1 == p2 = liftA2 (bin p1 m1) (go l1 l2) (go r1 r2)\n          | otherwise = liftA2 (link_ p1 p2) (g1t t1) (g2t t2)\n          where merge1\n                  | nomatch p2 p1 m1 = liftA2 (link_ p1 p2) (g1t t1) (g2t t2)\n                  | zero p2 m1 = liftA2 (bin p1 m1) (go l1 t2) (g1t r1)\n                  | otherwise = liftA2 (bin p1 m1) (g1t l1) (go r1 t2)\n                merge2\n                  | nomatch p1 p2 m2 = liftA2 (link_ p1 p2) (g1t t1) (g2t t2)\n                  | zero p1 m2 = liftA2 (bin p2 m2) (go t1 l2) (g2t r2)\n                  | otherwise = liftA2 (bin p2 m2) (g2t l2) (go t1 r2)\n        subsingletonBy gk k x = maybe Nil (Tip k) <$> gk k x\n        \n        {-# INLINE subsingletonBy #-}\n        mergeTips k1 x1 k2 x2\n          | k1 == k2 = maybe Nil (Tip k1) <$> f k1 x1 x2\n          | k1 < k2 = liftA2 (subdoubleton k1 k2) (g1k k1 x1) (g2k k2 x2)\n          | otherwise = liftA2 (subdoubleton k2 k1) (g2k k2 x2) (g1k k1 x1)\n        \n        {-# INLINE mergeTips #-}\n        subdoubleton _ _ Nothing Nothing = Nil\n        subdoubleton _ k2 Nothing (Just y2) = Tip k2 y2\n        subdoubleton k1 _ (Just y1) Nothing = Tip k1 y1\n        subdoubleton k1 k2 (Just y1) (Just y2)\n          = link k1 (Tip k1 y1) k2 (Tip k2 y2)\n        \n        {-# INLINE subdoubleton #-}\n        link_ _ _ Nil t2 = t2\n        link_ _ _ t1 Nil = t1\n        link_ p1 p2 t1 t2 = link p1 t1 p2 t2\n        \n        {-# INLINE link_ #-}\n        \n        linkA ::\n                Applicative f =>\n                Prefix -> f (IntMap a) -> Prefix -> f (IntMap a) -> f (IntMap a)\n        linkA p1 t1 p2 t2\n          | zero p1 m = liftA2 (bin p m) t1 t2\n          | otherwise = liftA2 (bin p m) t2 t1\n          where m = branchMask p1 p2\n                p = mask p1 m\n        \n        {-# INLINE linkA #-}"],"instances":[],"language":{"extensions":["BangPatterns","MagicHash","DeriveDataTypeable","StandaloneDeriving","ScopedTypeVariables","TypeFamilies","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
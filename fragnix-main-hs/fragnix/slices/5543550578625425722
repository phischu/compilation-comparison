{"sliceID":5543550578625425722,"uses":[{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"operator":"<$>"}},"qualification":null},{"reference":{"builtinModule":"Text.ParserCombinators.ReadP"},"usedName":{"valueName":{"identifier":"satisfy"}},"qualification":"ReadP"},{"reference":{"otherSlice":2869777375537636568},"usedName":{"valueName":{"identifier":"isSign"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"mplus"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"typeName":{"identifier":"Num"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"otherSlice":226649450698237307},"usedName":{"valueName":{"identifier":"foldDigits"}},"qualification":null},{"reference":{"otherSlice":4121652562195203886},"usedName":{"constructorName":{"identifier":"SP"},"constructorTypeName":{"identifier":"SP"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>"}},"qualification":null},{"reference":{"builtinModule":"Text.ParserCombinators.ReadP"},"usedName":{"valueName":{"operator":"<++"}},"qualification":"ReadP"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":1605215636363122086},"usedName":{"valueName":{"identifier":"isE"}},"qualification":null},{"reference":{"otherSlice":2794777964408613631},"usedName":{"valueName":{"identifier":"scientific"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"Text.ParserCombinators.ReadP"},"usedName":{"typeName":{"identifier":"ReadP"}},"qualification":null},{"reference":{"otherSlice":655943511058533134},"usedName":{"typeName":{"identifier":"Scientific"}},"qualification":null}],"fragment":["scientificP :: ReadP Scientific","scientificP\n  = do let positive\n             = (('+' ==) <$> ReadP.satisfy isSign) `mplus` return True\n       pos <- positive\n       let step :: Num a => a -> Int -> a\n           step a digit = a * 10 + fromIntegral digit\n           {-# INLINE step #-}\n       n <- foldDigits step 0\n       let s = SP n 0\n           fractional\n             = foldDigits (\\ (SP a e) digit -> SP (step a digit) (e - 1)) s\n       SP coeff expnt <- (ReadP.satisfy (== '.') >> fractional) ReadP.<++\n                           return s\n       let signedCoeff\n             | pos = coeff\n             | otherwise = (-coeff)\n           eP\n             = do posE <- positive\n                  e <- foldDigits step 0\n                  if posE then return e else return (-e)\n       (ReadP.satisfy isE >>\n          ((scientific signedCoeff . (expnt +)) <$> eP))\n         `mplus` return (scientific signedCoeff expnt)"],"instances":[],"language":{"extensions":["DeriveDataTypeable","BangPatterns","ScopedTypeVariables","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
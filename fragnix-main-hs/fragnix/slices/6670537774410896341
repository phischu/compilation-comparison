{"sliceID":6670537774410896341,"uses":[{"reference":{"otherSlice":7202692338078551997},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"otherSlice":7235567377809295464},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":5746284862407516300},"usedName":{"valueName":{"identifier":"head"}},"qualification":"S"},{"reference":{"otherSlice":4464784005131150161},"usedName":{"valueName":{"identifier":"elemIndices"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Word"},"usedName":{"typeName":{"identifier":"Word8"}},"qualification":null},{"reference":{"otherSlice":7493882458078027726},"usedName":{"valueName":{"identifier":"unsafeIndex"}},"qualification":null},{"reference":{"builtinModule":"GHC.Enum"},"usedName":{"valueName":{"identifier":"maxBound"}},"qualification":null},{"reference":{"otherSlice":4368397506866556061},"usedName":{"valueName":{"identifier":"occurs"}},"qualification":null},{"reference":{"otherSlice":696973203919167932},"usedName":{"valueName":{"identifier":"suffShifts"}},"qualification":null},{"reference":{"otherSlice":3191844957948247487},"usedName":{"valueName":{"identifier":"unsafeAt"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"error"}},"qualification":null},{"reference":{"builtinModule":"GHC.Int"},"usedName":{"typeName":{"identifier":"Int64"}},"qualification":null},{"reference":{"otherSlice":4010822550476529195},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"otherSlice":6988357746781263708},"usedName":{"valueName":{"identifier":"release"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"max"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null}],"fragment":["lazySearcher :: Bool -> S.ByteString -> [S.ByteString] -> [Int64]","lazySearcher _ !pat\n  | S.null pat =\n    let zgo !prior [] = [prior]\n        zgo prior (!(str : rest))\n          = let !l = S.length str\n                !prior' = prior + fromIntegral l\n              in [prior + fromIntegral i | i <- [0 .. l - 1]] ++ zgo prior' rest\n      in zgo 0\n  | S.length pat == 1 =\n    let !w = S.head pat\n        ixes = S.elemIndices w\n        go _ [] = []\n        go !prior (!(str : rest))\n          = let !prior' = prior + fromIntegral (S.length str) in\n              map ((+ prior) . fromIntegral) (ixes str) ++ go prior' rest\n      in go 0\nlazySearcher !overlap pat = searcher\n  where {-# INLINE patAt #-}\n        \n        patAt :: Int -> Word8\n        patAt !i = unsafeIndex pat i\n        !patLen = S.length pat\n        !patEnd = patLen - 1\n        \n        {-# INLINE preEnd #-}\n        preEnd = patEnd - 1\n        !maxLen = maxBound - patLen\n        !occT = occurs pat\n        !suffT = suffShifts pat\n        !skip = if overlap then unsafeAt suffT 0 else patLen\n        !kept = patLen - skip\n        !pe = patAt patEnd\n        \n        {-# INLINE occ #-}\n        occ !w = unsafeAt occT (fromIntegral w)\n        \n        {-# INLINE suff #-}\n        suff !i = unsafeAt suffT i\n        searcher lst\n          = case lst of\n                [] -> []\n                (h : t) -> if maxLen < S.length h then\n                             error \"Overflow in BoyerMoore.lazySearcher\" else\n                             seek 0 [] h t 0 patEnd\n        \n        seek ::\n             Int64 ->\n               [S.ByteString] ->\n                 S.ByteString -> [S.ByteString] -> Int -> Int -> [Int64]\n        seek !prior !past !str future !diffPos !patPos\n          | strPos < 0 =\n            case past of\n                (h : t) -> let !hLen = S.length h in\n                             seek (prior - fromIntegral hLen) t h (str : future)\n                               (diffPos + hLen)\n                               patPos\n                [] -> error \"seek back too far!\"\n          | strEnd < strPos =\n            case future of\n                (h : t) -> let {-# INLINE prior' #-}\n                               prior' = prior + fromIntegral strLen\n                               !diffPos' = diffPos - strLen\n                               \n                               {-# INLINE past' #-}\n                               past' = release (-diffPos') (str : past)\n                             in\n                             if maxLen < S.length h then\n                               error \"Overflow in BoyerMoore.lazySearcher\" else\n                               seek prior' past' h t diffPos' patPos\n                [] -> []\n          | patPos == patEnd = checkEnd strPos\n          | diffPos < 0 = matcherN diffPos patPos\n          | otherwise = matcherP diffPos patPos\n          where !strPos = diffPos + patPos\n                !strLen = S.length str\n                !strEnd = strLen - 1\n                !maxDiff = strLen - patLen\n                \n                {-# INLINE strAt #-}\n                strAt !i = unsafeIndex str i\n                checkEnd !sI\n                  | strEnd < sI = seek prior past str future (sI - patEnd) patEnd\n                  | otherwise =\n                    case strAt sI of\n                        !c | c == pe ->\n                             if sI < patEnd then\n                               case sI of\n                                   0 -> seek prior past str future (-patEnd) preEnd\n                                   _ -> matcherN (sI - patEnd) preEnd\n                               else matcherP (sI - patEnd) preEnd\n                           | otherwise -> checkEnd (sI + patEnd + occ c)\n                matcherN !diff !patI\n                  = case strAt (diff + patI) of\n                        !c | c == patAt patI ->\n                             if diff + patI == 0 then seek prior past str future diff (patI - 1)\n                               else matcherN diff (patI - 1)\n                           | otherwise ->\n                             let {-# INLINE badShift #-}\n                                 badShift = patI + occ c\n                                 \n                                 {-# INLINE goodShift #-}\n                                 goodShift = suff patI\n                                 !diff' = diff + max badShift goodShift\n                               in\n                               if maxDiff < diff' then seek prior past str future diff' patEnd\n                                 else checkEnd (diff' + patEnd)\n                matcherP !diff !patI\n                  = case strAt (diff + patI) of\n                        !c | c == patAt patI ->\n                             if patI == 0 then\n                               prior + fromIntegral diff :\n                                 let !diff' = diff + skip in\n                                   if maxDiff < diff' then seek prior past str future diff' patEnd\n                                     else\n                                     if skip == patLen then checkEnd (diff' + patEnd) else\n                                       afterMatch diff' patEnd\n                               else matcherP diff (patI - 1)\n                           | otherwise ->\n                             let {-# INLINE badShift #-}\n                                 badShift = patI + occ c\n                                 \n                                 {-# INLINE goodShift #-}\n                                 goodShift = suff patI\n                                 !diff' = diff + max badShift goodShift\n                               in\n                               if maxDiff < diff' then seek prior past str future diff' patEnd\n                                 else checkEnd (diff' + patEnd)\n                afterMatch !diff !patI\n                  = case strAt (diff + patI) of\n                        !c | c == patAt patI ->\n                             if patI == kept then\n                               prior + fromIntegral diff :\n                                 let !diff' = diff + skip in\n                                   if maxDiff < diff' then seek prior past str future diff' patEnd\n                                     else afterMatch diff' patEnd\n                               else afterMatch diff (patI - 1)\n                           | patI == patEnd -> checkEnd (diff + (2 * patEnd) + occ c)\n                           | otherwise ->\n                             let {-# INLINE badShift #-}\n                                 badShift = patI + occ c\n                                 \n                                 {-# INLINE goodShift #-}\n                                 goodShift = suff patI\n                                 !diff' = diff + max badShift goodShift\n                               in\n                               if maxDiff < diff' then seek prior past str future diff' patEnd\n                                 else checkEnd (diff' + patEnd)"],"instances":[],"language":{"extensions":["BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
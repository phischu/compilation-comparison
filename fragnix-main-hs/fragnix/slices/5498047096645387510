{"sliceID":5498047096645387510,"uses":[{"reference":{"builtinModule":"Text.ParserCombinators.ReadP"},"usedName":{"valueName":{"identifier":"readP_to_S"}},"qualification":null},{"reference":{"builtinModule":"Data.Data"},"usedName":{"typeName":{"identifier":"Data"}},"qualification":null},{"reference":{"builtinModule":"Text.ParserCombinators.ReadP"},"usedName":{"typeName":{"identifier":"ReadP"}},"qualification":null},{"reference":{"otherSlice":8736499836352441669},"usedName":{"valueName":{"identifier":"extR"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"String"}},"qualification":null},{"reference":{"builtinModule":"Text.ParserCombinators.ReadP"},"usedName":{"valueName":{"identifier":"readS_to_P"}},"qualification":null},{"reference":{"builtinModule":"Text.Read"},"usedName":{"valueName":{"identifier":"reads"}},"qualification":null},{"reference":{"builtinModule":"Data.Data"},"usedName":{"valueName":{"identifier":"dataTypeOf"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"undefined"}},"qualification":null},{"reference":{"builtinModule":"Text.ParserCombinators.ReadP"},"usedName":{"valueName":{"identifier":"skipSpaces"}},"qualification":null},{"reference":{"builtinModule":"Text.ParserCombinators.ReadP"},"usedName":{"valueName":{"identifier":"char"}},"qualification":null},{"reference":{"builtinModule":"Data.Data"},"usedName":{"valueName":{"identifier":"fromConstrM"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"Data.Data"},"usedName":{"typeName":{"identifier":"Constr"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"valueName":{"identifier":"maybe"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"mzero"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"Data.Data"},"usedName":{"valueName":{"identifier":"readConstr"}},"qualification":null},{"reference":{"builtinModule":"Text.ParserCombinators.ReadP"},"usedName":{"valueName":{"identifier":"string"}},"qualification":null},{"reference":{"builtinModule":"Text.ParserCombinators.ReadP"},"usedName":{"valueName":{"operator":"<++"}},"qualification":null},{"reference":{"builtinModule":"GHC.Read"},"usedName":{"valueName":{"identifier":"lex"}},"qualification":null},{"reference":{"builtinModule":"Text.ParserCombinators.ReadP"},"usedName":{"valueName":{"identifier":"munch1"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"not"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"builtinModule":"Text.ParserCombinators.ReadP"},"usedName":{"typeName":{"identifier":"ReadS"}},"qualification":null}],"fragment":["gread :: Data a => ReadS a","gread = readP_to_S gread'\n  where gread' :: Data a' => ReadP a'\n        gread' = allButString `extR` stringCase\n          where stringCase :: ReadP String\n                stringCase = readS_to_P reads\n                myDataType = dataTypeOf (getArg allButString)\n                  where getArg :: ReadP a'' -> a''\n                        getArg = undefined\n                allButString\n                  = do skipSpaces\n                       _ <- char '('\n                       skipSpaces\n                       str <- parseConstr\n                       con <- str2con str\n                       x <- fromConstrM gread' con\n                       skipSpaces\n                       _ <- char ')'\n                       skipSpaces\n                       return x\n                \n                str2con :: String -> ReadP Constr\n                str2con = maybe mzero return . readConstr myDataType\n                \n                parseConstr :: ReadP String\n                parseConstr\n                  = string \"[]\" <++ string \"()\" <++ infixOp <++ readS_to_P lex\n                \n                infixOp :: ReadP String\n                infixOp\n                  = do c1 <- char '('\n                       str <- munch1 (not . (==) ')')\n                       c2 <- char ')'\n                       return $ [c1] ++ str ++ [c2]"],"instances":[],"language":{"extensions":["MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
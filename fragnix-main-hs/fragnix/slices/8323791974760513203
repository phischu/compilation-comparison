{"sliceID":8323791974760513203,"uses":[{"reference":{"otherSlice":6766449275992946084},"usedName":{"constructorName":{"identifier":"Builder"},"constructorTypeName":{"identifier":"Builder"}},"qualification":null},{"reference":{"otherSlice":4640371534066560564},"usedName":{"valueName":{"identifier":"inlinePerformIO"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":2931540031717686030},"usedName":{"valueName":{"identifier":"buildStep"}},"qualification":null},{"reference":{"otherSlice":2921932848836490295},"usedName":{"constructorName":{"identifier":"BufRange"},"constructorTypeName":{"identifier":"BufRange"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":3030113937244366044},"usedName":{"constructorName":{"identifier":"Done"},"constructorTypeName":{"identifier":"BuildSignal"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":8772400319191501505},"usedName":{"valueName":{"identifier":"mallocByteString"}},"qualification":"S"},{"reference":{"builtinModule":"Foreign.ForeignPtr"},"usedName":{"valueName":{"identifier":"withForeignPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"plusPtr"}},"qualification":null},{"reference":{"otherSlice":8642306666063513779},"usedName":{"constructorName":{"identifier":"PS"},"constructorTypeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"minusPtr"}},"qualification":null},{"reference":{"otherSlice":3030113937244366044},"usedName":{"valueName":{"identifier":"runBuildStep"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":1699226608098321587},"usedName":{"constructorName":{"identifier":"Chunk"},"constructorTypeName":{"identifier":"ByteString"}},"qualification":"L"},{"reference":{"otherSlice":3030113937244366044},"usedName":{"constructorName":{"identifier":"BufferFull"},"constructorTypeName":{"identifier":"BuildSignal"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"max"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Marshal.Utils"},"usedName":{"valueName":{"identifier":"copyBytes"}},"qualification":null},{"reference":{"otherSlice":3030113937244366044},"usedName":{"constructorName":{"identifier":"InsertByteString"},"constructorTypeName":{"identifier":"BuildSignal"}},"qualification":null},{"reference":{"otherSlice":6711383198936054718},"usedName":{"valueName":{"identifier":"nonEmptyChunk"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"otherSlice":6766449275992946084},"usedName":{"typeName":{"identifier":"Builder"}},"qualification":null},{"reference":{"otherSlice":1699226608098321587},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"L"}],"fragment":["toLazyByteStringWith ::\n                     Int -> Int -> Int -> Builder -> L.ByteString -> L.ByteString","toLazyByteStringWith bufSize minBufSize firstBufSize (Builder b) k\n  = S.inlinePerformIO $ fillFirstBuffer (b (buildStep finalStep))\n  where finalStep (BufRange pf _) = return $ Done pf ()\n        fillFirstBuffer !step0\n          | minBufSize <= firstBufSize = fillNewBuffer firstBufSize step0\n          | otherwise =\n            do fpbuf <- S.mallocByteString firstBufSize\n               withForeignPtr fpbuf $\n                 \\ pf ->\n                   do let !pe = pf `plusPtr` firstBufSize\n                          mkbs pf' = S.PS fpbuf 0 (pf' `minusPtr` pf)\n                          {-# INLINE mkbs #-}\n                      next <- runBuildStep step0 (BufRange pf pe)\n                      case next of\n                          Done pf' _ | pf' == pf -> return k\n                                     | otherwise -> return $ L.Chunk (mkbs pf') k\n                          BufferFull newSize pf' nextStep -> do let !l = pf' `minusPtr` pf\n                                                                fillNewBuffer\n                                                                  (max (l + newSize) minBufSize)\n                                                                  $\n                                                                  buildStep $\n                                                                    \\ (BufRange pfNew peNew) ->\n                                                                      do copyBytes pfNew pf l\n                                                                         let !br'\n                                                                               = BufRange\n                                                                                   (pfNew `plusPtr`\n                                                                                      l)\n                                                                                   peNew\n                                                                         runBuildStep nextStep br'\n                          InsertByteString pf' bs nextStep | pf' == pf ->\n                                                             return $\n                                                               nonEmptyChunk bs\n                                                                 (S.inlinePerformIO $\n                                                                    fillNewBuffer bufSize nextStep)\n                                                           | otherwise ->\n                                                             return $\n                                                               L.Chunk (mkbs pf')\n                                                                 (nonEmptyChunk bs\n                                                                    (S.inlinePerformIO $\n                                                                       fillNewBuffer bufSize\n                                                                         nextStep))\n        fillNewBuffer !size !step0\n          = do fpbuf <- S.mallocByteString size\n               withForeignPtr fpbuf $ fillBuffer fpbuf\n          where fillBuffer fpbuf !pbuf = fill pbuf step0\n                  where !pe = pbuf `plusPtr` size\n                        fill !pf !step\n                          = do next <- runBuildStep step (BufRange pf pe)\n                               let mkbs pf' = S.PS fpbuf (pf `minusPtr` pbuf) (pf' `minusPtr` pf)\n                                   {-# INLINE mkbs #-}\n                               case next of\n                                   Done pf' _ | pf' == pf -> return k\n                                              | otherwise -> return $ L.Chunk (mkbs pf') k\n                                   BufferFull newSize pf' nextStep | pf' == pf ->\n                                                                     fillNewBuffer\n                                                                       (max newSize bufSize)\n                                                                       nextStep\n                                                                   | otherwise ->\n                                                                     return $\n                                                                       L.Chunk (mkbs pf')\n                                                                         (S.inlinePerformIO $\n                                                                            fillNewBuffer\n                                                                              (max newSize bufSize)\n                                                                              nextStep)\n                                   InsertByteString pf' bs nextStep | pf' == pf ->\n                                                                      return $\n                                                                        nonEmptyChunk bs\n                                                                          (S.inlinePerformIO $\n                                                                             fill pf' nextStep)\n                                                                    | minBufSize < pe `minusPtr` pf'\n                                                                      ->\n                                                                      return $\n                                                                        L.Chunk (mkbs pf')\n                                                                          (nonEmptyChunk bs\n                                                                             (S.inlinePerformIO $\n                                                                                fill pf' nextStep))\n                                                                    | otherwise ->\n                                                                      return $\n                                                                        L.Chunk (mkbs pf')\n                                                                          (nonEmptyChunk bs\n                                                                             (S.inlinePerformIO $\n                                                                                fillNewBuffer\n                                                                                  bufSize\n                                                                                  nextStep))"],"instances":[],"language":{"extensions":["BangPatterns","Rank2Types","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
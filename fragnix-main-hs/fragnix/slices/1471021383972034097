{"sliceID":1471021383972034097,"uses":[{"reference":{"otherSlice":9209112058599157037},"usedName":{"constructorName":{"identifier":"Stream"},"constructorTypeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Left"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":3501924119519436030},"usedName":{"constructorName":{"identifier":"Unknown"},"constructorTypeName":{"identifier":"Size"}},"qualification":null},{"reference":{"otherSlice":6240008831363963322},"usedName":{"constructorName":{"identifier":"Yield"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":6240008831363963322},"usedName":{"constructorName":{"identifier":"Skip"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Right"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":6240008831363963322},"usedName":{"constructorName":{"identifier":"Done"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Monad"}},"qualification":null},{"reference":{"otherSlice":9209112058599157037},"usedName":{"typeName":{"identifier":"Stream"}},"qualification":null}],"fragment":["concatMapM ::\n             Monad m => (a -> m (Stream m b)) -> Stream m a -> Stream m b","concatMapM f (Stream step s _)\n  = Stream concatMap_go (Left s) Unknown\n  where concatMap_go (Left s)\n          = do r <- step s\n               case r of\n                   Yield a s' -> do b_stream <- f a\n                                    return $ Skip (Right (b_stream, s'))\n                   Skip s' -> return $ Skip (Left s')\n                   Done -> return Done\n        concatMap_go (Right (Stream inner_step inner_s sz, s))\n          = do r <- inner_step inner_s\n               case r of\n                   Yield b inner_s' -> return $\n                                         Yield b (Right (Stream inner_step inner_s' sz, s))\n                   Skip inner_s' -> return $\n                                      Skip (Right (Stream inner_step inner_s' sz, s))\n                   Done -> return $ Skip (Left s)"],"instances":[],"language":{"extensions":["DeriveDataTypeable","ExistentialQuantification","Rank2Types","BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
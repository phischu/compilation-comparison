{"sliceID":5806818494902199580,"uses":[{"reference":{"otherSlice":2861716045928540937},"usedName":{"valueName":{"identifier":"c_regexec"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":5401391956019432590},"usedName":{"valueName":{"identifier":"retOk"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"mapM"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"take"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"iterate"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"plusPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Right"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":1438571287307028125},"usedName":{"valueName":{"identifier":"retNoMatch"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":1524900015938809029},"usedName":{"valueName":{"identifier":"wrapError"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"typeName":{"identifier":"Ptr"}},"qualification":null},{"reference":{"otherSlice":4901674627623922080},"usedName":{"typeName":{"identifier":"CRegMatch"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"otherSlice":2522203815511504828},"usedName":{"typeName":{"identifier":"RegOffset"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Storable"},"usedName":{"valueName":{"identifier":"peekByteOff"}},"qualification":null},{"reference":{"builtinModule":"GHC.Int"},"usedName":{"typeName":{"identifier":"Int32"}},"qualification":null},{"reference":{"otherSlice":8287013389532591762},"usedName":{"typeName":{"identifier":"CRegex"}},"qualification":null},{"reference":{"builtinModule":"Foreign.C.String"},"usedName":{"typeName":{"identifier":"CString"}},"qualification":null},{"reference":{"builtinModule":"Foreign.C.Types"},"usedName":{"typeName":{"identifier":"CSize"}},"qualification":null},{"reference":{"otherSlice":8309222215052791244},"usedName":{"typeName":{"identifier":"ExecOption"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"typeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":3294887094191733298},"usedName":{"typeName":{"identifier":"WrapError"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null}],"fragment":["doMatch ::\n        Ptr CRegex ->\n          CString ->\n            CSize ->\n              Ptr CRegMatch ->\n                ExecOption ->\n                  IO (Either WrapError (Maybe [(RegOffset, RegOffset)]))","doMatch regex_ptr cstr nsub p_match flags\n  = do r <- c_regexec regex_ptr cstr (1 + nsub) p_match flags\n       if r == retOk then\n         do regions <- mapM getOffsets .\n                         take (1 + fromIntegral nsub) . iterate (`plusPtr` (8))\n                         $ p_match\n            return (Right (Just regions))\n         else\n         if r == retNoMatch then return (Right Nothing) else\n           wrapError r regex_ptr\n  where getOffsets :: Ptr CRegMatch -> IO (RegOffset, RegOffset)\n        \n        {-# INLINE getOffsets #-}\n        getOffsets pmatch'\n          = do start <- ((\\ hsc_ptr -> peekByteOff hsc_ptr 0)) pmatch' ::\n                          IO (Int32)\n               end <- ((\\ hsc_ptr -> peekByteOff hsc_ptr 4)) pmatch' :: IO (Int32)\n               return (fromIntegral start, fromIntegral end)"],"instances":[],"language":{"extensions":["MultiParamTypeClasses","FunctionalDependencies","ForeignFunctionInterface","GeneralizedNewtypeDeriving","FlexibleContexts","TypeSynonymInstances","FlexibleInstances","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
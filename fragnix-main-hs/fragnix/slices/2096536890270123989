{"sliceID":2096536890270123989,"uses":[{"reference":{"otherSlice":7202692338078551997},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"otherSlice":7235567377809295464},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":5746284862407516300},"usedName":{"valueName":{"identifier":"head"}},"qualification":"S"},{"reference":{"otherSlice":4464784005131150161},"usedName":{"valueName":{"identifier":"elemIndices"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":380767506459821795},"usedName":{"valueName":{"identifier":"take"}},"qualification":"S"},{"reference":{"otherSlice":3748312495235440417},"usedName":{"valueName":{"identifier":"drop"}},"qualification":"S"},{"reference":{"otherSlice":609154278291193738},"usedName":{"valueName":{"identifier":"automaton"}},"qualification":null},{"reference":{"otherSlice":7493882458078027726},"usedName":{"valueName":{"identifier":"unsafeIndex"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"foldr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"flip"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"id"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":5195162226803900797},"usedName":{"valueName":{"identifier":"keep"}},"qualification":null},{"reference":{"otherSlice":3191844957948247487},"usedName":{"valueName":{"identifier":"unsafeAt"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"identifier":"shiftL"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":5437041566882355469},"usedName":{"valueName":{"identifier":"rgo"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":4010822550476529195},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"}],"fragment":["lazyBreaker ::\n            Bool ->\n              S.ByteString -> [S.ByteString] -> ([S.ByteString], [S.ByteString])","lazyBreaker before pat\n  | S.null pat = \\ strs -> ([], strs)\n  | S.length pat == 1 =\n    let !w = S.head pat\n        !a = if before then 0 else 1\n        ixes = S.elemIndices w\n        scan [] = ([], [])\n        scan (!(str : rest))\n          = let !strLen = S.length str in\n              case ixes str of\n                  [] -> let (fr, bk) = scan rest in (str : fr, bk)\n                  (i : _) -> let !j = i + a in\n                               if j == strLen then ([str], rest) else\n                                 ([S.take j str], S.drop j str : rest)\n      in scan\nlazyBreaker !before pat = bscan [] 0\n  where !patLen = S.length pat\n        !auto = automaton pat\n        !p0 = unsafeIndex pat 0\n        bscan _ _ [] = ([], [])\n        bscan !past !sta (!(str : rest)) = match sta 0\n          where !strLen = S.length str\n                \n                {-# INLINE strAt #-}\n                \n                strAt :: Int -> Int\n                strAt i = fromIntegral (str `unsafeIndex` i)\n                match 0 idx\n                  | idx == strLen =\n                    let (fr, bk) = bscan [] 0 rest in\n                      (foldr (flip (.) . (:)) id past (str : fr), bk)\n                  | unsafeIndex str idx == p0 = match 1 (idx + 1)\n                  | otherwise = match 0 (idx + 1)\n                match state idx\n                  | idx == strLen =\n                    let (kp, !rl)\n                          = if before then keep state (str : past) else ([], str : past)\n                        (fr, bk) = bscan kp state rest\n                      in (foldr (flip (.) . (:)) id rl fr, bk)\n                  | otherwise =\n                    let !nstate = unsafeAt auto ((state `shiftL` 8) + strAt idx)\n                        !nxtIdx = idx + 1\n                      in\n                      if nstate == patLen then\n                        case if before then nxtIdx - patLen else nxtIdx of\n                            0 -> (foldr (flip (.) . (:)) id past [], str : rest)\n                            stIx | stIx < 0 -> rgo (-stIx) (str : rest) past\n                                 | stIx == strLen -> (foldr (flip (.) . (:)) id past [str], rest)\n                                 | otherwise ->\n                                   (foldr (flip (.) . (:)) id past [S.take stIx str],\n                                    S.drop stIx str : rest)\n                        else match nstate nxtIdx"],"instances":[],"language":{"extensions":["BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
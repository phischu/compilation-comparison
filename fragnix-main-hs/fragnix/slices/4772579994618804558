{"sliceID":4772579994618804558,"uses":[{"reference":{"otherSlice":2186011155846212713},"usedName":{"constructorName":{"identifier":"Stream"},"constructorTypeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"otherSlice":8028622658720771942},"usedName":{"valueName":{"identifier":"isEmpty"}},"qualification":null},{"reference":{"otherSlice":4524776170727728111},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"I"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":8422374095318209233},"usedName":{"valueName":{"identifier":"text"}},"qualification":"I"},{"reference":{"otherSlice":9185008376510166860},"usedName":{"valueName":{"identifier":"upperBound"}},"qualification":null},{"reference":{"otherSlice":7923813713607015616},"usedName":{"valueName":{"identifier":"larger"}},"qualification":null},{"reference":{"otherSlice":1866006831720242842},"usedName":{"valueName":{"identifier":"run2"}},"qualification":"A"},{"reference":{"otherSlice":5202209142239390005},"usedName":{"valueName":{"identifier":"new"}},"qualification":"A"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"otherSlice":899429663293461015},"usedName":{"constructorName":{"identifier":"Done"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":899429663293461015},"usedName":{"constructorName":{"identifier":"Skip"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"otherSlice":899429663293461015},"usedName":{"constructorName":{"identifier":"Yield"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":7358425231838581354},"usedName":{"valueName":{"identifier":"shiftL"}},"qualification":null},{"reference":{"otherSlice":7788427119660368239},"usedName":{"valueName":{"identifier":"copyM"}},"qualification":"A"},{"reference":{"otherSlice":7488690057018853220},"usedName":{"valueName":{"identifier":"ord"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":7358425231838581354},"usedName":{"valueName":{"identifier":"shiftR"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"operator":".&."}},"qualification":null},{"reference":{"otherSlice":7073776594548819763},"usedName":{"valueName":{"identifier":"unsafeWrite"}},"qualification":"A"},{"reference":{"otherSlice":2186011155846212713},"usedName":{"typeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Char"}},"qualification":null},{"reference":{"otherSlice":2241541392207318616},"usedName":{"typeName":{"identifier":"Text"}},"qualification":null}],"fragment":["reverse :: Stream Char -> Text","reverse (Stream next s len0)\n  | isEmpty len0 = I.empty\n  | otherwise = I.text arr off' len'\n  where len0' = upperBound 4 (larger len0 4)\n        (arr, (off', len'))\n          = A.run2 (A.new len0' >>= loop s (len0' - 1) len0')\n        loop !s0 !i !len marr\n          = case next s0 of\n                Done -> return (marr, (j, len - j))\n                  where j = i + 1\n                Skip s1 -> loop s1 i len marr\n                Yield x s1 | i < least ->\n                             {-# SCC \"reverse/resize\" #-}\n                               do let newLen = len `shiftL` 1\n                                  marr' <- A.new newLen\n                                  A.copyM marr' (newLen - len) marr 0 len\n                                  write s1 (len + i) newLen marr'\n                           | otherwise -> write s1 i len marr\n                  where n = ord x\n                        least\n                          | n < 65536 = 0\n                          | otherwise = 1\n                        m = n - 65536\n                        lo = fromIntegral $ (m `shiftR` 10) + 55296\n                        hi = fromIntegral $ (m .&. 1023) + 56320\n                        write t j l mar\n                          | n < 65536 =\n                            do A.unsafeWrite mar j (fromIntegral n)\n                               loop t (j - 1) l mar\n                          | otherwise =\n                            do A.unsafeWrite mar (j - 1) lo\n                               A.unsafeWrite mar j hi\n                               loop t (j - 2) l mar"],"instances":[],"language":{"extensions":["BangPatterns","MagicHash","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
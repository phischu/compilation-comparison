{"sliceID":3816500397164869619,"uses":[{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"otherSlice":997032288423013583},"usedName":{"valueName":{"identifier":"logArr"}},"qualification":null},{"reference":{"otherSlice":3191844957948247487},"usedName":{"valueName":{"identifier":"unsafeAt"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":168486108079902635},"usedName":{"valueName":{"identifier":"fromNatural"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"quot"}},"qualification":null},{"reference":{"otherSlice":5478196713939479730},"usedName":{"valueName":{"identifier":"naturalPower"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"identifier":"shiftR"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":4375438339145620833},"usedName":{"valueName":{"identifier":"naturalLog2'"}},"qualification":null},{"reference":{"builtinModule":"GHC.Natural"},"usedName":{"typeName":{"identifier":"Natural"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null}],"fragment":["naturalLogBase' :: Natural -> Natural -> Int","naturalLogBase' b n\n  | n < b = 0\n  | ln - lb < lb = 1\n  | b < 33 =\n    let bi = fromIntegral b\n        ix = 2 * bi - 4\n        u = logArr `unsafeAt` ix\n        v = logArr `unsafeAt` (ix + 1)\n        ex\n          = fromNatural\n              ((fromIntegral u * fromIntegral ln) `quot` fromIntegral v)\n      in\n      case u of\n          1 -> ln `quot` v\n          _ -> ex + naturalLogBase' b (n `quot` naturalPower b ex)\n  | otherwise =\n    let bi = fromNatural (b `shiftR` (lb - 4))\n        ix = 2 * bi - 2\n        u = fromIntegral $ logArr `unsafeAt` ix\n        v = fromIntegral $ logArr `unsafeAt` (ix + 1)\n        w = v + u * fromIntegral (lb - 4)\n        ex = fromNatural ((u * fromIntegral ln) `quot` w)\n      in ex + naturalLogBase' b (n `quot` naturalPower b ex)\n  where lb = naturalLog2' b\n        ln = naturalLog2' n"],"instances":[],"language":{"extensions":["MagicHash","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
{"sliceID":8592548926701903594,"uses":[{"reference":{"otherSlice":1254073128444822395},"usedName":{"constructorName":{"identifier":"Stream"},"constructorTypeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"SPEC"},"constructorTypeName":{"identifier":"SPEC"}},"qualification":null},{"reference":{"otherSlice":2120320550836080743},"usedName":{"constructorName":{"identifier":"Yield"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"otherSlice":2120320550836080743},"usedName":{"constructorName":{"identifier":"Skip"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"otherSlice":2120320550836080743},"usedName":{"constructorName":{"identifier":"Done"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Monad"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":1254073128444822395},"usedName":{"typeName":{"identifier":"Stream"}},"qualification":null}],"fragment":["eqBy ::\n       (Monad m) => (a -> b -> Bool) -> Stream m a -> Stream m b -> m Bool","eqBy eq (Stream step1 t1) (Stream step2 t2) = eq_loop0 SPEC t1 t2\n  where eq_loop0 !_ s1 s2\n          = do r <- step1 s1\n               case r of\n                   Yield x s1' -> eq_loop1 SPEC x s1' s2\n                   Skip s1' -> eq_loop0 SPEC s1' s2\n                   Done -> eq_null s2\n        eq_loop1 !_ x s1 s2\n          = do r <- step2 s2\n               case r of\n                   Yield y s2' | eq x y -> eq_loop0 SPEC s1 s2'\n                               | otherwise -> return False\n                   Skip s2' -> eq_loop1 SPEC x s1 s2'\n                   Done -> return False\n        eq_null s2\n          = do r <- step2 s2\n               case r of\n                   Yield _ _ -> return False\n                   Skip s2' -> eq_null s2'\n                   Done -> return True"],"instances":[],"language":{"extensions":["ExistentialQuantification","MultiParamTypeClasses","FlexibleInstances","Rank2Types","BangPatterns","KindSignatures","GADTs","ScopedTypeVariables","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
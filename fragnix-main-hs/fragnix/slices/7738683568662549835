{"sliceID":7738683568662549835,"uses":[{"reference":{"otherSlice":3015404642924089020},"usedName":{"constructorName":{"identifier":"EncodeStrategy"},"constructorTypeName":{"identifier":"EncodeStrategy"}},"qualification":null},{"reference":{"otherSlice":3015404642924089020},"usedName":{"valueName":{"identifier":"compressionAlgo"}},"qualification":null},{"reference":{"otherSlice":3015404642924089020},"usedName":{"valueName":{"identifier":"useHuffman"}},"qualification":null},{"reference":{"otherSlice":1073997475800659652},"usedName":{"valueName":{"identifier":"newWorkingBuffer"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"when"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":1529233125470310207},"usedName":{"valueName":{"identifier":"changeTableSize"}},"qualification":null},{"reference":{"otherSlice":5412005961844528159},"usedName":{"valueName":{"identifier":"indexedHeaderField"}},"qualification":null},{"reference":{"otherSlice":3130045314277605382},"usedName":{"valueName":{"identifier":"literalHeaderFieldWithIncrementalIndexingIndexedName"}},"qualification":null},{"reference":{"otherSlice":7978979865817059757},"usedName":{"valueName":{"identifier":"literalHeaderFieldWithIncrementalIndexingNewName"}},"qualification":null},{"reference":{"otherSlice":8663345271635929438},"usedName":{"valueName":{"identifier":"literalHeaderFieldWithoutIndexingIndexedName"}},"qualification":null},{"reference":{"otherSlice":2922522358460655243},"usedName":{"valueName":{"identifier":"literalHeaderFieldWithoutIndexingNewName"}},"qualification":null},{"reference":{"otherSlice":5025311664219340630},"usedName":{"valueName":{"identifier":"literalHeaderFieldWithoutIndexingNewName'"}},"qualification":null},{"reference":{"otherSlice":7326009891081422896},"usedName":{"valueName":{"identifier":"getRevIndex"}},"qualification":null},{"reference":{"otherSlice":2526942351961331812},"usedName":{"constructorName":{"identifier":"Naive"},"constructorTypeName":{"identifier":"CompressionAlgo"}},"qualification":null},{"reference":{"otherSlice":8386198461282926391},"usedName":{"valueName":{"identifier":"naiveStep"}},"qualification":null},{"reference":{"otherSlice":2526942351961331812},"usedName":{"constructorName":{"identifier":"Static"},"constructorTypeName":{"identifier":"CompressionAlgo"}},"qualification":null},{"reference":{"otherSlice":815112215232642830},"usedName":{"valueName":{"identifier":"staticStep"}},"qualification":null},{"reference":{"otherSlice":2526942351961331812},"usedName":{"constructorName":{"identifier":"Linear"},"constructorTypeName":{"identifier":"CompressionAlgo"}},"qualification":null},{"reference":{"otherSlice":6736034502364244329},"usedName":{"valueName":{"identifier":"linearStep"}},"qualification":null},{"reference":{"otherSlice":7138438797358412597},"usedName":{"valueName":{"identifier":"currentOffset"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"newIORef"}},"qualification":null},{"reference":{"builtinModule":"Control.Exception.Base"},"usedName":{"valueName":{"identifier":"catch"}},"qualification":"E"},{"reference":{"otherSlice":3210954324554976950},"usedName":{"constructorName":{"identifier":"BufferOverrun"},"constructorTypeName":{"identifier":"BufferOverrun"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"readIORef"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"minusPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"writeIORef"}},"qualification":null},{"reference":{"otherSlice":7140848239145789393},"usedName":{"typeName":{"identifier":"Buffer"}},"qualification":null},{"reference":{"otherSlice":6991289732877524006},"usedName":{"typeName":{"identifier":"BufferSize"}},"qualification":null},{"reference":{"otherSlice":3015404642924089020},"usedName":{"typeName":{"identifier":"EncodeStrategy"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":6383363541455760455},"usedName":{"typeName":{"identifier":"DynamicTable"}},"qualification":null},{"reference":{"otherSlice":390496612234166211},"usedName":{"typeName":{"identifier":"TokenHeaderList"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null}],"fragment":["encodeTokenHeader ::\n                  Buffer ->\n                    BufferSize ->\n                      EncodeStrategy ->\n                        Bool ->\n                          DynamicTable -> TokenHeaderList -> IO (TokenHeaderList, Int)","encodeTokenHeader buf siz EncodeStrategy{..} first dyntbl hs0\n  = do wbuf <- newWorkingBuffer buf siz\n       when first $ changeTableSize dyntbl wbuf\n       let fa = indexedHeaderField dyntbl wbuf useHuffman\n           fb\n             = literalHeaderFieldWithIncrementalIndexingIndexedName dyntbl wbuf\n                 useHuffman\n           fc\n             = literalHeaderFieldWithIncrementalIndexingNewName dyntbl wbuf\n                 useHuffman\n           fd\n             = literalHeaderFieldWithoutIndexingIndexedName dyntbl wbuf\n                 useHuffman\n           fe\n             = literalHeaderFieldWithoutIndexingNewName dyntbl wbuf useHuffman\n           fe'\n             = literalHeaderFieldWithoutIndexingNewName' dyntbl wbuf useHuffman\n           rev = getRevIndex dyntbl\n           step0\n             = case compressionAlgo of\n                   Naive -> naiveStep fe'\n                   Static -> staticStep fa fd fe\n                   Linear -> linearStep rev fa fb fc fd\n       ref1 <- currentOffset wbuf >>= newIORef\n       ref2 <- newIORef hs0\n       loop wbuf ref1 ref2 step0 hs0 `E.catch`\n         \\ BufferOverrun -> return ()\n       end <- readIORef ref1\n       let !len = end `minusPtr` buf\n       hs <- readIORef ref2\n       return (hs, len)\n  where loop wbuf ref1 ref2 step hsx = go hsx\n          where go [] = return ()\n                go ((t, v) : hs)\n                  = do _ <- step t v\n                       currentOffset wbuf >>= writeIORef ref1\n                       writeIORef ref2 hs\n                       go hs"],"instances":[],"language":{"extensions":["BangPatterns","RecordWildCards","OverloadedStrings","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
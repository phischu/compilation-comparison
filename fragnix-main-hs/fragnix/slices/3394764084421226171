{"sliceID":3394764084421226171,"uses":[{"reference":{"otherSlice":8468946667989408909},"usedName":{"constructorName":{"identifier":"Seq"},"constructorTypeName":{"identifier":"Seq"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"otherSlice":6500945367252731749},"usedName":{"typeName":{"identifier":"Elem"}},"qualification":null},{"reference":{"otherSlice":2497553050502348575},"usedName":{"typeName":{"identifier":"FingerTree"}},"qualification":null},{"reference":{"otherSlice":4603056598885952374},"usedName":{"typeName":{"identifier":"Node"}},"qualification":null},{"reference":{"otherSlice":3097725820661431075},"usedName":{"typeName":{"identifier":"Sized"}},"qualification":null},{"reference":{"builtinModule":"GHC.Prim"},"usedName":{"valueName":{"identifier":"seq"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"undefined"}},"qualification":null},{"reference":{"otherSlice":2497553050502348575},"usedName":{"constructorName":{"identifier":"Empty"},"constructorTypeName":{"identifier":"FingerTree"}},"qualification":null},{"reference":{"otherSlice":2497553050502348575},"usedName":{"constructorName":{"identifier":"Single"},"constructorTypeName":{"identifier":"FingerTree"}},"qualification":null},{"reference":{"otherSlice":2497553050502348575},"usedName":{"constructorName":{"identifier":"Deep"},"constructorTypeName":{"identifier":"FingerTree"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"otherSlice":6073454630168832022},"usedName":{"constructorName":{"identifier":"One"},"constructorTypeName":{"identifier":"Digit"}},"qualification":null},{"reference":{"otherSlice":6073454630168832022},"usedName":{"constructorName":{"identifier":"Two"},"constructorTypeName":{"identifier":"Digit"}},"qualification":null},{"reference":{"otherSlice":3097725820661431075},"usedName":{"valueName":{"identifier":"size"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":6073454630168832022},"usedName":{"constructorName":{"identifier":"Three"},"constructorTypeName":{"identifier":"Digit"}},"qualification":null},{"reference":{"otherSlice":6073454630168832022},"usedName":{"typeName":{"identifier":"Digit"}},"qualification":null},{"reference":{"otherSlice":4603056598885952374},"usedName":{"constructorName":{"identifier":"Node3"},"constructorTypeName":{"identifier":"Node"}},"qualification":null},{"reference":{"builtinModule":"GHC.Prim"},"usedName":{"valueName":{"identifier":"coerce"}},"qualification":null},{"reference":{"otherSlice":8468946667989408909},"usedName":{"typeName":{"identifier":"Seq"}},"qualification":null},{"reference":{"otherSlice":6500945367252731749},"usedName":{"constructorName":{"identifier":"Elem"},"constructorTypeName":{"identifier":"Elem"}},"qualification":null},{"reference":{"otherSlice":4603056598885952374},"usedName":{"constructorName":{"identifier":"Node2"},"constructorTypeName":{"identifier":"Node"}},"qualification":null},{"reference":{"otherSlice":6073454630168832022},"usedName":{"constructorName":{"identifier":"Four"},"constructorTypeName":{"identifier":"Digit"}},"qualification":null}],"fragment":["fromList :: [a] -> Seq a","fromList = Seq . mkTree 1 . map_elem\n  where {-# SPECIALISE mkTree ::\n                         Int -> [Elem a] -> FingerTree (Elem a) #-}\n        \n        {-# SPECIALISE mkTree :: Int -> [Node a] -> FingerTree (Node a) #-}\n        \n        mkTree :: (Sized a) => Int -> [a] -> FingerTree a\n        mkTree arg _ | arg `seq` False = undefined\n        mkTree _ [] = Empty\n        mkTree _ [x1] = Single x1\n        mkTree s [x1, x2] = Deep (2 * s) (One x1) Empty (One x2)\n        mkTree s [x1, x2, x3] = Deep (3 * s) (One x1) Empty (Two x2 x3)\n        mkTree s (x1 : (x2 : (x3 : (x4 : xs))))\n          = case getNodes (3 * s) x4 xs of\n                (ns, sf) -> case mkTree (3 * s) ns of\n                                m -> m `seq`\n                                       Deep (3 * size x1 + size m + size sf) (Three x1 x2 x3) m sf\n        \n        getNodes :: Int -> a -> [a] -> ([Node a], Digit a)\n        getNodes arg _ _ | arg `seq` False = undefined\n        getNodes _ x1 [] = ([], One x1)\n        getNodes _ x1 [x2] = ([], Two x1 x2)\n        getNodes _ x1 [x2, x3] = ([], Three x1 x2 x3)\n        getNodes s x1 (x2 : (x3 : (x4 : xs))) = (Node3 s x1 x2 x3 : ns, d)\n          where (ns, d) = getNodes s x4 xs\n        \n        map_elem :: [a] -> [Elem a]\n        map_elem xs = coerce xs\n        \n        {-# INLINE map_elem #-}"],"instances":[],"language":{"extensions":["DeriveDataTypeable","StandaloneDeriving","TypeFamilies","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
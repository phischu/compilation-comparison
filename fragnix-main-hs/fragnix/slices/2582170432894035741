{"sliceID":2582170432894035741,"uses":[{"reference":{"builtinModule":"Control.Monad.ST.Lazy"},"usedName":{"valueName":{"identifier":"runST"}},"qualification":null},{"reference":{"otherSlice":7656308987823753789},"usedName":{"valueName":{"identifier":"toChunks"}},"qualification":"L"},{"reference":{"otherSlice":8160419729831137275},"usedName":{"constructorName":{"identifier":"CompressInputRequired"},"constructorTypeName":{"identifier":"CompressStream"}},"qualification":null},{"reference":{"otherSlice":7459617743278403755},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"otherSlice":8160419729831137275},"usedName":{"constructorName":{"identifier":"CompressOutputAvailable"},"constructorTypeName":{"identifier":"CompressStream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":8160419729831137275},"usedName":{"constructorName":{"identifier":"CompressStreamEnd"},"constructorTypeName":{"identifier":"CompressStream"}},"qualification":null},{"reference":{"otherSlice":4010822550476529195},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"otherSlice":8160419729831137275},"usedName":{"typeName":{"identifier":"CompressStream"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad.ST.Lazy"},"usedName":{"typeName":{"identifier":"ST"}},"qualification":null},{"reference":{"otherSlice":7233619382983855062},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"L"}],"fragment":["foldCompressStreamWithInput ::\n                            (S.ByteString -> a -> a) ->\n                              a -> (forall s . CompressStream (ST s)) -> L.ByteString -> a","foldCompressStreamWithInput chunk end\n  = \\ s lbs -> runST (fold s (L.toChunks lbs))\n  where fold (CompressInputRequired next) []\n          = next S.empty >>= \\ strm -> fold strm []\n        fold (CompressInputRequired next) (inchunk : inchunks)\n          = next inchunk >>= \\ s -> fold s inchunks\n        fold (CompressOutputAvailable outchunk next) inchunks\n          = do r <- next >>= \\ s -> fold s inchunks\n               return $ chunk outchunk r\n        fold CompressStreamEnd _inchunks = return end"],"instances":[],"language":{"extensions":["RankNTypes","DeriveDataTypeable","BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
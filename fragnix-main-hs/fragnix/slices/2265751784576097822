{"sliceID":2265751784576097822,"uses":[{"reference":{"builtinModule":"GHC.Prim"},"usedName":{"valueName":{"identifier":"seq"}},"qualification":null},{"reference":{"otherSlice":3215441896288524948},"usedName":{"constructorName":{"identifier":"Bin"},"constructorTypeName":{"identifier":"IntMap"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">="}},"qualification":null},{"reference":{"otherSlice":3215441896288524948},"usedName":{"constructorName":{"identifier":"Nil"},"constructorTypeName":{"identifier":"IntMap"}},"qualification":null},{"reference":{"otherSlice":2654114007802303743},"usedName":{"valueName":{"identifier":"nomatch"}},"qualification":null},{"reference":{"otherSlice":8608400882689775118},"usedName":{"valueName":{"identifier":"unsafeFindMin"}},"qualification":null},{"reference":{"otherSlice":4724247418787711009},"usedName":{"valueName":{"identifier":"zero"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":3215441896288524948},"usedName":{"constructorName":{"identifier":"Tip"},"constructorTypeName":{"identifier":"IntMap"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":937490584395345141},"usedName":{"typeName":{"identifier":"Key"}},"qualification":null},{"reference":{"otherSlice":3215441896288524948},"usedName":{"typeName":{"identifier":"IntMap"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null}],"fragment":["lookupGT :: Key -> IntMap a -> Maybe (Key, a)","lookupGT k t\n  = k `seq`\n      case t of\n          Bin _ m l r | m < 0 -> if k >= 0 then go Nil l else go l r\n          _ -> go Nil t\n  where go def (Bin p m l r)\n          | nomatch k p m =\n            if k < p then unsafeFindMin l else unsafeFindMin def\n          | zero k m = go r l\n          | otherwise = go def r\n        go def (Tip ky y)\n          | k >= ky = unsafeFindMin def\n          | otherwise = Just (ky, y)\n        go def Nil = unsafeFindMin def"],"instances":[],"language":{"extensions":["MagicHash","DeriveDataTypeable","StandaloneDeriving","ScopedTypeVariables","TypeFamilies","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
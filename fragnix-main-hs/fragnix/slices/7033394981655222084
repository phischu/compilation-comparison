{"sliceID":7033394981655222084,"uses":[{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":7018167640776532751},"usedName":{"valueName":{"identifier":"singleton"}},"qualification":null},{"reference":{"builtinModule":"Data.Monoid"},"usedName":{"valueName":{"operator":"<>"}},"qualification":null},{"reference":{"otherSlice":6499721132049218751},"usedName":{"valueName":{"identifier":"toDecimalDigits"}},"qualification":"Scientific"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"otherSlice":8829271036141060815},"usedName":{"valueName":{"identifier":"i2d"}},"qualification":null},{"reference":{"otherSlice":2418377670000465580},"usedName":{"constructorName":{"identifier":"Generic"},"constructorTypeName":{"identifier":"FPFormat"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"||"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">"}},"qualification":null},{"reference":{"otherSlice":2418377670000465580},"usedName":{"constructorName":{"identifier":"Exponent"},"constructorTypeName":{"identifier":"FPFormat"}},"qualification":null},{"reference":{"otherSlice":2418377670000465580},"usedName":{"constructorName":{"identifier":"Fixed"},"constructorTypeName":{"identifier":"FPFormat"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":2895301665658882648},"usedName":{"valueName":{"identifier":"decimal"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"otherSlice":9046112411268164559},"usedName":{"valueName":{"identifier":"fromString"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"error"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"max"}},"qualification":null},{"reference":{"otherSlice":4332510746250638343},"usedName":{"valueName":{"identifier":"fromText"}},"qualification":null},{"reference":{"otherSlice":5442614913020288291},"usedName":{"valueName":{"identifier":"replicate"}},"qualification":"T"},{"reference":{"otherSlice":5877354395276220359},"usedName":{"valueName":{"identifier":"roundTo"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"init"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<="}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"reverse"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">="}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"splitAt"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"null"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"replicate"}},"qualification":null},{"reference":{"otherSlice":2418377670000465580},"usedName":{"typeName":{"identifier":"FPFormat"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"otherSlice":655943511058533134},"usedName":{"typeName":{"identifier":"Scientific"}},"qualification":null},{"reference":{"otherSlice":295242023853634490},"usedName":{"typeName":{"identifier":"Builder"}},"qualification":null}],"fragment":["formatScientificBuilder ::\n                        FPFormat -> Maybe Int -> Scientific -> Builder","formatScientificBuilder fmt decs scntfc\n  | scntfc < 0 =\n    singleton '-' <> doFmt fmt (Scientific.toDecimalDigits (-scntfc))\n  | otherwise = doFmt fmt (Scientific.toDecimalDigits scntfc)\n  where doFmt format (is, e)\n          = let ds = map i2d is in\n              case format of\n                  Generic -> doFmt (if e < 0 || e > 7 then Exponent else Fixed)\n                               (is, e)\n                  Exponent -> case decs of\n                                  Nothing -> let show_e' = decimal (e - 1) in\n                                               case ds of\n                                                   \"0\" -> \"0.0e0\"\n                                                   [d] -> singleton d <> \".0e\" <> show_e'\n                                                   (d : ds') -> singleton d <> singleton '.' <>\n                                                                  fromString ds'\n                                                                  <> singleton 'e'\n                                                                  <> show_e'\n                                                   [] -> error $\n                                                           \"Data.Text.Lazy.Builder.Scientific.formatScientificBuilder\"\n                                                             ++ \"/doFmt/Exponent: []\"\n                                  Just dec -> let dec' = max dec 1 in\n                                                case is of\n                                                    [0] -> \"0.\" <> fromText (T.replicate dec' \"0\")\n                                                             <> \"e0\"\n                                                    _ -> let (ei, is') = roundTo (dec' + 1) is\n                                                             (d : ds')\n                                                               = map i2d\n                                                                   (if ei > 0 then init is' else\n                                                                      is')\n                                                           in\n                                                           singleton d <> singleton '.' <>\n                                                             fromString ds'\n                                                             <> singleton 'e'\n                                                             <> decimal (e - 1 + ei)\n                  Fixed -> let mk0 ls\n                                 = case ls of\n                                       \"\" -> \"0\"\n                                       _ -> fromString ls\n                             in\n                             case decs of\n                                 Nothing | e <= 0 ->\n                                           \"0.\" <> fromText (T.replicate (-e) \"0\") <> fromString ds\n                                         | otherwise ->\n                                           let f 0 s rs = mk0 (reverse s) <> singleton '.' <> mk0 rs\n                                               f n s \"\" = f (n - 1) ('0' : s) \"\"\n                                               f n s (r : rs) = f (n - 1) (r : s) rs\n                                             in f e \"\" ds\n                                 Just dec -> let dec' = max dec 0 in\n                                               if e >= 0 then\n                                                 let (ei, is') = roundTo (dec' + e) is\n                                                     (ls, rs) = splitAt (e + ei) (map i2d is')\n                                                   in\n                                                   mk0 ls <>\n                                                     (if null rs then \"\" else\n                                                        singleton '.' <> fromString rs)\n                                                 else\n                                                 let (ei, is')\n                                                       = roundTo dec' (replicate (-e) 0 ++ is)\n                                                     d : ds'\n                                                       = map i2d (if ei > 0 then is' else 0 : is')\n                                                   in\n                                                   singleton d <>\n                                                     (if null ds' then \"\" else\n                                                        singleton '.' <> fromString ds')"],"instances":[],"language":{"extensions":["MagicHash","OverloadedStrings","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
{"sliceID":722395964124692841,"uses":[{"reference":{"builtinModule":"Data.Data"},"usedName":{"valueName":{"identifier":"dataTypeOf"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"Data.Data"},"usedName":{"valueName":{"identifier":"dataTypeRep"}},"qualification":null},{"reference":{"builtinModule":"Data.Data"},"usedName":{"constructorName":{"identifier":"AlgRep"},"constructorTypeName":{"identifier":"DataRep"}},"qualification":null},{"reference":{"otherSlice":1669319695546572556},"usedName":{"constructorName":{"identifier":"Null"},"constructorTypeName":{"identifier":"Value"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":9148036613603187110},"usedName":{"valueName":{"identifier":"modError"}},"qualification":null},{"reference":{"otherSlice":3886534024474226034},"usedName":{"valueName":{"identifier":"modFail"}},"qualification":null},{"reference":{"builtinModule":"Data.Data"},"usedName":{"valueName":{"identifier":"indexConstr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Show"},"usedName":{"valueName":{"identifier":"show"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"otherSlice":1669319695546572556},"usedName":{"constructorName":{"identifier":"Object"},"constructorTypeName":{"identifier":"Value"}},"qualification":null},{"reference":{"otherSlice":1669319695546572556},"usedName":{"constructorName":{"identifier":"String"},"constructorTypeName":{"identifier":"Value"}},"qualification":null},{"reference":{"otherSlice":212440380998441966},"usedName":{"valueName":{"identifier":"unpack"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"valueName":{"identifier":"maybe"}},"qualification":null},{"reference":{"builtinModule":"Data.Data"},"usedName":{"valueName":{"identifier":"readConstr"}},"qualification":null},{"reference":{"builtinModule":"Data.Data"},"usedName":{"valueName":{"identifier":"constrFields"}},"qualification":null},{"reference":{"otherSlice":1669319695546572556},"usedName":{"constructorName":{"identifier":"Array"},"constructorTypeName":{"identifier":"Value"}},"qualification":null},{"reference":{"otherSlice":1636744142848187809},"usedName":{"valueName":{"identifier":"toList"}},"qualification":"V"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"builtinModule":"Control.Arrow"},"usedName":{"valueName":{"identifier":"first"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":2303024117134025433},"usedName":{"valueName":{"identifier":"toList"}},"qualification":"H"},{"reference":{"otherSlice":8021708859655897931},"usedName":{"valueName":{"identifier":"evalStateT"}},"qualification":null},{"reference":{"builtinModule":"Data.Data"},"usedName":{"valueName":{"identifier":"fromConstrM"}},"qualification":null},{"reference":{"builtinModule":"Data.Data"},"usedName":{"typeName":{"identifier":"Data"}},"qualification":null},{"reference":{"otherSlice":2180372455056153309},"usedName":{"typeName":{"identifier":"StateT"}},"qualification":null},{"reference":{"otherSlice":1669319695546572556},"usedName":{"typeName":{"identifier":"Value"}},"qualification":null},{"reference":{"otherSlice":5454664963428560658},"usedName":{"typeName":{"identifier":"Parser"}},"qualification":null},{"reference":{"otherSlice":9178480903840253076},"usedName":{"valueName":{"identifier":"get"}},"qualification":null},{"reference":{"otherSlice":1800817309688667062},"usedName":{"valueName":{"identifier":"lift"}},"qualification":null},{"reference":{"otherSlice":9178480903840253076},"usedName":{"valueName":{"identifier":"put"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"mapM"}},"qualification":null},{"reference":{"otherSlice":4884679441121001069},"usedName":{"valueName":{"identifier":"lookup"}},"qualification":"H"},{"reference":{"otherSlice":400033489728798890},"usedName":{"valueName":{"identifier":"pack"}},"qualification":null},{"reference":{"builtinModule":"Data.Data"},"usedName":{"typeName":{"identifier":"Constr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"otherSlice":1794257694554010799},"usedName":{"valueName":{"identifier":"execState"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"asTypeOf"}},"qualification":null},{"reference":{"otherSlice":7546477014285353099},"usedName":{"valueName":{"identifier":"modify"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"undefined"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"typeName":{"identifier":"MonadPlus"}},"qualification":null},{"reference":{"otherSlice":77858720751745995},"usedName":{"valueName":{"identifier":"ext1R"}},"qualification":null},{"reference":{"otherSlice":7437438681885898304},"usedName":{"valueName":{"identifier":"ext2R'"}},"qualification":null},{"reference":{"otherSlice":8736499836352441669},"usedName":{"valueName":{"identifier":"extR"}},"qualification":null},{"reference":{"otherSlice":5321669235150504643},"usedName":{"typeName":{"identifier":"F"}},"qualification":null},{"reference":{"builtinModule":"GHC.Integer"},"usedName":{"typeName":{"identifier":"Integer"}},"qualification":null},{"reference":{"builtinModule":"GHC.Int"},"usedName":{"typeName":{"identifier":"Int8"}},"qualification":null},{"reference":{"builtinModule":"GHC.Int"},"usedName":{"typeName":{"identifier":"Int16"}},"qualification":null},{"reference":{"builtinModule":"GHC.Int"},"usedName":{"typeName":{"identifier":"Int32"}},"qualification":null},{"reference":{"builtinModule":"GHC.Int"},"usedName":{"typeName":{"identifier":"Int64"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Word"}},"qualification":null},{"reference":{"builtinModule":"GHC.Word"},"usedName":{"typeName":{"identifier":"Word8"}},"qualification":null},{"reference":{"builtinModule":"GHC.Word"},"usedName":{"typeName":{"identifier":"Word16"}},"qualification":null},{"reference":{"builtinModule":"GHC.Word"},"usedName":{"typeName":{"identifier":"Word32"}},"qualification":null},{"reference":{"builtinModule":"GHC.Word"},"usedName":{"typeName":{"identifier":"Word64"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Double"}},"qualification":null},{"reference":{"otherSlice":3500322218702681625},"usedName":{"typeName":{"identifier":"Number"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Float"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"typeName":{"identifier":"Rational"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Char"}},"qualification":null},{"reference":{"otherSlice":6742866475076404776},"usedName":{"typeName":{"identifier":"Text"}},"qualification":null},{"reference":{"otherSlice":3835980439088584228},"usedName":{"typeName":{"identifier":"Text"}},"qualification":"LT"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"String"}},"qualification":null},{"reference":{"otherSlice":1669319695546572556},"usedName":{"typeName":{"identifier":"Value"}},"qualification":"T"},{"reference":{"otherSlice":1182561289642179335},"usedName":{"typeName":{"identifier":"DotNetTime"}},"qualification":null},{"reference":{"otherSlice":3833914085320438758},"usedName":{"typeName":{"identifier":"UTCTime"}},"qualification":null},{"reference":{"otherSlice":7169308240080232539},"usedName":{"typeName":{"identifier":"IntSet"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":7281902249350019939},"usedName":{"typeName":{"identifier":"FromJSON"}},"qualification":"T"},{"reference":{"otherSlice":7281902249350019939},"usedName":{"valueName":{"identifier":"parseJSON"}},"qualification":"T"},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"operator":"<$>"}},"qualification":null},{"reference":{"otherSlice":5971278633365469013},"usedName":{"typeName":{"identifier":"Vector"}},"qualification":"V"},{"reference":{"otherSlice":9160080535451805991},"usedName":{"valueName":{"identifier":"mapM"}},"qualification":"V"},{"reference":{"otherSlice":4136673170685477501},"usedName":{"typeName":{"identifier":"Map"}},"qualification":"Map"},{"reference":{"builtinModule":"Data.Typeable.Internal"},"usedName":{"valueName":{"identifier":"typeOf"}},"qualification":null},{"reference":{"otherSlice":600428831856449117},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"DT"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"id"}},"qualification":null},{"reference":{"otherSlice":3206583878039194784},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"LT"},{"reference":{"otherSlice":532927593689475356},"usedName":{"valueName":{"identifier":"fromStrict"}},"qualification":"LT"},{"reference":{"otherSlice":212440380998441966},"usedName":{"valueName":{"identifier":"unpack"}},"qualification":"DT"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"Data.Typeable"},"usedName":{"valueName":{"identifier":"cast"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"operator":"=<<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"typeName":{"identifier":"Ord"}},"qualification":null},{"reference":{"otherSlice":2259158086607407638},"usedName":{"valueName":{"identifier":"fromList"}},"qualification":"Map"},{"reference":{"builtinModule":"Data.Traversable"},"usedName":{"valueName":{"identifier":"mapM"}},"qualification":"T"},{"reference":{"otherSlice":8924003398132186113},"usedName":{"typeName":{"identifier":"HashMap"}},"qualification":"H"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"typeName":{"identifier":"Eq"}},"qualification":null},{"reference":{"otherSlice":7954954090554769191},"usedName":{"typeName":{"identifier":"Hashable"}},"qualification":null},{"reference":{"otherSlice":5494449121550456513},"usedName":{"valueName":{"identifier":"mapKey"}},"qualification":null}],"fragment":["parseJSON_generic :: (Data a) => Value -> Parser a","parseJSON_generic j = generic\n  where typ = dataTypeOf $ resType generic\n        generic\n          = case dataTypeRep typ of\n                AlgRep [] -> case j of\n                                 Null -> return (modError \"parseJSON\" \"empty type\")\n                                 _ -> modFail \"parseJSON\" \"no-constr bad data\"\n                AlgRep [_] -> decodeArgs (indexConstr typ 1) j\n                AlgRep _ -> do (c, j') <- getConstr typ j\n                               decodeArgs c j'\n                rep -> modFail \"parseJSON\" $ show rep ++ \"(\" ++ show typ ++ \")\"\n        getConstr t (Object o)\n          | [(s, j')] <- fromJSObject o =\n            do c <- readConstr' t s\n               return (c, j')\n        getConstr t (String js)\n          = do c <- readConstr' t (unpack js)\n               return (c, Null)\n        getConstr _ _ = modFail \"parseJSON\" \"bad constructor encoding\"\n        readConstr' t s\n          = maybe\n              (modFail \"parseJSON\" $\n                 \"unknown constructor: \" ++ s ++ \" \" ++ show t)\n              return\n              $ readConstr t s\n        decodeArgs c0\n          = go (numConstrArgs (resType generic) c0) c0 (constrFields c0)\n          where go 0 c _ Null = construct c []\n                go 1 c [] jd = construct c [jd]\n                go _ c [] (Array js) = construct c (V.toList js)\n                go _ c fs@(_ : _) (Object o) = selectFields o fs >>= construct c\n                go _ c _ jd\n                  = modFail \"parseJSON\" $ \"bad decodeArgs data \" ++ show (c, jd)\n        fromJSObject = map (first unpack) . H.toList\n        construct c = evalStateT $ fromConstrM f c\n          where f :: (Data a) => StateT [Value] Parser a\n                f = do js <- get\n                       case js of\n                           [] -> lift $ modFail \"construct\" \"empty list\"\n                           (j' : js') -> do put js'\n                                            lift $ parseJSON j'\n        selectFields fjs\n          = mapM $\n              \\ f ->\n                maybe (modFail \"parseJSON\" $ \"field does not exist \" ++ f) return $\n                  H.lookup (pack f) fjs\n        \n        numConstrArgs :: (Data a) => a -> Constr -> Int\n        numConstrArgs x c\n          = execState (fromConstrM f c `asTypeOf` return x) 0\n          where f = do modify (+ 1)\n                       return undefined\n        \n        resType :: MonadPlus m => m a -> a\n        resType _ = modError \"parseJSON\" \"resType\"","parseJSON :: (Data a) => Value -> Parser a","parseJSON j\n  = parseJSON_generic j `ext1R` maybeP `ext1R` list `ext1R` vector\n      `ext2R'` mapAny\n      `ext2R'` hashMapAny\n      `extR` (value :: F Integer)\n      `extR` (value :: F Int)\n      `extR` (value :: F Int8)\n      `extR` (value :: F Int16)\n      `extR` (value :: F Int32)\n      `extR` (value :: F Int64)\n      `extR` (value :: F Word)\n      `extR` (value :: F Word8)\n      `extR` (value :: F Word16)\n      `extR` (value :: F Word32)\n      `extR` (value :: F Word64)\n      `extR` (value :: F Double)\n      `extR` (value :: F Number)\n      `extR` (value :: F Float)\n      `extR` (value :: F Rational)\n      `extR` (value :: F Char)\n      `extR` (value :: F Text)\n      `extR` (value :: F LT.Text)\n      `extR` (value :: F String)\n      `extR` (value :: F T.Value)\n      `extR` (value :: F DotNetTime)\n      `extR` (value :: F UTCTime)\n      `extR` (value :: F IntSet)\n      `extR` (value :: F Bool)\n      `extR` (value :: F ())\n  where value :: (T.FromJSON a) => Parser a\n        value = T.parseJSON j\n        \n        maybeP :: (Data a) => Parser (Maybe a)\n        maybeP = if j == Null then return Nothing else Just <$> parseJSON j\n        \n        list :: (Data a) => Parser [a]\n        list = V.toList <$> parseJSON j\n        \n        vector :: (Data a) => Parser (V.Vector a)\n        vector\n          = case j of\n                Array js -> V.mapM parseJSON js\n                _ -> myFail\n        \n        mapAny :: forall e f . (Data e, Data f) => Parser (Map.Map f e)\n        mapAny\n          | tyrep == typeOf DT.empty = process id\n          | tyrep == typeOf LT.empty = process LT.fromStrict\n          | tyrep == typeOf \"\" = process DT.unpack\n          | otherwise = myFail\n          where process f = maybe myFail return . cast =<< parseWith f\n                \n                parseWith :: (Ord c) => (Text -> c) -> Parser (Map.Map c e)\n                parseWith f\n                  = case j of\n                        Object js -> Map.fromList . map (first f) . H.toList <$>\n                                       T.mapM parseJSON js\n                        _ -> myFail\n                tyrep = typeOf (undefined :: f)\n        \n        hashMapAny ::\n                   forall e f . (Data e, Data f) => Parser (H.HashMap f e)\n        hashMapAny\n          | tyrep == typeOf DT.empty = process id\n          | tyrep == typeOf LT.empty = process LT.fromStrict\n          | tyrep == typeOf \"\" = process DT.unpack\n          | otherwise = myFail\n          where process f = maybe myFail return . cast =<< parseWith f\n                \n                parseWith ::\n                            (Eq c, Hashable c) => (Text -> c) -> Parser (H.HashMap c e)\n                parseWith f\n                  = case j of\n                        Object js -> mapKey f <$> T.mapM parseJSON js\n                        _ -> myFail\n                tyrep = typeOf (undefined :: f)\n        myFail = modFail \"parseJSON\" $ \"bad data: \" ++ show j"],"instances":[],"language":{"extensions":["PatternGuards","Rank2Types","ScopedTypeVariables","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll"],"isInstance":false}}
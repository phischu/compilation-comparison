{"sliceID":1012628962775540426,"uses":[{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"take"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"drop"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"null"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"Text.Read"},"usedName":{"valueName":{"identifier":"read"}},"qualification":null},{"reference":{"builtinModule":"Data.Tuple"},"usedName":{"valueName":{"identifier":"fst"}},"qualification":null},{"reference":{"builtinModule":"GHC.Arr"},"usedName":{"valueName":{"operator":"!"}},"qualification":null},{"reference":{"otherSlice":7990091112320757662},"usedName":{"typeName":{"identifier":"MatchText"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"String"}},"qualification":null},{"reference":{"otherSlice":4283787102231565285},"usedName":{"valueName":{"identifier":"mkRegex"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"builtinModule":"Data.Tuple"},"usedName":{"valueName":{"identifier":"snd"}},"qualification":null},{"reference":{"otherSlice":5462232557626609601},"usedName":{"valueName":{"identifier":"matchAllText"}},"qualification":null},{"reference":{"otherSlice":6756606517105139295},"usedName":{"typeName":{"identifier":"Regex"}},"qualification":null}],"fragment":["subRegex :: Regex -> String -> String -> String","subRegex _ \"\" _ = \"\"\nsubRegex regexp inp repl\n  = let compile _i str [] = \\ _m -> (str ++)\n        compile i str ((\"\\\\\", (off, len)) : rest)\n          = let i' = off + len\n                pre = take (off - i) str\n                str' = drop (i' - i) str\n              in\n              if null str' then \\ _m -> (pre ++) . ('\\\\' :) else\n                \\ m -> (pre ++) . ('\\\\' :) . compile i' str' rest m\n        compile i str ((xstr, (off, len)) : rest)\n          = let i' = off + len\n                pre = take (off - i) str\n                str' = drop (i' - i) str\n                x = read xstr\n              in\n              if null str' then \\ m -> (pre ++) . ((fst (m ! x)) ++) else\n                \\ m -> (pre ++) . ((fst (m ! x)) ++) . compile i' str' rest m\n        \n        compiled :: MatchText String -> String -> String\n        compiled = compile 0 repl findrefs\n          where bre = mkRegex \"\\\\\\\\(\\\\\\\\|[0-9]+)\"\n                findrefs\n                  = map (\\ m -> (fst (m ! 1), snd (m ! 0))) (matchAllText bre repl)\n        go _i str [] = str\n        go i str (m : ms)\n          = let (_, (off, len)) = m ! 0\n                i' = off + len\n                pre = take (off - i) str\n                str' = drop (i' - i) str\n              in\n              if null str' then pre ++ (compiled m \"\") else\n                pre ++ (compiled m (go i' str' ms))\n      in go 0 inp (matchAllText regexp inp)"],"instances":[],"language":{"extensions":["MultiParamTypeClasses","FunctionalDependencies","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
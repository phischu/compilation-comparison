{"sliceID":6311340454252935725,"uses":[{"reference":{"otherSlice":1254073128444822395},"usedName":{"constructorName":{"identifier":"Stream"},"constructorTypeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":2120320550836080743},"usedName":{"constructorName":{"identifier":"Done"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"liftM"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":2120320550836080743},"usedName":{"constructorName":{"identifier":"Yield"},"constructorTypeName":{"identifier":"Step"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Monad"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":1254073128444822395},"usedName":{"typeName":{"identifier":"Stream"}},"qualification":null}],"fragment":["unfoldrNM ::\n            Monad m => Int -> (s -> m (Maybe (a, s))) -> s -> Stream m a","unfoldrNM m f t = Stream step (t, m)\n  where {-# INLINE [0] step #-}\n        step (s, n)\n          | n <= 0 = return Done\n          | otherwise =\n            liftM\n              (\\ r ->\n                 case r of\n                     Just (x, s') -> Yield x (s', n - 1)\n                     Nothing -> Done)\n              (f s)"],"instances":[],"language":{"extensions":["ExistentialQuantification","MultiParamTypeClasses","FlexibleInstances","Rank2Types","BangPatterns","KindSignatures","GADTs","ScopedTypeVariables","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
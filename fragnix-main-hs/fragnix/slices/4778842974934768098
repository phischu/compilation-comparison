{"sliceID":4778842974934768098,"uses":[{"reference":{"otherSlice":6140247046808343475},"usedName":{"valueName":{"identifier":"mkSource"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"otherSlice":484081683502405527},"usedName":{"valueName":{"identifier":"takeLine"}},"qualification":null},{"reference":{"otherSlice":2123356911951242787},"usedName":{"valueName":{"identifier":"takeLines"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"unless"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"null"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"lookup"}},"qualification":null},{"reference":{"otherSlice":4722091673123795757},"usedName":{"valueName":{"identifier":"parseAttrs"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"valueName":{"identifier":"fromMaybe"}},"qualification":null},{"reference":{"otherSlice":970670172681592095},"usedName":{"constructorName":{"identifier":"FileInfo"},"constructorTypeName":{"identifier":"FileInfo"}},"qualification":null},{"reference":{"otherSlice":783954534845988950},"usedName":{"valueName":{"identifier":"sinkTillBound'"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Right"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":970670172681592095},"usedName":{"valueName":{"identifier":"fileContent"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"when"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"id"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":4164730125724827689},"usedName":{"valueName":{"identifier":"sinkTillBound"}},"qualification":null},{"reference":{"otherSlice":8017170790354418478},"usedName":{"valueName":{"identifier":"concat"}},"qualification":"S"},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Left"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":8519534216426756697},"usedName":{"valueName":{"identifier":"pack"}},"qualification":"S8"},{"reference":{"otherSlice":1341631786159072772},"usedName":{"valueName":{"identifier":"breakDiscard"}},"qualification":null},{"reference":{"otherSlice":8651865326705395037},"usedName":{"valueName":{"identifier":"dropWhile"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":4175260859201958131},"usedName":{"typeName":{"identifier":"BackEnd"}},"qualification":null},{"reference":{"otherSlice":8642306666063513779},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"typeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":3233004973087392466},"usedName":{"typeName":{"identifier":"Param"}},"qualification":null},{"reference":{"otherSlice":1662716235212055960},"usedName":{"typeName":{"identifier":"File"}},"qualification":null}],"fragment":["parsePieces ::\n            BackEnd y ->\n              S.ByteString ->\n                IO S.ByteString -> (Either Param (File y) -> IO ()) -> IO ()","parsePieces sink bound rbody add = mkSource rbody >>= loop\n  where loop src\n          = do _boundLine <- takeLine src\n               res' <- takeLines src\n               unless (null res') $\n                 do let ls' = map parsePair res'\n                    let x = do cd <- lookup contDisp ls'\n                               let ct = lookup contType ls'\n                               let attrs = parseAttrs cd\n                               name <- lookup \"name\" attrs\n                               return (ct, name, lookup \"filename\" attrs)\n                    case x of\n                        Just (mct, name, Just filename) -> do let ct\n                                                                    = fromMaybe\n                                                                        \"application/octet-stream\"\n                                                                        mct\n                                                                  fi0 = FileInfo filename ct ()\n                                                              (wasFound, y) <- sinkTillBound' bound\n                                                                                 name\n                                                                                 fi0\n                                                                                 sink\n                                                                                 src\n                                                              add $\n                                                                Right (name, fi0{fileContent = y})\n                                                              when wasFound (loop src)\n                        Just (_ct, name, Nothing) -> do let seed = id\n                                                        let iter front bs = return $ front . (:) bs\n                                                        (wasFound, front) <- sinkTillBound bound\n                                                                               iter\n                                                                               seed\n                                                                               src\n                                                        let bs = S.concat $ front []\n                                                        let x' = (name, bs)\n                                                        add $ Left x'\n                                                        when wasFound (loop src)\n                        _ -> do let seed = ()\n                                    iter () _ = return ()\n                                (wasFound, ()) <- sinkTillBound bound iter seed src\n                                when wasFound (loop src)\n          where contDisp = S8.pack \"Content-Disposition\"\n                contType = S8.pack \"Content-Type\"\n                parsePair s\n                  = let (x, y) = breakDiscard 58 s in (x, S.dropWhile (== 32) y)"],"instances":[],"language":{"extensions":["OverloadedStrings","ExistentialQuantification","PatternGuards","TypeFamilies","RankNTypes","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll"],"isInstance":false}}
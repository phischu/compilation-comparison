{"sliceID":2651901972011620638,"uses":[{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"lookup"}},"qualification":null},{"reference":{"otherSlice":30758760526534613},"usedName":{"valueName":{"identifier":"requestHeaders"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>="}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<="}},"qualification":null},{"reference":{"otherSlice":30758760526534613},"usedName":{"valueName":{"identifier":"requestBody"}},"qualification":null},{"reference":{"otherSlice":675696118971413715},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S8"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"id"}},"qualification":null},{"reference":{"otherSlice":8220051201904867748},"usedName":{"valueName":{"identifier":"newIORef"}},"qualification":null},{"reference":{"otherSlice":1258346885303599072},"usedName":{"valueName":{"identifier":"atomicModifyIORef"}},"qualification":null},{"reference":{"otherSlice":2109377013281436257},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"S8"},{"reference":{"otherSlice":30758760526534613},"usedName":{"valueName":{"identifier":"requestMethod"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"elem"}},"qualification":null},{"reference":{"otherSlice":2071755692096765236},"usedName":{"valueName":{"identifier":"liftIO"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"otherSlice":30758760526534613},"usedName":{"valueName":{"identifier":"queryString"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"valueName":{"identifier":"fromMaybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"not"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"null"}},"qualification":null},{"reference":{"otherSlice":8519534216426756697},"usedName":{"valueName":{"identifier":"pack"}},"qualification":null},{"reference":{"builtinModule":"GHC.Show"},"usedName":{"valueName":{"identifier":"show"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":9097856661557912664},"usedName":{"constructorName":{"identifier":"White"},"constructorTypeName":{"identifier":"Color"}},"qualification":null},{"reference":{"builtinModule":"Data.Monoid"},"usedName":{"valueName":{"operator":"<>"}},"qualification":null},{"reference":{"builtinModule":"Data.Monoid"},"usedName":{"valueName":{"identifier":"mconcat"}},"qualification":null},{"reference":{"otherSlice":4509646242005640210},"usedName":{"valueName":{"identifier":"toLogStr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"otherSlice":30758760526534613},"usedName":{"valueName":{"identifier":"rawPathInfo"}},"qualification":null},{"reference":{"otherSlice":6940399698718426398},"usedName":{"valueName":{"identifier":"getCurrentTime"}},"qualification":null},{"reference":{"otherSlice":4388261176215324957},"usedName":{"constructorName":{"identifier":"ResponseRaw"},"constructorTypeName":{"identifier":"Response"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":8002792463244169660},"usedName":{"valueName":{"identifier":"statusBS"}},"qualification":null},{"reference":{"otherSlice":5145196201064323023},"usedName":{"valueName":{"identifier":"msgBS"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"unless"}},"qualification":null},{"reference":{"otherSlice":6491046430819758565},"usedName":{"valueName":{"identifier":"diffUTCTime"}},"qualification":null},{"reference":{"otherSlice":2682330660079479991},"usedName":{"valueName":{"identifier":"getRequestBodyType"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":3323440499482804747},"usedName":{"valueName":{"identifier":"sinkRequestBody"}},"qualification":null},{"reference":{"otherSlice":464070898076031284},"usedName":{"valueName":{"identifier":"lbsBackEnd"}},"qualification":null},{"reference":{"otherSlice":8642306666063513779},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"BS"},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":3233004973087392466},"usedName":{"typeName":{"identifier":"Param"}},"qualification":null},{"reference":{"otherSlice":1662716235212055960},"usedName":{"typeName":{"identifier":"File"}},"qualification":null},{"reference":{"otherSlice":1699226608098321587},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"LBS"},{"reference":{"otherSlice":970670172681592095},"usedName":{"valueName":{"identifier":"fileName"}},"qualification":null},{"reference":{"builtinModule":"Text.Read"},"usedName":{"valueName":{"identifier":"reads"}},"qualification":null},{"reference":{"otherSlice":1940791894936628658},"usedName":{"valueName":{"identifier":"unpack"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"otherSlice":8400547262960430667},"usedName":{"typeName":{"identifier":"Callback"}},"qualification":null},{"reference":{"otherSlice":9097856661557912664},"usedName":{"typeName":{"identifier":"Color"}},"qualification":null},{"reference":{"otherSlice":3389037324188664509},"usedName":{"typeName":{"identifier":"Middleware"}},"qualification":null}],"fragment":["detailedMiddleware' ::\n                    Callback ->\n                      (Color -> BS.ByteString -> [BS.ByteString]) ->\n                        (BS.ByteString -> [BS.ByteString]) ->\n                          (BS.ByteString -> BS.ByteString -> [BS.ByteString]) -> Middleware","detailedMiddleware' cb ansiColor ansiMethod ansiStatusCode app req\n  sendResponse\n  = do let mlen\n             = lookup \"content-length\" (requestHeaders req) >>= readInt\n       (req', body) <- case mlen of\n                           Just len | len <= 2048 ->\n                                      do let loop front\n                                               = do bs <- requestBody req\n                                                    if S8.null bs then return $ front [] else\n                                                      loop $ front . (bs :)\n                                         body <- loop id\n                                         ichunks <- newIORef body\n                                         let rbody\n                                               = atomicModifyIORef ichunks $\n                                                   \\ chunks ->\n                                                     case chunks of\n                                                         [] -> ([], S8.empty)\n                                                         x : y -> (y, x)\n                                         let req' = req{requestBody = rbody}\n                                         return (req', body)\n                           _ -> return (req, [])\n       postParams <- if requestMethod req `elem` [\"GET\", \"HEAD\"] then\n                       return [] else\n                       do postParams <- liftIO $ allPostParams body\n                          return $ collectPostParams postParams\n       let getParams = map emptyGetParam $ queryString req\n           accept = fromMaybe \"\" $ lookup \"Accept\" $ requestHeaders req\n           params\n             = let par\n                     | not $ null postParams = [pack (show postParams)]\n                     | not $ null getParams = [pack (show getParams)]\n                     | otherwise = []\n                 in\n                 if null par then [\"\"] else\n                   ansiColor White \"  Params: \" <> par <> [\"\\n\"]\n       liftIO $\n         cb $\n           mconcat $\n             map toLogStr $\n               ansiMethod (requestMethod req) ++\n                 [\" \", rawPathInfo req, \"\\n\"] ++\n                   params ++ ansiColor White \"  Accept: \" ++ [accept, \"\\n\"]\n       t0 <- getCurrentTime\n       app req' $\n         \\ rsp ->\n           do let isRaw\n                    = case rsp of\n                          ResponseRaw{} -> True\n                          _ -> False\n                  stCode = statusBS rsp\n                  stMsg = msgBS rsp\n              t1 <- getCurrentTime\n              unless isRaw $\n                cb $\n                  mconcat $\n                    map toLogStr $\n                      ansiColor White \"  Status: \" ++\n                        ansiStatusCode stCode (stCode <> \" \" <> stMsg) ++\n                          [\" \", pack $ show $ diffUTCTime t1 t0, \"\\n\"]\n              sendResponse rsp\n  where allPostParams body\n          = case getRequestBodyType req of\n                Nothing -> return ([], [])\n                Just rbt -> do ichunks <- newIORef body\n                               let rbody\n                                     = atomicModifyIORef ichunks $\n                                         \\ chunks ->\n                                           case chunks of\n                                               [] -> ([], S8.empty)\n                                               x : y -> (y, x)\n                               sinkRequestBody lbsBackEnd rbt rbody\n        \n        emptyGetParam ::\n                      (BS.ByteString, Maybe BS.ByteString) ->\n                        (BS.ByteString, BS.ByteString)\n        emptyGetParam (k, Just v) = (k, v)\n        emptyGetParam (k, Nothing) = (k, \"\")\n        \n        collectPostParams :: ([Param], [File LBS.ByteString]) -> [Param]\n        collectPostParams (postParams, files)\n          = postParams ++ map (\\ (k, v) -> (k, \"FILE: \" <> fileName v)) files\n        readInt bs\n          = case reads $ unpack bs of\n                (i, _) : _ -> Just (i :: Int)\n                [] -> Nothing"],"instances":[],"language":{"extensions":["OverloadedStrings","RecordWildCards","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
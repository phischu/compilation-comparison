{"sliceID":600845713027802444,"uses":[{"reference":{"otherSlice":6766449275992946084},"usedName":{"constructorName":{"identifier":"Builder"},"constructorTypeName":{"identifier":"Builder"}},"qualification":null},{"reference":{"otherSlice":4225927731506146159},"usedName":{"valueName":{"identifier":"fromBuildStepCont"}},"qualification":null},{"reference":{"otherSlice":2921932848836490295},"usedName":{"constructorName":{"identifier":"BufRange"},"constructorTypeName":{"identifier":"BufRange"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":3030113937244366044},"usedName":{"constructorName":{"identifier":"Done"},"constructorTypeName":{"identifier":"BuildSignal"}},"qualification":null},{"reference":{"otherSlice":2931540031717686030},"usedName":{"valueName":{"identifier":"buildStep"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":2719835477628140216},"usedName":{"valueName":{"identifier":"bufferFull"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"plusPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"typeName":{"identifier":"Ptr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Word"},"usedName":{"typeName":{"identifier":"Word8"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"otherSlice":3030113937244366044},"usedName":{"typeName":{"identifier":"BuildSignal"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":4463318904864233348},"usedName":{"valueName":{"identifier":"pokeWord32HexN"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"minusPtr"}},"qualification":null},{"reference":{"otherSlice":4309570904732863147},"usedName":{"valueName":{"identifier":"execWrite"}},"qualification":null},{"reference":{"otherSlice":1568278181019096456},"usedName":{"valueName":{"identifier":"writeCRLF"}},"qualification":null},{"reference":{"otherSlice":3030113937244366044},"usedName":{"valueName":{"identifier":"runBuildStep"}},"qualification":null},{"reference":{"otherSlice":3030113937244366044},"usedName":{"constructorName":{"identifier":"BufferFull"},"constructorTypeName":{"identifier":"BuildSignal"}},"qualification":null},{"reference":{"builtinModule":"Prelude"},"usedName":{"valueName":{"operator":"$!"}},"qualification":null},{"reference":{"otherSlice":3030113937244366044},"usedName":{"constructorName":{"identifier":"InsertByteString"},"constructorTypeName":{"identifier":"BuildSignal"}},"qualification":null},{"reference":{"otherSlice":675696118971413715},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"otherSlice":8787400331237908198},"usedName":{"valueName":{"identifier":"insertByteString"}},"qualification":null},{"reference":{"otherSlice":2109377013281436257},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"S"},{"reference":{"otherSlice":8627977680109043678},"usedName":{"valueName":{"identifier":"runPoke"}},"qualification":null},{"reference":{"otherSlice":8272375223631285915},"usedName":{"valueName":{"identifier":"getPoke"}},"qualification":null},{"reference":{"otherSlice":1739721691356598213},"usedName":{"valueName":{"identifier":"writeWord32Hex"}},"qualification":null},{"reference":{"otherSlice":6258463563638113276},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"builtinModule":"Data.Monoid"},"usedName":{"valueName":{"identifier":"mappend"}},"qualification":null},{"reference":{"otherSlice":6766449275992946084},"usedName":{"valueName":{"identifier":"unBuilder"}},"qualification":null},{"reference":{"otherSlice":4999886305526563029},"usedName":{"valueName":{"identifier":"fromWrite"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Storable"},"usedName":{"valueName":{"identifier":"sizeOf"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"undefined"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"otherSlice":8300436289802481375},"usedName":{"valueName":{"identifier":"word32HexLength"}},"qualification":null},{"reference":{"otherSlice":6766449275992946084},"usedName":{"typeName":{"identifier":"Builder"}},"qualification":null}],"fragment":["chunkedTransferEncoding :: Builder -> Builder","chunkedTransferEncoding (Builder b)\n  = fromBuildStepCont transferEncodingStep\n  where finalStep !(BufRange op _) = return $ Done op ()\n        transferEncodingStep k = go (b (buildStep finalStep))\n          where go innerStep !(BufRange op ope)\n                  | outRemaining < minimalBufferSize =\n                    return $ bufferFull minimalBufferSize op (go innerStep)\n                  | otherwise =\n                    do let !brInner@(BufRange opInner _)\n                             = BufRange (op `plusPtr` (chunkSizeLength + 2))\n                                 (ope `plusPtr` (-maxAfterBufferOverhead))\n                           {-# INLINE wrapChunk #-}\n                           wrapChunk ::\n                                     Ptr Word8 ->\n                                       (Ptr Word8 -> IO (BuildSignal a)) -> IO (BuildSignal a)\n                           wrapChunk !opInner' mkSignal\n                             | opInner' == opInner = mkSignal op\n                             | otherwise =\n                               do pokeWord32HexN chunkSizeLength\n                                    (fromIntegral $ opInner' `minusPtr` opInner)\n                                    op\n                                  execWrite writeCRLF (opInner `plusPtr` (-2))\n                                  execWrite writeCRLF opInner'\n                                  mkSignal (opInner' `plusPtr` 2)\n                       signal <- runBuildStep innerStep brInner\n                       case signal of\n                           Done opInner' _ -> wrapChunk opInner' $\n                                                \\ op' ->\n                                                  do let !br' = BufRange op' ope\n                                                     k br'\n                           BufferFull minRequiredSize opInner' nextInnerStep -> wrapChunk\n                                                                                  opInner'\n                                                                                  $\n                                                                                  \\ op' ->\n                                                                                    return $!\n                                                                                      bufferFull\n                                                                                        (minRequiredSize\n                                                                                           +\n                                                                                           maxEncodingOverhead)\n                                                                                        op'\n                                                                                        (go\n                                                                                           nextInnerStep)\n                           InsertByteString opInner' bs nextInnerStep | S.null bs ->\n                                                                        wrapChunk opInner' $\n                                                                          \\ op' ->\n                                                                            return $!\n                                                                              insertByteString op'\n                                                                                S.empty\n                                                                                (go nextInnerStep)\n                                                                      | otherwise ->\n                                                                        wrapChunk opInner' $\n                                                                          \\ op' ->\n                                                                            do !op'' <- (`runPoke` op')\n                                                                                          $\n                                                                                          getPoke $\n                                                                                            writeWord32Hex\n                                                                                              (fromIntegral\n                                                                                                 $\n                                                                                                 S.length\n                                                                                                   bs)\n                                                                                              `mappend`\n                                                                                              writeCRLF\n                                                                               return $!\n                                                                                 InsertByteString\n                                                                                   op''\n                                                                                   bs\n                                                                                   (unBuilder\n                                                                                      (fromWrite\n                                                                                         writeCRLF)\n                                                                                      $\n                                                                                      buildStep $\n                                                                                        go\n                                                                                          nextInnerStep)\n                  where minimalChunkSize = 1\n                        maxBeforeBufferOverhead = sizeOf (undefined :: Int) + 2\n                        maxAfterBufferOverhead = 2 + sizeOf (undefined :: Int) + 2\n                        maxEncodingOverhead\n                          = maxBeforeBufferOverhead + maxAfterBufferOverhead\n                        minimalBufferSize = minimalChunkSize + maxEncodingOverhead\n                        \n                        outRemaining :: Int\n                        outRemaining = ope `minusPtr` op\n                        chunkSizeLength = word32HexLength $ fromIntegral outRemaining"],"instances":[],"language":{"extensions":["BangPatterns","MagicHash","OverloadedStrings","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
{"sliceID":8077012809669053906,"uses":[{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Marshal.Alloc"},"usedName":{"valueName":{"identifier":"allocaBytes"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"divMod"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Storable"},"usedName":{"valueName":{"identifier":"pokeByteOff"}},"qualification":null},{"reference":{"otherSlice":7203131010857071920},"usedName":{"valueName":{"identifier":"c_nanosleep"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"Foreign.C.Error"},"usedName":{"valueName":{"identifier":"getErrno"}},"qualification":null},{"reference":{"builtinModule":"Foreign.C.Error"},"usedName":{"valueName":{"identifier":"eINTR"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Storable"},"usedName":{"valueName":{"identifier":"peekByteOff"}},"qualification":null},{"reference":{"builtinModule":"Foreign.C.Error"},"usedName":{"valueName":{"identifier":"throwErrno"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"Foreign.C.Types"},"usedName":{"typeName":{"identifier":"CTime"}},"qualification":null},{"reference":{"builtinModule":"GHC.Integer"},"usedName":{"typeName":{"identifier":"Integer"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null}],"fragment":["nanosleep :: Integer -> IO ()","nanosleep 0 = return ()\nnanosleep nsecs\n  = do allocaBytes (16) $\n         \\ pts1 ->\n           do allocaBytes (16) $\n                \\ pts2 ->\n                  do let (tv_sec0, tv_nsec0) = nsecs `divMod` 1000000000\n                     let loop tv_sec tv_nsec\n                           = do ((\\ hsc_ptr -> pokeByteOff hsc_ptr 0)) pts1 tv_sec\n                                ((\\ hsc_ptr -> pokeByteOff hsc_ptr 8)) pts1 tv_nsec\n                                res <- c_nanosleep pts1 pts2\n                                if res == 0 then return () else\n                                  do errno <- getErrno\n                                     if errno == eINTR then\n                                       do tv_sec' <- ((\\ hsc_ptr -> peekByteOff hsc_ptr 0)) pts2\n                                          tv_nsec' <- ((\\ hsc_ptr -> peekByteOff hsc_ptr 8)) pts2\n                                          loop tv_sec' tv_nsec'\n                                       else throwErrno \"nanosleep\"\n                     loop (fromIntegral tv_sec0 :: CTime)\n                       (fromIntegral tv_nsec0 :: CTime)"],"instances":[],"language":{"extensions":["CApiFFI","NondecreasingIndentation","MultiParamTypeClasses","ExplicitForAll","PatternGuards"],"isInstance":false}}
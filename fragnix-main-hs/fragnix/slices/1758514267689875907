{"sliceID":1758514267689875907,"uses":[{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"identifier":"fromInteger"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"otherSlice":997032288423013583},"usedName":{"valueName":{"identifier":"logArr"}},"qualification":null},{"reference":{"otherSlice":3191844957948247487},"usedName":{"valueName":{"identifier":"unsafeAt"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"quot"}},"qualification":null},{"reference":{"otherSlice":9216628763923603710},"usedName":{"valueName":{"identifier":"integerPower"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"identifier":"shiftR"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":7904913984523605853},"usedName":{"valueName":{"identifier":"integerLog2'"}},"qualification":null},{"reference":{"builtinModule":"GHC.Integer.GMP.Internals"},"usedName":{"typeName":{"identifier":"Integer"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null}],"fragment":["integerLogBase' :: Integer -> Integer -> Int","integerLogBase' b n\n  | n < b = 0\n  | ln - lb < lb = 1\n  | b < 33 =\n    let bi = fromInteger b\n        ix = 2 * bi - 4\n        u = logArr `unsafeAt` ix\n        v = logArr `unsafeAt` (ix + 1)\n        ex\n          = fromInteger\n              ((fromIntegral u * fromIntegral ln) `quot` fromIntegral v)\n      in\n      case u of\n          1 -> ln `quot` v\n          _ -> ex + integerLogBase' b (n `quot` integerPower b ex)\n  | otherwise =\n    let bi = fromInteger (b `shiftR` (lb - 4))\n        ix = 2 * bi - 2\n        u = fromIntegral $ logArr `unsafeAt` ix\n        v = fromIntegral $ logArr `unsafeAt` (ix + 1)\n        w = v + u * fromIntegral (lb - 4)\n        ex = fromInteger ((u * fromIntegral ln) `quot` w)\n      in ex + integerLogBase' b (n `quot` integerPower b ex)\n  where lb = integerLog2' b\n        ln = integerLog2' n"],"instances":[],"language":{"extensions":["MagicHash","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
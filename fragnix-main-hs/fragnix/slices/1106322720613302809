{"sliceID":1106322720613302809,"uses":[{"reference":{"otherSlice":842708811867993973},"usedName":{"constructorName":{"identifier":"CSource"},"constructorTypeName":{"identifier":"CSource"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"readIORef"}},"qualification":"I"},{"reference":{"otherSlice":3896990514858613071},"usedName":{"valueName":{"identifier":"leftoverSource"}},"qualification":null},{"reference":{"otherSlice":2109377013281436257},"usedName":{"valueName":{"identifier":"empty"}},"qualification":"S"},{"reference":{"otherSlice":5820411320716764055},"usedName":{"constructorName":{"identifier":"DoneChunking"},"constructorTypeName":{"identifier":"ChunkState"}},"qualification":null},{"reference":{"otherSlice":675696118971413715},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"writeIORef"}},"qualification":"I"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":6258463563638113276},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"compare"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"EQ"},"constructorTypeName":{"identifier":"Ordering"}},"qualification":null},{"reference":{"otherSlice":5820411320716764055},"usedName":{"constructorName":{"identifier":"NeedLenNewline"},"constructorTypeName":{"identifier":"ChunkState"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"LT"},"constructorTypeName":{"identifier":"Ordering"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":5820411320716764055},"usedName":{"constructorName":{"identifier":"HaveLen"},"constructorTypeName":{"identifier":"ChunkState"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"GT"},"constructorTypeName":{"identifier":"Ordering"}},"qualification":null},{"reference":{"otherSlice":3674330957874520992},"usedName":{"valueName":{"identifier":"splitAt"}},"qualification":"S"},{"reference":{"otherSlice":4434023532649325206},"usedName":{"valueName":{"identifier":"readSource"}},"qualification":null},{"reference":{"otherSlice":8556082736304368763},"usedName":{"valueName":{"identifier":"uncons"}},"qualification":"S"},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":2238155074880201616},"usedName":{"valueName":{"identifier":"readSource'"}},"qualification":null},{"reference":{"builtinModule":"Control.Monad"},"usedName":{"valueName":{"identifier":"unless"}},"qualification":null},{"reference":{"otherSlice":5820411320716764055},"usedName":{"constructorName":{"identifier":"NeedLen"},"constructorTypeName":{"identifier":"ChunkState"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":">>"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"assert"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":7389831803702733683},"usedName":{"valueName":{"identifier":"breakByte"}},"qualification":"S"},{"reference":{"otherSlice":1524283775147600600},"usedName":{"valueName":{"identifier":"append"}},"qualification":"S"},{"reference":{"otherSlice":4826645999871818821},"usedName":{"valueName":{"identifier":"foldl'"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":7112072859998831005},"usedName":{"valueName":{"identifier":"takeWhile"}},"qualification":"S"},{"reference":{"otherSlice":3438909673328875310},"usedName":{"valueName":{"identifier":"isHexDigit"}},"qualification":null},{"reference":{"otherSlice":6985366053944096403},"usedName":{"valueName":{"identifier":"drop"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":842708811867993973},"usedName":{"typeName":{"identifier":"CSource"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"otherSlice":8642306666063513779},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":null}],"fragment":["readCSource :: CSource -> IO ByteString","readCSource (CSource src ref)\n  = do mlen <- I.readIORef ref\n       go mlen\n  where withLen 0 bs\n          = do leftoverSource src bs\n               dropCRLF\n               yield' S.empty DoneChunking\n        withLen len bs\n          | S.null bs =\n            do I.writeIORef ref DoneChunking\n               return S.empty\n          | otherwise =\n            case S.length bs `compare` fromIntegral len of\n                EQ -> yield' bs NeedLenNewline\n                LT -> yield' bs $ HaveLen $ len - fromIntegral (S.length bs)\n                GT -> do let (x, y) = S.splitAt (fromIntegral len) bs\n                         leftoverSource src y\n                         yield' x NeedLenNewline\n        yield' bs mlen\n          = do I.writeIORef ref mlen\n               return bs\n        dropCRLF\n          = do bs <- readSource src\n               case S.uncons bs of\n                   Nothing -> return ()\n                   Just (13, bs') -> dropLF bs'\n                   Just (10, bs') -> leftoverSource src bs'\n                   Just _ -> leftoverSource src bs\n        dropLF bs\n          = case S.uncons bs of\n                Nothing -> do bs2 <- readSource' src\n                              unless (S.null bs2) $ dropLF bs2\n                Just (10, bs') -> leftoverSource src bs'\n                Just _ -> leftoverSource src bs\n        go NeedLen = getLen\n        go NeedLenNewline = dropCRLF >> getLen\n        go (HaveLen 0)\n          = do dropCRLF\n               I.writeIORef ref DoneChunking\n               return S.empty\n        go (HaveLen len)\n          = do bs <- readSource src\n               withLen len bs\n        go DoneChunking = return S.empty\n        getLen\n          = do bs <- readSource src\n               if S.null bs then\n                 do I.writeIORef ref $ assert False $ HaveLen 0\n                    return S.empty\n                 else\n                 do (x, y) <- case S.breakByte 10 bs of\n                                  (x, y) | S.null y ->\n                                           do bs2 <- readSource' src\n                                              return $\n                                                if S.null bs2 then (x, y) else\n                                                  S.breakByte 10 $ bs `S.append` bs2\n                                         | otherwise -> return (x, y)\n                    let w = S.foldl' (\\ i c -> i * 16 + fromIntegral (hexToWord c)) 0 $\n                              S.takeWhile isHexDigit x\n                    let y' = S.drop 1 y\n                    y'' <- if S.null y' then readSource src else return y'\n                    withLen w y''\n        hexToWord w\n          | w < 58 = w - 48\n          | w < 71 = w - 55\n          | otherwise = w - 87"],"instances":[],"language":{"extensions":["MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
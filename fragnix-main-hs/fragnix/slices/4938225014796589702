{"sliceID":4938225014796589702,"uses":[{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"operator":"<$>"}},"qualification":null},{"reference":{"otherSlice":7827604926602876518},"usedName":{"valueName":{"identifier":"satisfy"}},"qualification":"I"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"||"}},"qualification":null},{"reference":{"builtinModule":"Control.Applicative"},"usedName":{"valueName":{"operator":"<|>"}},"qualification":null},{"reference":{"builtinModule":"Control.Applicative"},"usedName":{"valueName":{"identifier":"pure"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":6426296527945267756},"usedName":{"valueName":{"identifier":"decimal"}},"qualification":null},{"reference":{"otherSlice":5142355219508967982},"usedName":{"constructorName":{"identifier":"SP"},"constructorTypeName":{"identifier":"SP"}},"qualification":null},{"reference":{"otherSlice":9172574327038568965},"usedName":{"valueName":{"identifier":"foldl'"}},"qualification":"T"},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"identifier":"negate"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":3696497047475397211},"usedName":{"valueName":{"identifier":"length"}},"qualification":"T"},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"ord"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"Control.Applicative"},"usedName":{"valueName":{"operator":"*>"}},"qualification":null},{"reference":{"otherSlice":1655761226116046540},"usedName":{"valueName":{"identifier":"takeWhile"}},"qualification":"I"},{"reference":{"builtinModule":"GHC.Unicode"},"usedName":{"valueName":{"identifier":"isDigit"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"fmap"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":2794777964408613631},"usedName":{"valueName":{"identifier":"scientific"}},"qualification":"Sci"},{"reference":{"otherSlice":2695017408180040498},"usedName":{"valueName":{"identifier":"signed"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":655943511058533134},"usedName":{"typeName":{"identifier":"Scientific"}},"qualification":null},{"reference":{"otherSlice":1318512042216165404},"usedName":{"typeName":{"identifier":"Parser"}},"qualification":null}],"fragment":["scientifically :: (Scientific -> a) -> Parser a","scientifically h\n  = do !positive <- ((== '+') <$>\n                       I.satisfy (\\ c -> c == '-' || c == '+'))\n                      <|> pure True\n       n <- decimal\n       let f fracDigits\n             = SP (T.foldl' step n fracDigits) (negate $ T.length fracDigits)\n           step a c = a * 10 + fromIntegral (ord c - 48)\n       SP c e <- (I.satisfy (== '.') *> (f <$> I.takeWhile isDigit)) <|>\n                   pure (SP n 0)\n       let !signedCoeff\n             | positive = c\n             | otherwise = -c\n       (I.satisfy (\\ w -> w == 'e' || w == 'E') *>\n          fmap (h . Sci.scientific signedCoeff . (e +)) (signed decimal))\n         <|> return (h $ Sci.scientific signedCoeff e)"],"instances":[],"language":{"extensions":["BangPatterns","FlexibleInstances","TypeSynonymInstances","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
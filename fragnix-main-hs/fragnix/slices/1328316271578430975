{"sliceID":1328316271578430975,"uses":[{"reference":{"otherSlice":9208044541903137161},"usedName":{"constructorName":{"identifier":"Seq"},"constructorTypeName":{"identifier":"Seq"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"otherSlice":3555949835188142327},"usedName":{"typeName":{"identifier":"Elem"}},"qualification":null},{"reference":{"builtinModule":"GHC.Prim"},"usedName":{"valueName":{"identifier":"coerce"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Monoid"}},"qualification":null},{"reference":{"otherSlice":2103754850612341338},"usedName":{"typeName":{"identifier":"FingerTree"}},"qualification":null},{"reference":{"otherSlice":2103754850612341338},"usedName":{"constructorName":{"identifier":"EmptyT"},"constructorTypeName":{"identifier":"FingerTree"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"mempty"}},"qualification":null},{"reference":{"otherSlice":2103754850612341338},"usedName":{"constructorName":{"identifier":"Single"},"constructorTypeName":{"identifier":"FingerTree"}},"qualification":null},{"reference":{"otherSlice":2103754850612341338},"usedName":{"constructorName":{"identifier":"Deep"},"constructorTypeName":{"identifier":"FingerTree"}},"qualification":null},{"reference":{"otherSlice":3221098851026216459},"usedName":{"valueName":{"operator":"<>"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":2658389187921074114},"usedName":{"valueName":{"identifier":"size"}},"qualification":null},{"reference":{"otherSlice":1673753023314990609},"usedName":{"typeName":{"identifier":"Node"}},"qualification":null},{"reference":{"otherSlice":6856618864151171204},"usedName":{"typeName":{"identifier":"Digit"}},"qualification":null},{"reference":{"otherSlice":2658389187921074114},"usedName":{"typeName":{"identifier":"Sized"}},"qualification":null},{"reference":{"otherSlice":6856618864151171204},"usedName":{"constructorName":{"identifier":"One"},"constructorTypeName":{"identifier":"Digit"}},"qualification":null},{"reference":{"otherSlice":6856618864151171204},"usedName":{"constructorName":{"identifier":"Two"},"constructorTypeName":{"identifier":"Digit"}},"qualification":null},{"reference":{"otherSlice":6856618864151171204},"usedName":{"constructorName":{"identifier":"Three"},"constructorTypeName":{"identifier":"Digit"}},"qualification":null},{"reference":{"otherSlice":6856618864151171204},"usedName":{"constructorName":{"identifier":"Four"},"constructorTypeName":{"identifier":"Digit"}},"qualification":null},{"reference":{"otherSlice":1673753023314990609},"usedName":{"constructorName":{"identifier":"Node2"},"constructorTypeName":{"identifier":"Node"}},"qualification":null},{"reference":{"otherSlice":1673753023314990609},"usedName":{"constructorName":{"identifier":"Node3"},"constructorTypeName":{"identifier":"Node"}},"qualification":null},{"reference":{"otherSlice":9208044541903137161},"usedName":{"typeName":{"identifier":"Seq"}},"qualification":null},{"reference":{"otherSlice":3555949835188142327},"usedName":{"constructorName":{"identifier":"Elem"},"constructorTypeName":{"identifier":"Elem"}},"qualification":null}],"fragment":["foldMapWithIndex :: Monoid m => (Int -> a -> m) -> Seq a -> m","foldMapWithIndex f' (Seq xs')\n  = foldMapWithIndexTreeE (lift_elem f') 0 xs'\n  where lift_elem :: (Int -> a -> m) -> (Int -> Elem a -> m)\n        lift_elem g = coerce g\n        \n        {-# INLINE lift_elem #-}\n        \n        foldMapWithIndexTreeE ::\n                                Monoid m => (Int -> Elem a -> m) -> Int -> FingerTree (Elem a) -> m\n        foldMapWithIndexTreeE _ !_s EmptyT = mempty\n        foldMapWithIndexTreeE f s (Single xs) = f s xs\n        foldMapWithIndexTreeE f s (Deep _ pr m sf)\n          = foldMapWithIndexDigitE f s pr <>\n              foldMapWithIndexTreeN (foldMapWithIndexNodeE f) sPspr m <>\n                foldMapWithIndexDigitE f sPsprm sf\n          where !sPspr = s + size pr\n                !sPsprm = sPspr + size m\n        \n        foldMapWithIndexTreeN ::\n                                Monoid m => (Int -> Node a -> m) -> Int -> FingerTree (Node a) -> m\n        foldMapWithIndexTreeN _ !_s EmptyT = mempty\n        foldMapWithIndexTreeN f s (Single xs) = f s xs\n        foldMapWithIndexTreeN f s (Deep _ pr m sf)\n          = foldMapWithIndexDigitN f s pr <>\n              foldMapWithIndexTreeN (foldMapWithIndexNodeN f) sPspr m <>\n                foldMapWithIndexDigitN f sPsprm sf\n          where !sPspr = s + size pr\n                !sPsprm = sPspr + size m\n        \n        foldMapWithIndexDigitE ::\n                                 Monoid m => (Int -> Elem a -> m) -> Int -> Digit (Elem a) -> m\n        foldMapWithIndexDigitE f i t = foldMapWithIndexDigit f i t\n        \n        foldMapWithIndexDigitN ::\n                                 Monoid m => (Int -> Node a -> m) -> Int -> Digit (Node a) -> m\n        foldMapWithIndexDigitN f i t = foldMapWithIndexDigit f i t\n        \n        {-# INLINE foldMapWithIndexDigit #-}\n        \n        foldMapWithIndexDigit ::\n                                (Monoid m, Sized a) => (Int -> a -> m) -> Int -> Digit a -> m\n        foldMapWithIndexDigit f !s (One a) = f s a\n        foldMapWithIndexDigit f s (Two a b) = f s a <> f sPsa b\n          where !sPsa = s + size a\n        foldMapWithIndexDigit f s (Three a b c)\n          = f s a <> f sPsa b <> f sPsab c\n          where !sPsa = s + size a\n                !sPsab = sPsa + size b\n        foldMapWithIndexDigit f s (Four a b c d)\n          = f s a <> f sPsa b <> f sPsab c <> f sPsabc d\n          where !sPsa = s + size a\n                !sPsab = sPsa + size b\n                !sPsabc = sPsab + size c\n        \n        foldMapWithIndexNodeE ::\n                                Monoid m => (Int -> Elem a -> m) -> Int -> Node (Elem a) -> m\n        foldMapWithIndexNodeE f i t = foldMapWithIndexNode f i t\n        \n        foldMapWithIndexNodeN ::\n                                Monoid m => (Int -> Node a -> m) -> Int -> Node (Node a) -> m\n        foldMapWithIndexNodeN f i t = foldMapWithIndexNode f i t\n        \n        {-# INLINE foldMapWithIndexNode #-}\n        \n        foldMapWithIndexNode ::\n                               (Monoid m, Sized a) => (Int -> a -> m) -> Int -> Node a -> m\n        foldMapWithIndexNode f !s (Node2 _ a b) = f s a <> f sPsa b\n          where !sPsa = s + size a\n        foldMapWithIndexNode f s (Node3 _ a b c)\n          = f s a <> f sPsa b <> f sPsab c\n          where !sPsa = s + size a\n                !sPsab = sPsa + size b"],"instances":[],"language":{"extensions":["BangPatterns","DeriveDataTypeable","StandaloneDeriving","FlexibleInstances","ScopedTypeVariables","DeriveGeneric","TypeFamilies","PatternSynonyms","ViewPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
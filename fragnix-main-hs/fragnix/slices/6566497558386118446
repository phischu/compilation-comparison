{"sliceID":6566497558386118446,"uses":[{"reference":{"otherSlice":4010822550476529195},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"},{"reference":{"otherSlice":7375684867847713962},"usedName":{"valueName":{"identifier":"break"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"id"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":3748312495235440417},"usedName":{"valueName":{"identifier":"drop"}},"qualification":"S"},{"reference":{"otherSlice":7202692338078551997},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":7334742665858401074},"usedName":{"valueName":{"identifier":"dropWhile"}},"qualification":"S"},{"reference":{"builtinModule":"Data.Tuple"},"usedName":{"valueName":{"identifier":"fst"}},"qualification":null},{"reference":{"otherSlice":3997942884358528428},"usedName":{"valueName":{"identifier":"breakEnd"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"/="}},"qualification":null}],"fragment":["parseContentType ::\n                 S.ByteString -> (S.ByteString, [(S.ByteString, S.ByteString)])","parseContentType a\n  = do let (ctype, b) = S.break (== semicolon) a\n           attrs = goAttrs id $ S.drop 1 b\n         in (ctype, attrs)\n  where semicolon = 59\n        equals = 61\n        space = 32\n        goAttrs front bs\n          | S.null bs = front []\n          | otherwise =\n            let (x, rest) = S.break (== semicolon) bs in\n              goAttrs (front . (goAttr x :)) $ S.drop 1 rest\n        goAttr bs\n          = let (k, v') = S.break (== equals) bs\n                v = S.drop 1 v'\n              in (strip k, strip v)\n        strip = S.dropWhile (== space) . fst . S.breakEnd (/= space)"],"instances":[],"language":{"extensions":["OverloadedStrings","ExistentialQuantification","PatternGuards","TypeFamilies","RankNTypes","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll"],"isInstance":false}}
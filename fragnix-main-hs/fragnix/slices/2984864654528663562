{"sliceID":2984864654528663562,"uses":[{"reference":{"otherSlice":675696118971413715},"usedName":{"valueName":{"identifier":"null"}},"qualification":"S"},{"reference":{"otherSlice":6258463563638113276},"usedName":{"valueName":{"identifier":"length"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":667237810833597684},"usedName":{"valueName":{"identifier":"head"}},"qualification":"S"},{"reference":{"otherSlice":6575862329792134764},"usedName":{"valueName":{"identifier":"elemIndices"}},"qualification":"S"},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":3093287715237579077},"usedName":{"valueName":{"identifier":"take"}},"qualification":"S"},{"reference":{"otherSlice":6985366053944096403},"usedName":{"valueName":{"identifier":"drop"}},"qualification":"S"},{"reference":{"otherSlice":206598715147514767},"usedName":{"valueName":{"identifier":"automaton"}},"qualification":null},{"reference":{"otherSlice":7420251549451097395},"usedName":{"valueName":{"identifier":"unsafeIndex"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"foldr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"flip"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"id"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":5036397791054469605},"usedName":{"valueName":{"identifier":"keep"}},"qualification":null},{"reference":{"otherSlice":958675940120742873},"usedName":{"valueName":{"identifier":"unsafeAt"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"identifier":"shiftL"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":7797195051772689959},"usedName":{"valueName":{"identifier":"rgo"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":8642306666063513779},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":"S"}],"fragment":["lazyBreaker ::\n            Bool ->\n              S.ByteString -> [S.ByteString] -> ([S.ByteString], [S.ByteString])","lazyBreaker before pat\n  | S.null pat = \\ strs -> ([], strs)\n  | S.length pat == 1 =\n    let !w = S.head pat\n        !a = if before then 0 else 1\n        ixes = S.elemIndices w\n        scan [] = ([], [])\n        scan (!(str : rest))\n          = let !strLen = S.length str in\n              case ixes str of\n                  [] -> let (fr, bk) = scan rest in (str : fr, bk)\n                  (i : _) -> let !j = i + a in\n                               if j == strLen then ([str], rest) else\n                                 ([S.take j str], S.drop j str : rest)\n      in scan\nlazyBreaker !before pat = bscan [] 0\n  where !patLen = S.length pat\n        !auto = automaton pat\n        !p0 = unsafeIndex pat 0\n        bscan _ _ [] = ([], [])\n        bscan !past !sta (!(str : rest)) = match sta 0\n          where !strLen = S.length str\n                \n                {-# INLINE strAt #-}\n                \n                strAt :: Int -> Int\n                strAt i = fromIntegral (str `unsafeIndex` i)\n                match 0 idx\n                  | idx == strLen =\n                    let (fr, bk) = bscan [] 0 rest in\n                      (foldr (flip (.) . (:)) id past (str : fr), bk)\n                  | unsafeIndex str idx == p0 = match 1 (idx + 1)\n                  | otherwise = match 0 (idx + 1)\n                match state idx\n                  | idx == strLen =\n                    let (kp, !rl)\n                          = if before then keep state (str : past) else ([], str : past)\n                        (fr, bk) = bscan kp state rest\n                      in (foldr (flip (.) . (:)) id rl fr, bk)\n                  | otherwise =\n                    let !nstate = unsafeAt auto ((state `shiftL` 8) + strAt idx)\n                        !nxtIdx = idx + 1\n                      in\n                      if nstate == patLen then\n                        case if before then nxtIdx - patLen else nxtIdx of\n                            0 -> (foldr (flip (.) . (:)) id past [], str : rest)\n                            stIx | stIx < 0 -> rgo (-stIx) (str : rest) past\n                                 | stIx == strLen -> (foldr (flip (.) . (:)) id past [str], rest)\n                                 | otherwise ->\n                                   (foldr (flip (.) . (:)) id past [S.take stIx str],\n                                    S.drop stIx str : rest)\n                        else match nstate nxtIdx"],"instances":[],"language":{"extensions":["BangPatterns","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
{"sliceID":6022222497244103317,"uses":[{"reference":{"otherSlice":5290961166819491409},"usedName":{"valueName":{"identifier":"coefficient"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":5290961166819491409},"usedName":{"typeName":{"identifier":"Scientific"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"String"}},"qualification":null},{"reference":{"otherSlice":602802442221886060},"usedName":{"constructorName":{"identifier":"Generic"},"constructorTypeName":{"identifier":"FPFormat"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":5996158497258436070},"usedName":{"valueName":{"identifier":"toDecimalDigits"}},"qualification":null},{"reference":{"otherSlice":602802442221886060},"usedName":{"constructorName":{"identifier":"Exponent"},"constructorTypeName":{"identifier":"FPFormat"}},"qualification":null},{"reference":{"otherSlice":602802442221886060},"usedName":{"constructorName":{"identifier":"Fixed"},"constructorTypeName":{"identifier":"FPFormat"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"||"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":38271849687247326},"usedName":{"valueName":{"identifier":"fmtAsExponent"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":4236512482587482745},"usedName":{"valueName":{"identifier":"fmtAsFixed"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"max"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"take"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"repeat"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"otherSlice":7939095067907186733},"usedName":{"valueName":{"identifier":"roundTo"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"builtinModule":"GHC.Show"},"usedName":{"valueName":{"identifier":"intToDigit"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"init"}},"qualification":null},{"reference":{"builtinModule":"GHC.Show"},"usedName":{"valueName":{"identifier":"show"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">="}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"splitAt"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"null"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"replicate"}},"qualification":null},{"reference":{"otherSlice":602802442221886060},"usedName":{"typeName":{"identifier":"FPFormat"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null}],"fragment":["formatScientific :: FPFormat -> Maybe Int -> Scientific -> String","formatScientific format mbDecs s\n  | coefficient s < 0 = '-' : formatPositiveScientific (-s)\n  | otherwise = formatPositiveScientific s\n  where formatPositiveScientific :: Scientific -> String\n        formatPositiveScientific s'\n          = case format of\n                Generic -> fmtAsGeneric $ toDecimalDigits s'\n                Exponent -> fmtAsExponentMbDecs $ toDecimalDigits s'\n                Fixed -> fmtAsFixedMbDecs $ toDecimalDigits s'\n        \n        fmtAsGeneric :: ([Int], Int) -> String\n        fmtAsGeneric x@(_is, e)\n          | e < 0 || e > 7 = fmtAsExponentMbDecs x\n          | otherwise = fmtAsFixedMbDecs x\n        \n        fmtAsExponentMbDecs :: ([Int], Int) -> String\n        fmtAsExponentMbDecs x\n          = case mbDecs of\n                Nothing -> fmtAsExponent x\n                Just dec -> fmtAsExponentDecs dec x\n        \n        fmtAsFixedMbDecs :: ([Int], Int) -> String\n        fmtAsFixedMbDecs x\n          = case mbDecs of\n                Nothing -> fmtAsFixed x\n                Just dec -> fmtAsFixedDecs dec x\n        \n        fmtAsExponentDecs :: Int -> ([Int], Int) -> String\n        fmtAsExponentDecs dec (is, e)\n          = let dec' = max dec 1 in\n              case is of\n                  [0] -> '0' : '.' : take dec' (repeat '0') ++ \"e0\"\n                  _ -> let (ei, is') = roundTo (dec' + 1) is\n                           (d : ds') = map intToDigit (if ei > 0 then init is' else is')\n                         in d : '.' : ds' ++ 'e' : show (e - 1 + ei)\n        \n        fmtAsFixedDecs :: Int -> ([Int], Int) -> String\n        fmtAsFixedDecs dec (is, e)\n          = let dec' = max dec 0 in\n              if e >= 0 then\n                let (ei, is') = roundTo (dec' + e) is\n                    (ls, rs) = splitAt (e + ei) (map intToDigit is')\n                  in mk0 ls ++ (if null rs then \"\" else '.' : rs)\n                else\n                let (ei, is') = roundTo dec' (replicate (-e) 0 ++ is)\n                    d : ds' = map intToDigit (if ei > 0 then is' else 0 : is')\n                  in d : (if null ds' then \"\" else '.' : ds')\n          where mk0 ls\n                  = case ls of\n                        \"\" -> \"0\"\n                        _ -> ls"],"instances":[],"language":{"extensions":["DeriveDataTypeable","BangPatterns","ScopedTypeVariables","UnboxedTuples","PatternGuards","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll"],"isInstance":false}}
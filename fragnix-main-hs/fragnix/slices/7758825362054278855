{"sliceID":7758825362054278855,"uses":[{"reference":{"otherSlice":655943511058533134},"usedName":{"constructorName":{"identifier":"Scientific"},"constructorTypeName":{"identifier":"Scientific"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<"}},"qualification":null},{"reference":{"otherSlice":6499721132049218751},"usedName":{"valueName":{"identifier":"toDecimalDigits"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":2418377670000465580},"usedName":{"typeName":{"identifier":"FPFormat"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"typeName":{"identifier":"String"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"builtinModule":"GHC.Show"},"usedName":{"valueName":{"identifier":"intToDigit"}},"qualification":null},{"reference":{"otherSlice":2418377670000465580},"usedName":{"constructorName":{"identifier":"Generic"},"constructorTypeName":{"identifier":"FPFormat"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"||"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">"}},"qualification":null},{"reference":{"otherSlice":2418377670000465580},"usedName":{"constructorName":{"identifier":"Exponent"},"constructorTypeName":{"identifier":"FPFormat"}},"qualification":null},{"reference":{"otherSlice":2418377670000465580},"usedName":{"constructorName":{"identifier":"Fixed"},"constructorTypeName":{"identifier":"FPFormat"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Show"},"usedName":{"valueName":{"identifier":"show"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"++"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"error"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"identifier":"max"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"take"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"repeat"}},"qualification":null},{"reference":{"otherSlice":37493724474199123},"usedName":{"valueName":{"identifier":"roundTo"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"init"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<="}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"replicate"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"reverse"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">="}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"splitAt"}},"qualification":null},{"reference":{"builtinModule":"GHC.List"},"usedName":{"valueName":{"identifier":"null"}},"qualification":null},{"reference":{"builtinModule":"Data.Maybe"},"usedName":{"typeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":655943511058533134},"usedName":{"typeName":{"identifier":"Scientific"}},"qualification":null}],"fragment":["formatScientific :: FPFormat -> Maybe Int -> Scientific -> String","formatScientific fmt decs scntfc@(Scientific c _)\n  | c < 0 = '-' : doFmt fmt (toDecimalDigits (-scntfc))\n  | otherwise = doFmt fmt (toDecimalDigits scntfc)\n  where doFmt :: FPFormat -> ([Int], Int) -> String\n        doFmt format (is, e)\n          = let ds = map intToDigit is in\n              case format of\n                  Generic -> doFmt (if e < 0 || e > 7 then Exponent else Fixed)\n                               (is, e)\n                  Exponent -> case decs of\n                                  Nothing -> let show_e' = show (e - 1) in\n                                               case ds of\n                                                   \"0\" -> \"0.0e0\"\n                                                   [d] -> d : \".0e\" ++ show_e'\n                                                   (d : ds') -> d : '.' : ds' ++ \"e\" ++ show_e'\n                                                   [] -> error\n                                                           \"formatScientific/doFmt/FFExponent: []\"\n                                  Just dec -> let dec' = max dec 1 in\n                                                case is of\n                                                    [0] -> '0' :\n                                                             '.' : take dec' (repeat '0') ++ \"e0\"\n                                                    _ -> let (ei, is') = roundTo (dec' + 1) is\n                                                             (d : ds')\n                                                               = map intToDigit\n                                                                   (if ei > 0 then init is' else\n                                                                      is')\n                                                           in\n                                                           d : '.' : ds' ++ 'e' : show (e - 1 + ei)\n                  Fixed -> let mk0 ls\n                                 = case ls of\n                                       \"\" -> \"0\"\n                                       _ -> ls\n                             in\n                             case decs of\n                                 Nothing | e <= 0 -> \"0.\" ++ replicate (-e) '0' ++ ds\n                                         | otherwise ->\n                                           let f 0 s rs = mk0 (reverse s) ++ '.' : mk0 rs\n                                               f n s \"\" = f (n - 1) ('0' : s) \"\"\n                                               f n s (r : rs) = f (n - 1) (r : s) rs\n                                             in f e \"\" ds\n                                 Just dec -> let dec' = max dec 0 in\n                                               if e >= 0 then\n                                                 let (ei, is') = roundTo (dec' + e) is\n                                                     (ls, rs)\n                                                       = splitAt (e + ei) (map intToDigit is')\n                                                   in mk0 ls ++ (if null rs then \"\" else '.' : rs)\n                                                 else\n                                                 let (ei, is')\n                                                       = roundTo dec' (replicate (-e) 0 ++ is)\n                                                     d : ds'\n                                                       = map intToDigit\n                                                           (if ei > 0 then is' else 0 : is')\n                                                   in d : (if null ds' then \"\" else '.' : ds')"],"instances":[],"language":{"extensions":["DeriveDataTypeable","BangPatterns","ScopedTypeVariables","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
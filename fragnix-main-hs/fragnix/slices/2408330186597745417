{"sliceID":2408330186597745417,"uses":[{"reference":{"otherSlice":4136673170685477501},"usedName":{"constructorName":{"identifier":"Bin"},"constructorTypeName":{"identifier":"Map"}},"qualification":null},{"reference":{"otherSlice":4136673170685477501},"usedName":{"constructorName":{"identifier":"Tip"},"constructorTypeName":{"identifier":"Map"}},"qualification":null},{"reference":{"otherSlice":2985160912211971320},"usedName":{"valueName":{"identifier":"balanceL"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"error"}},"qualification":null},{"reference":{"otherSlice":4136673170685477501},"usedName":{"typeName":{"identifier":"Map"}},"qualification":null}],"fragment":["deleteFindMax :: Map k a -> ((k, a), Map k a)","deleteFindMax t\n  = case t of\n        Bin _ k x l Tip -> ((k, x), l)\n        Bin _ k x l r -> let (km, r') = deleteFindMax r in\n                           (km, balanceL k x l r')\n        Tip -> (error\n                  \"Map.deleteFindMax: can not return the maximal element of an empty map\",\n                Tip)"],"instances":[],"language":{"extensions":["DeriveDataTypeable","StandaloneDeriving","RoleAnnotations","TypeFamilies","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}
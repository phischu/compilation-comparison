{"sliceID":3044946264329136785,"uses":[{"reference":{"otherSlice":1904543910357874234},"usedName":{"constructorName":{"identifier":"Tip"},"constructorTypeName":{"identifier":"Set"}},"qualification":null},{"reference":{"otherSlice":1904543910357874234},"usedName":{"constructorName":{"identifier":"Bin"},"constructorTypeName":{"identifier":"Set"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">="}},"qualification":null},{"reference":{"otherSlice":7998559228765506290},"usedName":{"valueName":{"identifier":"foldlStrict"}},"qualification":null},{"reference":{"otherSlice":87150894348613268},"usedName":{"valueName":{"identifier":"insert"}},"qualification":null},{"reference":{"otherSlice":1756972569592436584},"usedName":{"valueName":{"identifier":"insertMax"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"identifier":"shiftL"}},"qualification":null},{"reference":{"otherSlice":5092005356321557259},"usedName":{"valueName":{"identifier":"link"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"identifier":"shiftR"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"typeName":{"identifier":"Ord"}},"qualification":null},{"reference":{"otherSlice":1904543910357874234},"usedName":{"typeName":{"identifier":"Set"}},"qualification":null}],"fragment":["fromList :: Ord a => [a] -> Set a","fromList [] = Tip\nfromList [x] = Bin 1 x Tip Tip\nfromList (x0 : xs0)\n  | not_ordered x0 xs0 = fromList' (Bin 1 x0 Tip Tip) xs0\n  | otherwise = go (1 :: Int) (Bin 1 x0 Tip Tip) xs0\n  where not_ordered _ [] = False\n        not_ordered x (y : _) = x >= y\n        \n        {-# INLINE not_ordered #-}\n        fromList' t0 xs = foldlStrict ins t0 xs\n          where ins t x = insert x t\n        go !_ t [] = t\n        go _ t [x] = insertMax x t\n        go s l xs@(x : xss)\n          | not_ordered x xss = fromList' l xs\n          | otherwise =\n            case create s xss of\n                (r, ys, []) -> go (s `shiftL` 1) (link x l r) ys\n                (r, _, ys) -> fromList' (link x l r) ys\n        create !_ [] = (Tip, [], [])\n        create s xs@(x : xss)\n          | s == 1 =\n            if not_ordered x xss then (Bin 1 x Tip Tip, [], xss) else\n              (Bin 1 x Tip Tip, xss, [])\n          | otherwise =\n            case create (s `shiftR` 1) xs of\n                res@(_, [], _) -> res\n                (l, [y], zs) -> (insertMax y l, [], zs)\n                (l, ys@(y : yss), _) | not_ordered y yss -> (l, [], ys)\n                                     | otherwise ->\n                                       case create (s `shiftR` 1) yss of\n                                           (r, zs, ws) -> (link y l r, zs, ws)"],"instances":[],"language":{"extensions":["BangPatterns","PatternGuards","DeriveDataTypeable","StandaloneDeriving","RoleAnnotations","TypeFamilies","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll"],"isInstance":false}}
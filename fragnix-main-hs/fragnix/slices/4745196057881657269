{"sliceID":4745196057881657269,"uses":[{"reference":{"builtinModule":"Control.Exception.Base"},"usedName":{"valueName":{"identifier":"catch"}},"qualification":"E"},{"reference":{"otherSlice":4041040564016882290},"usedName":{"constructorName":{"identifier":"Context"},"constructorTypeName":{"identifier":"Context"}},"qualification":null},{"reference":{"otherSlice":4041040564016882290},"usedName":{"valueName":{"identifier":"http2settings"}},"qualification":null},{"reference":{"otherSlice":4041040564016882290},"usedName":{"valueName":{"identifier":"streamTable"}},"qualification":null},{"reference":{"otherSlice":4041040564016882290},"usedName":{"valueName":{"identifier":"concurrency"}},"qualification":null},{"reference":{"otherSlice":4041040564016882290},"usedName":{"valueName":{"identifier":"continued"}},"qualification":null},{"reference":{"otherSlice":4041040564016882290},"usedName":{"valueName":{"identifier":"clientStreamId"}},"qualification":null},{"reference":{"otherSlice":4041040564016882290},"usedName":{"valueName":{"identifier":"inputQ"}},"qualification":null},{"reference":{"otherSlice":4041040564016882290},"usedName":{"valueName":{"identifier":"controlQ"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"otherSlice":3799123115806425041},"usedName":{"constructorName":{"identifier":"ConnectionError"},"constructorTypeName":{"identifier":"HTTP2Error"}},"qualification":null},{"reference":{"builtinModule":"GHC.Exception"},"usedName":{"valueName":{"identifier":"fromException"}},"qualification":"E"},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"readIORef"}},"qualification":null},{"reference":{"otherSlice":7836450316313632827},"usedName":{"valueName":{"identifier":"goawayFrame"}},"qualification":null},{"reference":{"otherSlice":2847764183293833005},"usedName":{"valueName":{"identifier":"enqueueControl"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"otherSlice":2096491001196216488},"usedName":{"constructorName":{"identifier":"CGoaway"},"constructorTypeName":{"identifier":"Control"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"otherSlice":7326433401287430113},"usedName":{"valueName":{"identifier":"resetFrame"}},"qualification":null},{"reference":{"otherSlice":2096491001196216488},"usedName":{"constructorName":{"identifier":"CFrame"},"constructorTypeName":{"identifier":"Control"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"builtinModule":"GHC.Conc.Sync"},"usedName":{"valueName":{"identifier":"yield"}},"qualification":null},{"reference":{"otherSlice":829999802279960389},"usedName":{"valueName":{"identifier":"frameHeaderLength"}},"qualification":null},{"reference":{"otherSlice":7202692338078551997},"usedName":{"valueName":{"identifier":"null"}},"qualification":"BS"},{"reference":{"otherSlice":2096491001196216488},"usedName":{"constructorName":{"identifier":"CFinish"},"constructorTypeName":{"identifier":"Control"}},"qualification":null},{"reference":{"otherSlice":5348049771979304736},"usedName":{"valueName":{"identifier":"decodeFrameHeader"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"when"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"otherSlice":1285600184885925655},"usedName":{"constructorName":{"identifier":"FrameHeader"},"constructorTypeName":{"identifier":"FrameHeader"}},"qualification":null},{"reference":{"otherSlice":1285600184885925655},"usedName":{"valueName":{"identifier":"streamId"}},"qualification":null},{"reference":{"otherSlice":4601536646804663288},"usedName":{"valueName":{"identifier":"isResponse"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"&&"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"notElem"}},"qualification":null},{"reference":{"otherSlice":3404358292982908639},"usedName":{"constructorName":{"identifier":"FramePriority"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"otherSlice":3404358292982908639},"usedName":{"constructorName":{"identifier":"FrameRSTStream"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"otherSlice":3404358292982908639},"usedName":{"constructorName":{"identifier":"FrameWindowUpdate"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"builtinModule":"GHC.IO"},"usedName":{"valueName":{"identifier":"throwIO"}},"qualification":"E"},{"reference":{"otherSlice":5005511013097534442},"usedName":{"constructorName":{"identifier":"ProtocolError"},"constructorTypeName":{"identifier":"ErrorCodeId"}},"qualification":null},{"reference":{"otherSlice":3404358292982908639},"usedName":{"constructorName":{"identifier":"FrameUnknown"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"otherSlice":1285600184885925655},"usedName":{"valueName":{"identifier":"payloadLength"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"otherSlice":3404358292982908639},"usedName":{"constructorName":{"identifier":"FramePushPromise"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"otherSlice":7456997103226205772},"usedName":{"valueName":{"identifier":"checkFrameHeader"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Left"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":3799123115806425041},"usedName":{"constructorName":{"identifier":"StreamError"},"constructorTypeName":{"identifier":"HTTP2Error"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Right"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"builtinModule":"Control.Exception.Base"},"usedName":{"valueName":{"identifier":"try"}},"qualification":"E"},{"reference":{"builtinModule":"GHC.Exception"},"usedName":{"valueName":{"identifier":"throw"}},"qualification":"E"},{"reference":{"otherSlice":2485077862527340610},"usedName":{"valueName":{"identifier":"isControl"}},"qualification":null},{"reference":{"otherSlice":3657869686664526164},"usedName":{"valueName":{"identifier":"control"}},"qualification":null},{"reference":{"otherSlice":8661256068812973938},"usedName":{"constructorName":{"identifier":"PriorityFrame"},"constructorTypeName":{"identifier":"FramePayload"}},"qualification":null},{"reference":{"otherSlice":8820382256421280623},"usedName":{"valueName":{"identifier":"guardIt"}},"qualification":null},{"reference":{"otherSlice":8305280325074824622},"usedName":{"valueName":{"identifier":"decodePriorityFrame"}},"qualification":null},{"reference":{"otherSlice":8512493623266531795},"usedName":{"valueName":{"identifier":"checkPriority"}},"qualification":null},{"reference":{"otherSlice":2801635089134887690},"usedName":{"constructorName":{"identifier":"Stream"},"constructorTypeName":{"identifier":"Stream"}},"qualification":null},{"reference":{"otherSlice":2801635089134887690},"usedName":{"valueName":{"identifier":"streamState"}},"qualification":null},{"reference":{"otherSlice":2801635089134887690},"usedName":{"valueName":{"identifier":"streamPrecedence"}},"qualification":null},{"reference":{"otherSlice":569502842599408406},"usedName":{"valueName":{"identifier":"stream"}},"qualification":null},{"reference":{"otherSlice":4015603071341496419},"usedName":{"constructorName":{"identifier":"Open"},"constructorTypeName":{"identifier":"StreamState"}},"qualification":null},{"reference":{"otherSlice":6773935588081563152},"usedName":{"constructorName":{"identifier":"NoBody"},"constructorTypeName":{"identifier":"OpenState"}},"qualification":null},{"reference":{"otherSlice":6665381595375594482},"usedName":{"valueName":{"identifier":"readInt"}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"operator":"<$>"}},"qualification":null},{"reference":{"otherSlice":6900724541411838377},"usedName":{"valueName":{"identifier":"getHeaderValue"}},"qualification":null},{"reference":{"otherSlice":2614460488900874285},"usedName":{"valueName":{"identifier":"tokenContentLength"}},"qualification":null},{"reference":{"otherSlice":27785736963186051},"usedName":{"valueName":{"identifier":"just"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"writeIORef"}},"qualification":null},{"reference":{"otherSlice":7166906186427769224},"usedName":{"valueName":{"identifier":"toPrecedence"}},"qualification":null},{"reference":{"otherSlice":4015603071341496419},"usedName":{"constructorName":{"identifier":"HalfClosed"},"constructorTypeName":{"identifier":"StreamState"}},"qualification":null},{"reference":{"builtinModule":"GHC.Conc.Sync"},"usedName":{"valueName":{"identifier":"atomically"}},"qualification":null},{"reference":{"otherSlice":8509858668053217108},"usedName":{"valueName":{"identifier":"writeTQueue"}},"qualification":null},{"reference":{"otherSlice":3945285669814970459},"usedName":{"constructorName":{"identifier":"Input"},"constructorTypeName":{"identifier":"Input"}},"qualification":null},{"reference":{"otherSlice":6773935588081563152},"usedName":{"constructorName":{"identifier":"HasBody"},"constructorTypeName":{"identifier":"OpenState"}},"qualification":null},{"reference":{"otherSlice":1306416343409347104},"usedName":{"valueName":{"identifier":"newTQueueIO"}},"qualification":null},{"reference":{"builtinModule":"GHC.IORef"},"usedName":{"valueName":{"identifier":"newIORef"}},"qualification":null},{"reference":{"otherSlice":6773935588081563152},"usedName":{"constructorName":{"identifier":"Body"},"constructorTypeName":{"identifier":"OpenState"}},"qualification":null},{"reference":{"otherSlice":6456255109150393305},"usedName":{"valueName":{"identifier":"newReadBody"}},"qualification":null},{"reference":{"otherSlice":5711996411912101929},"usedName":{"valueName":{"identifier":"mkSource"}},"qualification":null},{"reference":{"otherSlice":5305167733554199752},"usedName":{"valueName":{"identifier":"readSource"}},"qualification":null},{"reference":{"otherSlice":6773935588081563152},"usedName":{"constructorName":{"identifier":"Continued"},"constructorTypeName":{"identifier":"OpenState"}},"qualification":null},{"reference":{"otherSlice":3404358292982908639},"usedName":{"constructorName":{"identifier":"FrameContinuation"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"otherSlice":3801810361162443572},"usedName":{"valueName":{"identifier":"search"}},"qualification":null},{"reference":{"otherSlice":3404358292982908639},"usedName":{"constructorName":{"identifier":"FrameHeaders"},"constructorTypeName":{"identifier":"FrameTypeId"}},"qualification":null},{"reference":{"otherSlice":1730795819762616219},"usedName":{"valueName":{"identifier":"isHalfClosed"}},"qualification":null},{"reference":{"otherSlice":5005511013097534442},"usedName":{"constructorName":{"identifier":"StreamClosed"},"constructorTypeName":{"identifier":"ErrorCodeId"}},"qualification":null},{"reference":{"otherSlice":8379669888266992858},"usedName":{"valueName":{"identifier":"isIdle"}},"qualification":null},{"reference":{"otherSlice":2471548441821594622},"usedName":{"valueName":{"identifier":"opened"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"<="}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">="}},"qualification":null},{"reference":{"otherSlice":6138165947125340336},"usedName":{"valueName":{"identifier":"maxConcurrency"}},"qualification":null},{"reference":{"otherSlice":5005511013097534442},"usedName":{"constructorName":{"identifier":"RefusedStream"},"constructorTypeName":{"identifier":"ErrorCodeId"}},"qualification":null},{"reference":{"otherSlice":6400076285833186274},"usedName":{"valueName":{"identifier":"initialWindowSize"}},"qualification":null},{"reference":{"otherSlice":2734394067027500782},"usedName":{"valueName":{"identifier":"newStream"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"otherSlice":3945725472456966921},"usedName":{"valueName":{"identifier":"insert"}},"qualification":null},{"reference":{"builtinModule":"Data.Functor"},"usedName":{"valueName":{"identifier":"void"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":4041040564016882290},"usedName":{"typeName":{"identifier":"Context"}},"qualification":null},{"reference":{"otherSlice":8542872695666035917},"usedName":{"typeName":{"identifier":"MkReq"}},"qualification":null},{"reference":{"otherSlice":2439198389408872677},"usedName":{"typeName":{"identifier":"BufSize"}},"qualification":null},{"reference":{"otherSlice":4010822550476529195},"usedName":{"typeName":{"identifier":"ByteString"}},"qualification":null}],"fragment":["frameReceiver ::\n              Context -> MkReq -> (BufSize -> IO ByteString) -> IO ()","frameReceiver ctx mkreq recvN = loop 0 `E.catch` sendGoaway\n  where Context{http2settings, streamTable, concurrency, continued,\n                clientStreamId, inputQ, controlQ}\n          = ctx\n        sendGoaway e\n          | Just (ConnectionError err msg) <- E.fromException e =\n            do csid <- readIORef clientStreamId\n               let !frame = goawayFrame csid err msg\n               enqueueControl controlQ $ CGoaway frame\n          | otherwise = return ()\n        sendReset err sid\n          = do let !frame = resetFrame err sid\n               enqueueControl controlQ $ CFrame frame\n        \n        loop :: Int -> IO ()\n        loop !n\n          | n == 6 =\n            do yield\n               loop 0\n          | otherwise =\n            do hd <- recvN frameHeaderLength\n               if BS.null hd then enqueueControl controlQ CFinish else\n                 do cont <- processStreamGuardingError $ decodeFrameHeader hd\n                    when cont $ loop (n + 1)\n        processStreamGuardingError (fid, FrameHeader{streamId})\n          | isResponse streamId &&\n              (fid `notElem` [FramePriority, FrameRSTStream, FrameWindowUpdate])\n            =\n            E.throwIO $ ConnectionError ProtocolError \"stream id should be odd\"\n        processStreamGuardingError\n          (FrameUnknown _, FrameHeader{payloadLength})\n          = do mx <- readIORef continued\n               case mx of\n                   Nothing -> do consume payloadLength\n                                 return True\n                   Just _ -> E.throwIO $ ConnectionError ProtocolError \"unknown frame\"\n        processStreamGuardingError (FramePushPromise, _)\n          = E.throwIO $\n              ConnectionError ProtocolError \"push promise is not allowed\"\n        processStreamGuardingError\n          typhdr@(ftyp, header@FrameHeader{payloadLength})\n          = do settings <- readIORef http2settings\n               case checkFrameHeader settings typhdr of\n                   Left h2err -> case h2err of\n                                     StreamError err sid -> do sendReset err sid\n                                                               consume payloadLength\n                                                               return True\n                                     connErr -> E.throwIO connErr\n                   Right _ -> do ex <- E.try $ controlOrStream ftyp header\n                                 case ex of\n                                     Left (StreamError err sid) -> do sendReset err sid\n                                                                      return True\n                                     Left connErr -> E.throw connErr\n                                     Right cont -> return cont\n        controlOrStream ftyp header@FrameHeader{streamId, payloadLength}\n          | isControl streamId =\n            do pl <- recvN payloadLength\n               control ftyp header pl ctx\n          | otherwise =\n            do checkContinued\n               !mstrm <- getStream\n               pl <- recvN payloadLength\n               case mstrm of\n                   Nothing -> do when (ftyp == FramePriority) $\n                                   do PriorityFrame newpri <- guardIt $\n                                                                decodePriorityFrame header pl\n                                      checkPriority newpri streamId\n                                 return True\n                   Just\n                     strm@Stream{streamState, streamPrecedence} -> do state <- readIORef\n                                                                                 streamState\n                                                                      state' <- stream ftyp header\n                                                                                  pl\n                                                                                  ctx\n                                                                                  state\n                                                                                  strm\n                                                                      case state' of\n                                                                          Open\n                                                                            (NoBody tbl@(_, reqvt)\n                                                                               pri) -> do resetContinued\n                                                                                          let mcl\n                                                                                                = readInt\n                                                                                                    <$>\n                                                                                                    getHeaderValue\n                                                                                                      tokenContentLength\n                                                                                                      reqvt\n                                                                                          when\n                                                                                            (just\n                                                                                               mcl\n                                                                                               (== (0 ::\n                                                                                                      Int)))\n                                                                                            $\n                                                                                            E.throwIO\n                                                                                              $\n                                                                                              StreamError\n                                                                                                ProtocolError\n                                                                                                streamId\n                                                                                          writeIORef\n                                                                                            streamPrecedence\n                                                                                            $\n                                                                                            toPrecedence\n                                                                                              pri\n                                                                                          writeIORef\n                                                                                            streamState\n                                                                                            HalfClosed\n                                                                                          (!req,\n                                                                                           !ii) <- mkreq\n                                                                                                     tbl\n                                                                                                     (Just\n                                                                                                        0,\n                                                                                                      return\n                                                                                                        \"\")\n                                                                                          atomically\n                                                                                            $\n                                                                                            writeTQueue\n                                                                                              inputQ\n                                                                                              $\n                                                                                              Input\n                                                                                                strm\n                                                                                                req\n                                                                                                reqvt\n                                                                                                ii\n                                                                          Open\n                                                                            (HasBody tbl@(_, reqvt)\n                                                                               pri) -> do resetContinued\n                                                                                          q <- newTQueueIO\n                                                                                          let !mcl\n                                                                                                = readInt\n                                                                                                    <$>\n                                                                                                    getHeaderValue\n                                                                                                      tokenContentLength\n                                                                                                      reqvt\n                                                                                          writeIORef\n                                                                                            streamPrecedence\n                                                                                            $\n                                                                                            toPrecedence\n                                                                                              pri\n                                                                                          bodyLength <- newIORef\n                                                                                                          0\n                                                                                          writeIORef\n                                                                                            streamState\n                                                                                            $\n                                                                                            Open\n                                                                                              (Body\n                                                                                                 q\n                                                                                                 mcl\n                                                                                                 bodyLength)\n                                                                                          readQ <- newReadBody\n                                                                                                     q\n                                                                                          bodySource <- mkSource\n                                                                                                          readQ\n                                                                                          (!req,\n                                                                                           !ii) <- mkreq\n                                                                                                     tbl\n                                                                                                     (mcl,\n                                                                                                      readSource\n                                                                                                        bodySource)\n                                                                                          atomically\n                                                                                            $\n                                                                                            writeTQueue\n                                                                                              inputQ\n                                                                                              $\n                                                                                              Input\n                                                                                                strm\n                                                                                                req\n                                                                                                reqvt\n                                                                                                ii\n                                                                          s@(Open\n                                                                               Continued{}) -> do setContinued\n                                                                                                  writeIORef\n                                                                                                    streamState\n                                                                                                    s\n                                                                          s -> do resetContinued\n                                                                                  writeIORef\n                                                                                    streamState\n                                                                                    s\n                                                                      return True\n          where setContinued = writeIORef continued (Just streamId)\n                resetContinued = writeIORef continued Nothing\n                checkContinued\n                  = do mx <- readIORef continued\n                       case mx of\n                           Nothing -> return ()\n                           Just sid | sid == streamId && ftyp == FrameContinuation ->\n                                      return ()\n                                    | otherwise ->\n                                      E.throwIO $\n                                        ConnectionError ProtocolError\n                                          \"continuation frame must follow\"\n                getStream\n                  = do mstrm0 <- search streamTable streamId\n                       case mstrm0 of\n                           js@(Just strm0) -> do when (ftyp == FrameHeaders) $\n                                                   do st <- readIORef $ streamState strm0\n                                                      when (isHalfClosed st) $\n                                                        E.throwIO $\n                                                          ConnectionError StreamClosed\n                                                            \"header must not be sent to half closed\"\n                                                      when (isIdle st) $ opened ctx strm0\n                                                 return js\n                           Nothing | isResponse streamId -> return Nothing\n                                   | otherwise ->\n                                     do when (ftyp `notElem` [FrameHeaders, FramePriority]) $\n                                          E.throwIO $\n                                            ConnectionError ProtocolError\n                                              \"this frame is not allowed in an idel stream\"\n                                        csid <- readIORef clientStreamId\n                                        if streamId <= csid then\n                                          do if ftyp == FramePriority then return Nothing else\n                                               E.throwIO $\n                                                 ConnectionError ProtocolError\n                                                   \"stream identifier must not decrease\"\n                                          else\n                                          do when (ftyp == FrameHeaders) $\n                                               do writeIORef clientStreamId streamId\n                                                  cnt <- readIORef concurrency\n                                                  when (cnt >= maxConcurrency) $\n                                                    E.throwIO $ StreamError RefusedStream streamId\n                                             ws <- initialWindowSize <$> readIORef http2settings\n                                             newstrm <- newStream streamId (fromIntegral ws)\n                                             when (ftyp == FrameHeaders) $ opened ctx newstrm\n                                             insert streamTable streamId newstrm\n                                             return $ Just newstrm\n        consume = void . recvN"],"instances":[],"language":{"extensions":["OverloadedStrings","NamedFieldPuns","BangPatterns","PatternGuards","MultiParamTypeClasses","NondecreasingIndentation","ExplicitForAll"],"isInstance":false}}
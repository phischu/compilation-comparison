{"sliceID":4844500896780252551,"uses":[{"reference":{"otherSlice":1541402738797772585},"usedName":{"typeName":{"identifier":"Regex"}},"qualification":null},{"reference":{"builtinModule":"Foreign.C.String"},"usedName":{"typeName":{"identifier":"CString"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"IO"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"typeName":{"identifier":"Either"}},"qualification":null},{"reference":{"otherSlice":106396208025620094},"usedName":{"typeName":{"identifier":"WrapError"}},"qualification":null},{"reference":{"otherSlice":8059339572671343219},"usedName":{"typeName":{"identifier":"MatchArray"}},"qualification":null},{"reference":{"otherSlice":1541402738797772585},"usedName":{"constructorName":{"identifier":"Regex"},"constructorTypeName":{"identifier":"Regex"}},"qualification":null},{"reference":{"otherSlice":498108700764045428},"usedName":{"valueName":{"identifier":"nullTest"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"$"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"/="}},"qualification":null},{"reference":{"otherSlice":1310776574081630583},"usedName":{"valueName":{"identifier":"compNoSub"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"operator":".&."}},"qualification":null},{"reference":{"otherSlice":841163542554592407},"usedName":{"valueName":{"identifier":"wrapTest"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Right"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"True"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"return"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"constructorName":{"identifier":"False"},"constructorTypeName":{"identifier":"Bool"}},"qualification":null},{"reference":{"builtinModule":"Data.Either"},"usedName":{"constructorName":{"identifier":"Left"},"constructorTypeName":{"identifier":"Either"}},"qualification":null},{"reference":{"builtinModule":"Foreign.ForeignPtr"},"usedName":{"valueName":{"identifier":"withForeignPtr"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Storable"},"usedName":{"valueName":{"identifier":"peekByteOff"}},"qualification":null},{"reference":{"builtinModule":"Foreign.C.Types"},"usedName":{"typeName":{"identifier":"CSize"}},"qualification":null},{"reference":{"builtinModule":"GHC.Types"},"usedName":{"typeName":{"identifier":"Int"}},"qualification":null},{"reference":{"builtinModule":"GHC.Real"},"usedName":{"valueName":{"identifier":"fromIntegral"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"+"}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"*"}},"qualification":null},{"reference":{"builtinModule":"Foreign.Marshal.Alloc"},"usedName":{"valueName":{"identifier":"allocaBytes"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"identifier":"complement"}},"qualification":null},{"reference":{"otherSlice":4590599657527590350},"usedName":{"valueName":{"identifier":"execNotBOL"}},"qualification":null},{"reference":{"builtinModule":"Data.Bits"},"usedName":{"valueName":{"operator":".|."}},"qualification":null},{"reference":{"otherSlice":6431175393264208140},"usedName":{"valueName":{"identifier":"doMatch"}},"qualification":null},{"reference":{"builtinModule":"GHC.Ptr"},"usedName":{"valueName":{"identifier":"plusPtr"}},"qualification":null},{"reference":{"builtinModule":"GHC.Prim"},"usedName":{"valueName":{"identifier":"seq"}},"qualification":null},{"reference":{"builtinModule":"GHC.Err"},"usedName":{"valueName":{"identifier":"undefined"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":"=="}},"qualification":null},{"reference":{"otherSlice":4624094115744203607},"usedName":{"valueName":{"identifier":"isNull"}},"qualification":null},{"reference":{"builtinModule":"GHC.Enum"},"usedName":{"valueName":{"identifier":"succ"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"otherwise"}},"qualification":null},{"reference":{"otherSlice":4624094115744203607},"usedName":{"valueName":{"identifier":"isNewline"}},"qualification":null},{"reference":{"builtinModule":"GHC.Enum"},"usedName":{"valueName":{"identifier":"pred"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Nothing"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"constructorName":{"identifier":"Just"},"constructorTypeName":{"identifier":"Maybe"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"operator":"."}},"qualification":null},{"reference":{"otherSlice":8898595847961145836},"usedName":{"typeName":{"identifier":"RegOffset"}},"qualification":null},{"reference":{"builtinModule":"GHC.Arr"},"usedName":{"typeName":{"identifier":"Array"}},"qualification":null},{"reference":{"builtinModule":"GHC.Arr"},"usedName":{"valueName":{"identifier":"listArray"}},"qualification":null},{"reference":{"builtinModule":"Data.Foldable"},"usedName":{"valueName":{"identifier":"length"}},"qualification":null},{"reference":{"builtinModule":"GHC.Base"},"usedName":{"valueName":{"identifier":"map"}},"qualification":null},{"reference":{"builtinModule":"GHC.Classes"},"usedName":{"valueName":{"operator":">="}},"qualification":null},{"reference":{"builtinModule":"GHC.Num"},"usedName":{"valueName":{"operator":"-"}},"qualification":null}],"fragment":["wrapMatchAll ::\n             Regex -> CString -> IO (Either WrapError [MatchArray])","wrapMatchAll regex@(Regex regex_fptr compileOptions flags) cstr\n  = do nullTest cstr \"wrapMatchAll cstr\" $\n         do if (0 /= compNoSub .&. compileOptions) then\n              do r <- wrapTest regex cstr\n                 case r of\n                     Right True -> return (Right [(toMA 0 [])])\n                     Right False -> return (Right [])\n                     Left err -> return (Left err)\n              else\n              do withForeignPtr regex_fptr $\n                   \\ regex_ptr ->\n                     do nsub <- ((\\ hsc_ptr -> peekByteOff hsc_ptr 48)) regex_ptr ::\n                                  IO CSize\n                        let nsub_int, nsub_bytes :: Int\n                            nsub_int = fromIntegral nsub\n                            nsub_bytes = ((1 + nsub_int) * (8))\n                        allocaBytes nsub_bytes $\n                          \\ p_match ->\n                            do nullTest p_match \"wrapMatchAll p_match\" $\n                                 do let flagsBOL = (complement execNotBOL) .&. flags\n                                        flagsMIDDLE = execNotBOL .|. flags\n                                        atBOL pos\n                                          = doMatch regex_ptr (plusPtr cstr pos) nsub p_match\n                                              flagsBOL\n                                        atMIDDLE pos\n                                          = doMatch regex_ptr (plusPtr cstr pos) nsub p_match\n                                              flagsMIDDLE\n                                        loop acc old (s, e)\n                                          | acc `seq` old `seq` False = undefined\n                                          | s == e =\n                                            do let pos = old + fromIntegral e\n                                               atEnd <- isNull cstr pos\n                                               if atEnd then return (Right (acc [])) else\n                                                 loop acc old (s, succ e)\n                                          | otherwise =\n                                            do let pos = old + fromIntegral e\n                                               prev'newline <- isNewline cstr (pred pos)\n                                               result <- if prev'newline then atBOL pos else\n                                                           atMIDDLE pos\n                                               case result of\n                                                   Right Nothing -> return (Right (acc []))\n                                                   Right (Just parts@(whole : _)) -> let ma\n                                                                                           = toMA\n                                                                                               pos\n                                                                                               parts\n                                                                                       in\n                                                                                       loop\n                                                                                         (acc .\n                                                                                            (ma :))\n                                                                                         pos\n                                                                                         whole\n                                                   Left err -> return (Left err)\n                                                   Right (Just []) -> return\n                                                                        (Right\n                                                                           (acc [(toMA pos [])]))\n                                    result <- doMatch regex_ptr cstr nsub p_match flags\n                                    case result of\n                                        Right Nothing -> return (Right [])\n                                        Right (Just parts@(whole : _)) -> let ma = toMA 0 parts in\n                                                                            loop (ma :) 0 whole\n                                        Left err -> return (Left err)\n                                        Right (Just []) -> return (Right [(toMA 0 [])])\n  where toMA ::\n             Int -> [(RegOffset, RegOffset)] -> Array Int (Int, Int)\n        toMA pos [] = listArray (0, 0) [(pos, 0)]\n        toMA pos parts\n          = listArray (0, pred (length parts)) .\n              map\n                (\\ (s, e) ->\n                   if s >= 0 then (pos + fromIntegral s, fromIntegral (e - s)) else\n                     (-1, 0))\n              $ parts"],"instances":[],"language":{"extensions":["MultiParamTypeClasses","FunctionalDependencies","ForeignFunctionInterface","GeneralizedNewtypeDeriving","FlexibleContexts","TypeSynonymInstances","FlexibleInstances","NondecreasingIndentation","ExplicitForAll","PatternGuards"],"isInstance":false}}